*************************************************************************************
This document represents items that jumped out at me as needing to be studied for Java interviews at a point in time.
Since in the future, different items would jump out at me based on the experience I have between now and then, it is only an artifact of this moment in time.
Going forward, I should review the actual notebooks, but this is so I can study up quickly at first.
Also, the interview tips section is only in here (not elsewhere).
*************************************************************************************

[Online Documentation]
searching for Java Stream, for instance, gives you a Java 8 result
add 17 to the search string to get Java 17 results
as a result of this, a lot of the info in here may be limited to 8 unnecessarily

also, sometimes methods aren't listed in the main list but are listed as being included by other things
	be careful!

[Variables]
String
boolean [true, false]
byte, short, int, long
char is 16-bit (like short)
	most characters are same as ascii because using utf-8
float (32-bit), double (64-bit)
no unsigned
L for long literal (instead of int)
f for float literal (instead of double)
	d for double literal also
exponential notation: 1E9, 0.79E-7, 1.0E+9f, 1.0e9, etc.
C++ style quoting for strings and chars

interning for numbers and strings
all reference types are nullable
primitive value types are not Object and have boxed equivalents (which have static things too)

== reference or primitive value, .equals() contents, .compareTo() lex, Object.equals() null safe
implicit widening, c-style narrowing (truncates)
	numeric conversions via cast operator only work for primitives
	to do it for boxed types, use methods like intValue()
		these come from the superclass, Number

float near-equality just via Math.abs() on difference and < tolerance
Double.NaN, Double.POSITIVE_INFINITY, Double.isNaN(), Double.isInfinite()

'final' for all constants (but only reference locked)
	local variables and class members
	also for preventing overrides (same keyword)
'var' keyword for type inference
no typedef
variable scoping like C++ instead of Python
no local inline statics (only class members)

Enums
	enum MyEnum { VALUE1, VALUE2 }
	enum MyEnum { VALUE1(0), VALUE2(1); MyEnum(int val) {} }
	enum MyEnum { VALUE1, VALUE2; public void someOtherMember() {}}
	MyEnum e = MyEnum.VALUE1;
	if (e == MyEnum.VALUE1) {}

	actually defines a class that inherits from java.lang.Enum
		which makes all enums REFERENCE TYPES
			and thus nullable
		certain members like equals() are made final
	c'tor is private and can only be called by the values
		has default if none provided (no value specified in the values)
		nobody else can call the constructor
	values at the top are public static final instances
		combined with new() not working, means == always safe
		if any values provided with (), must have a c'tor
	other members can be made private, public, whatever
	could actually ignore what is passed into c'tor and == would still work
		because still a separate instance for each value
		== does nothing with any data owned by the enum, that is for its own use
	
	e.ordinal() for 0-based Index (regardless of actual value)
	MyEnum.values() for MyEnum[] of all the constant values (just what's defined, no gaps filled or sentinels)
		you can then read their ordinals and any public data defined in the enum
		ordinals are indices into this array

	== 5
		doesn't work because not a number like C++

	e.toString()
		the literal name of the value (eg. VALUE1)
	Enum.valueOf(MyEnum.class, "VALUE1")
		string to enum

	to use numbers (or any # of any type of thing) instead of ordinals:
		provide your own method such as intValue() to get it
		provide your own static method such as valueOf() to loop values() and find Matching
		this is recommended over using ordinals because it's more resilient to inserts and deletions

	Constant-Specific Class body
		enum MyOperation {
			ADD {
				public double apply(double x, double y) { return x + y; }
				public void f() {}
			},
			SUBTRACT {
				public double apply(double x, double y) { return x - y; }
			};

			abstract double apply(double x, double y);
		}
		MyOperation.ADD.apply(10, 20);	// YES
		MyOperation.ADD.f(); // NO
	Enum inheriting interface
		interface Operation {
			double apply(double x, double y);
		}

		enum MyOperation implements Operation {
			ADD {
				public double apply(double x, double y) { return x + y; }
			},
			SUBTRACT {
				public double apply(double x, double y) { return x - y; }
			};
		}

		same as above but interface specifies the abstract method so enum doesn't have to
	Extensible Enums
		a design pattern that makes use of the above
		you can make multiple enums that inherit the same interface
		then code to the interface (eg. Operation) instead of the enum
		in the future people can make more enums and add more constants, but the callee doesn't care
	Static Imports
		import static java.lang.annotation.ElementType.*;
			now you can use METHOD, etc. as if top-level constants

uninitialized values have sensible defaults inc. null for reference and numeric 0s for numbers
	however, local variables are still required to be initialized before use or compile error
		ok to initialize in conditional blocks if exhuastive
		same rule whether final or not
	final class instance variables also have to be initialized before use
		have to be initialized by end of c'tor body (can be inline, in a block, in the c'tor)
		can only be set once, but can be set in a conditional, etc.

[Collections]
in general, ranges are inclusive lower bound and exclusive upper bound
sizes in Java are int, which is signed, so collections have a 2 giga-element limit

literal, indexer, etc. only available for arrays, which are a weird type in general
	others only use methods
array can take primitive types but the others must take boxed types
arrays cannot be concated directly (either with + or with a method)
	you could use streams or something else to do so

int[] numbers = {1, 2, 3, 4, 5}; // fixed size, mutable contents
f(new int[] {1, 2, 3});		// only way to pass an array literal
you cannot skip items or leave off the end like in C++
numbers[0]
numbers.length
Arrays.sort(numbers)
int[][] numbers = {{1, 2}, {3, 4}}
	multidimensional array, but actually array of arrays
	numbers.length is 2 here
	new int[10][] allowed (get 10 nulls)
	new int[][10] not allowed (meaningless)
	new int[10][10] allowed (100 0s)

for (var x : numbers) {} // This is the only thing here that matches other collections
no way to take subarray without making copy
	pass indices or make your own ArraySlice wrapper

Arrays class
	lots of these methods are overloaded for all the primitive types
		in many cases where generic things like streams are hard to use with primitives, this is helpful

	java.util.Arrays
	static methods to do collection operations on arrays
		in-place mutability
	searching, sorting, conversion to string, equality, filling, etc.
		a lot of overloads such as ranges, comparators, etc.

	asList() is varargs and thus can take an array or individual arguments
	the list it returns is a mutable view on the original array (2-way mutable) but cannot be resized
	
	list.toArray() makes a separate array copy instead of acting like this

	toString() needed because arr.toString() doesn't work as expected

	hashCode() to get hash code of an array of Object

	equals()
	copyOf(original, length)
		truncates or pads with zeros
	copyOfRange(original, from, to)
	parallelSort()
	members overloaded for primitive types

	if arrays might be members of the array, you should use:
		deepToString, deepEquals, deepHashCode
		these will recursively expand the next level down

java.util.* for collection interfaces and implementations

List<T> interface
	ArrayList<T> implementation (like c++ vector)
		c'tor overloads to take collection or initial capacity
	LinkedList<T> implementation
list.add(item)
list.add(index, item)	// insert operation
list.addAll(iterable)
list.get(index)
list.set(index, item)
	you cannot reify the list by setting past the end
list.remove(index)
list.remove(item)
	depends on item.equals() [or both being null] to find FIRST MATCh
list.removeAll(iterable)
list.removeIf(predicate)
list.contains(item)
list.containsAll(iterable)
list.indexOf(item)
list.lastIndexOf(item)
list.size() // instead of .length like with array
list.isEmpty()
list.clear()
list.sort(comparitor) // null for default sort, lambda of 2 things otherwise
	eg. Integer.compare can be used
Collections.sort(list)
Collections.reverseOrder()
list.subList(from, to)	// inclusive, exclusive bounds, gets new List<T>
	this is how you slice, and it's a mutable window into the original
	you can modify, append, etc.
	changing length of source invalidates (exception thrown next time read or use)
	if have chain of sublists, they delegate back to each other
		changing length of most derived changes length of others
		changing length of source invalidates more derived
		not the most efficient of doing recursion like in Quicksort
list.toArray()		// will give Object[]
list.toArray(T[] a)	// to force proper runtime type
for (var x : list) {}

Set<T> interface
	HashSet<T> implementation
	EnumSet<T> implementation (for bitfield)
	more or less looks like List<T> but with no indices
		by default you can assume most generic collection stuff in List is here too
	normally, a Set will be O(1) lookup
		TreeSet is an exception (covered later)

	a lot of methods that change the set return a boolean
		this indicates if it was actually changed
			even if only 1 piece changed (such as set union where 1 value is added out of 100)
		eg. s.add(10) would return false if 10 was already in the set
		eg. s.remove(10) would return false if 10 was not in the set
		the set will not throw in these cases, unlike a list out of index situation
		methods that mutate and return boolean are idempotent on the set
			the set will be the same no matter how many times you call in a row
		these methods take collections (not varargs)
			List.of() or Set.of() is equally fine
	
	contains()/containsAll() return boolean but don't mutate

	add*, remove*, and retainAll are operations that take another set and mutate
		add() and addAll() return boolean indicating if anything was added (not there before)
			this is a SET UNION
		remove() and removeAll() return boolean indicating if anything was removed (there before)
			this is a SET DIFFERENCE
		retainAll() returns boolean indicating if any items were removed that were not in the input set
			this is a SET INTERSECTION

Map<TKey, TValue> interface
	Hashtable<TKey, TValue> implementation (order not guaranteed)
		old and not performant, but is thread-safe
	HashMap<> = recommended for non-multi-threaded
	java.util.concurrent.ConcurrentHashMap = recommended for multithreaded
	LinkedHashMap<TKey, TValue> implementation (ordered by insertion)
	TreeMap<> = ordered by key natural order
	EnumMap<> = enum key version
a lot like List<T> except use keys instead of indices and:
	.get() returns null if not present (instead of throwing)
		can be ambiguous with a true null value (check containsKey if that matters)
	.put() instead of .set()/.add()
		returns previous value (null if new key)
	.containsKey() and .containsValue() instead of just contains
		work properly in case of value being null
.putIfAbsent()
	returns existing value if present (without changing it)
	returns null if absent (and sets it)
	can be tricked by null values
.putAll()
	put all values from another map
iterate keys with .keySet() which gets a Set<TKey>
iterate values with .values() which gets a Collection<TValue>
	iterable collection in case order matters, but for HashMap it doesn't
.getOrDefault(key, defaultValue)
.remove(key)
	returns null if not there or if value is null
	returns value key had otherwise
	doesn't throw
.remove(key, value)
	same but only if value matches
	returns boolean indicating if removed
.replace(key, newValue)
	returns old value if present
	null if absent (and doesn't modify)
	also has overloads to include old value, and to do bifunctions of k,v to v
.merge(key, defaultValue, binaryOperatorToCombineValues)
	if key is absent, gets set to defaultValue
	if key is present, gets set to defaultValue combined with existing value by operator
	if operator returns null, key is removed
	returns new value (or null on removal)
.entrySet() gets a set of Map.Entry<TKey, TValue>
	you can use getValue() and getKey() to see the members
	you can use setValue() to modify the value (which affects the map!)
	Map.Entry is an interface
		concrete ones are in java.util.AbstractMap
			SimpleEntry - normal one
			SimpleImmutableEntry - for thread-safe maps
			both have c'tors that can take an entry or a key and value
		also some static members like comparables
.size() tells you how many entries
.compute*() variants used to update and get atomically
	.compute(key, (k,v) -> newValue)
		returns newValue
		if key is not present, value comes into the lambda null
	.computeIfAbsent(key, k -> newValue)
		returns newValue if added
			existing value if not added
	.computeIfPresent(key, (k,v) -> newValue)
		returns newValue if absent, old value if present
	can be tricked by null values into thinking not present
.forEach((k,v) -> ) instead of entries or keys or something
one-liner patterns
	not always worth it, esp. if O(1) map [but maybe more for TreeMap]
	not as clear to read and may have performance drawback due to extra indirection
	probably want to use helper methods for readability if use these

	map of list entries
		map.computeIfAbsent(key, k -> new ArrayList<>()).add(100);
	count value
		map.merge(key, 1, Integer::sum);
	dissappearing key on count reaching zero
		map.merge(key, -1, (a, b) -> a + b == 0 ? null : a + b);

TreeSet
	TreeSet<T> is a Set<T> implementation
	it also implements NavigableSet<T> which extends SortedSet<T>
	because it uses a self-balancing binary search tree (based on natural order or constructor comparator)
		lookup is O(logN) instead of O(1)
		thus, the more specialized set operations and idempotency may be more important
	you can construct based on another SortedSet or any collection as well

	Set<T> members all implemented but backed by binary search tree
	SortedSet<T> members
		first(), last() which throw like List would
		headSet(exclusiveItem), tailSet(inclusiveItem), subSet(inclusiveItem, exclusiveItem)
	NavigableSet<T> members
		treat the set like a numeric sequence and return null for non-existing things
		pollFirst(), pollLast() are like first() and last() but get null instead of throwing if not there
		ceiling() and floor() to get value past or just before (or equal to) given value
		higher() and lower() are similar but treat the value exclusively
		descendingSet() gives you a view of the sorted set with all relationships reversed
			so higher() would give you a smaller value for instance

TreeMap
	TreeMap<T> is a Map<T> implementation
	it also implements NavigableMap<T> which extends SortedMap<T>
	like TreeSet, it uses a self-balancing binary tree for the keys
		natural order or comparator passed to constructor
		lookup O(logN) instead of O(1)
		might make it more useful to use the crazy one-liners
	
	the interface is very similar to TreeSet
	most operations in TreeSet (eg. ceiling, floor, etc.) have an Entry vs. Key variants
		eg. floorKey
		eg. ceilingEntry
		the entry versions can be used to modify the map in-place just like with entrySet()
	in addition, you have firstKey(), lastKey(), firstEntry(), lastEntry()
	instead of that for tail, sub, and head, it's the whole map (because multiple things)
		tailMap(), headMap(), subMap()
	pollFirstEntry() and pollLastEntry() but not pollFirstKey() or pollLastKey() for some reason
	descendingMap() gives you reversed view
	navigableKeySet() gives you keys as sorted set
		keySet() also maintains the order though

Bitfields (EnumSet)
	EnumSet is built for an enum type and maps 1 enum value per bit as a bitmask
	you use static methods of EnumSet to create them and then treat like any other set
	EnumSet.of(val1, val2)
	EnumSet.allOf(MyEnum.class)
	EnumSet.noneOf(MyEnum.class)
	EnumSet.complementOf(otherSet)
EnumMap
	built around an enum type - uses fixed size array based on knowledge of total keys
	new EnumMap(MyEnum.class)
	new EnumMap(otherEnumMap)

StringBuilder
	append() // instead of add()
		overloaded for a lot of types
	length() // instead of size()
	capacity()
	toString()/substring()
	insert(index, str) // instead of add()
	delete(index1, index2) // instead of remove()
	reverse() // instead of reverseOrder()
	replace() // instead of using SubList() and changing

	methods that mutate the data return the object itself
		this allows you to chain fluently
StringBuffer
	thread-safe version of StringBuilder

Stack<T>
	push/pop/peek/isEmpty
	concrete
Queue<T>
	add/poll/peek/isEmpty
	interface
		LinkedList, ArrayDeque, PriorityQueue
Deque<T>
	queue members but also addFirst, addLast, pollFirst, etc.
	interface
		LinkedList, ArrayDeque

PriorityQueue<T> (concrete, implements Queue<T>)
	smallest item (by natural sort) comes out first
		can provide custom comparator to change how Ordered
			eg. Comparator.reverseOrder() makes it use max value instead of min
	implemented via heap that uses comparator (minheap by default, maxheap with reverseOrder)

RandomAccess interface
	a marker interface with no members
	used by algorithms like binary search to check whether a collection can do random access
		eg. implemented by ArrayList but not LinkedList
		that way the algorithm won't do something bad like seek back and forth on a linked list

Missing from Java: tuple, struct/value type, tree, graph

	POD Type
		in addition to the newer record type, making a POD like a C++ struct is not that bad
		just making a class with public variables and let the c'tor default

Immutability
	Collections.unmodifiableList(existingList)
		gets a List<T> that will throw if you try to modify the list
	available for sets and maps too

Conversions
	collection constructors take collections as args where appropriate
		but not arrays, because arrays are not collections (use asList if needed)
	Arrays.asList()
		should be efficient since just a view on the array
	Collections.unmodificable* for getting immutable from mutable

Casting
	the issue of boxing only comes up in arrays because they can take primitives
	you cannot cast a whole array between boxed vs. unboxed in one cast
	you can cast an array from Object[] to Integer[] for instance though
		you can't do this (directly) with generics though
		caveat: this only works if the array is created as Integer[] and not Object[]
			so for an API such as stream.toArray(), this won't work
			it's a whole array cast and not an element-by-element one

	to cast elements for collections/generics, the syntax is weird:
		List<Object> objList = (List<Object>)(List<?>)list;
        	List<Integer> castedList = (List<Integer>)(List<?>)objList;
		or just use the wildcard to declare objList and don't cast anything

Aggregates
	Collections.max(), Collections.min()

Sorting/Shuffling
	Collections.sort(), Collections.shuffle()
	Comparator<T> functional interface can tell collections how to sort things
	java.util.Comparator has static methods to get comparators to pass
		Comparator.naturalOrder() = use Compareable<T> of elements
		Comparator.reverseOrder() = use opposite of natural order

Searching
	assuming a sorted collection (natural order)

	Collections.binarySearch(list, item)
		natural order search, taking into account whether instanceof RandomAccess
		depends on Comparable<T>
		gets index if found (same = undefined which will get)
		-(insertionPoint + 1) if not found
			so that you can use < 0 to know
			where you'd insert it if you wanted
	Collections.binarySearch(list, item comparator)
		same but custom comparator
	Arrays.binarySearch()
		same as all the above for arrays
		lots of overloads for primitive types since not generic

Simulating Literals in non-arrays
	Arrays.asList(item1, item2, item3) to make an array list that can't be resized (but is mutable)
	{{ }} anonymous class with initializer block (caution!)
	List.of(), Set.of(), etc. take varargs to specify items inline
		explicitly disallow nulls for philosophical reasons
		this restriction doesn't apply to Arrays.asList() or Stream.of()
		also doesn't apply if wrap existing list with unmodificableList() call

Filling with Values
	new int[5] gets 5 0s
	Arrays.fill(arr, 100) fills the array with 100 afterward
	Arrays.fill(arr, start, stop, value) for a subrange
	Collections.nCopies(n, val) gets a new immutable list
		pass into ArrayList<> c'tor to get mutable one from it
	Collections.fill(list) to fill existing
		use subList() to fill a subrange
	Arrays.setAll(arr, generator)
		fill all the elements of an array using a function
		the function takes an int index and returns an int, long, double, or T
		the type of arr must be int[], long[], double[], or T[]
		only the 3 main primitives supported by java.util.function are overloaded here
		note that this is not lazy, unlike something like Stream.iterate or Stream.generate

Cloning
	arr.clone()
	copy constructor for the rest
	Arrays.copyOf() and Arrays.copyOfRange() for portions of arrays
	new ArrayList<>(list.subList()) for portions of lists

Extending
	collection types in java.util not marked final, so you can extend

Thread Safety of Collections (and other types)
	to make any non-thread safe thing thread-safe, you need to do your own locking and such
		but some types are already thrad-safe and some have thread-safe alternatives
	primitive numbers themselves are thread-safe
		but operands like ++ (as post-increment) are not because they store and modify non-automatically
		java.util.concurrent.atomic.AtomicInteger is example of an atomic version provided for that purpose
	anything immutable is thread-safe by default ONCE CREATED because you can only read it
		eg. String, Integer, List.of(), etc.
		keep in mind any iterator from an immutable collection is mutable and thus not itself thread-safe
	mutable collections (and arrays) can be assumed to be NOT THREAD-SAFE by default
		Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedSortedSet(), etc.
			can wrap mutable instances of the various interfaces
			because the wrapping is done at the interface level, basically you use the same interface (eg. List<>)
				and the wrapper locks (on itself) before forwarding calls
				if you access the unwrapped one, you are bypassing the locking
			similarly, Collections.unmodifiableList() and those wrap the same interfaces and make any writes fail
				this can also make it thread-safe if you don't need to write to it
				if you don't need writes, this might be a more efficient way to be thread-safe
	the following collections are already thread-safe
		Hashtable is thread-safe but slow (ConcurrentHashMap is faster)
		Stack is thread-safe because inherits Vector
			but Deque is not
	there are also thread-safe alternatives to some of the built-in collections you can instantiate
		Vector <-> List
		ConcurrentHashMap <-> HashMap
		PriorityBlockingQueue <-> PriorityQueue
		StringBuilder <-> StringBuffer

		Vector implements List<> and is thread-safe
			but is much older and retrofitted to support List
			so don't use unless you have to

Implementing Objects for Collections
	to put into a collection that uses hashes, you will need hashCode() and equals()
		to do operations like remove() on a list, you will need those as well
		utilize Objects.hash(...) to make this easy
	to support sorting and operations like that, you will need to implement Comparable<T>
	to support writing the collection to a string, implement toString()

Swapping
	Collections.swap(list, i1, i2) for lists only
	none provided for array or in general due to no ref parameters

Iterators/Iterables
	collections implement Iterable<T> interface in java.lang
		has an iterator() member to get an Iterator<T> (java.util)
	Iterator<T> has hasNext() and next() and some default methods
	the interface is compatible with laziness for things like streams
	Iterable<T> always has a .forEach(consumer) method just like streams do
		which means you can use .forEach(System.out::println) on any java.util collection!

Empty Constants
	Collections.EMPTY_SET, EMPTY_LIST, EMPTY_MAP
	immutable

hashCode(), equals(), and toString() implementations
	collections already implement based on their items
	the abstraction is lower level than the container, so it doesn't depend on other state
	eg. immutable list vs. mutable list have same hash if same items
	this makes collections suitable to be composed into higher collections (eg. use List as tuple)
	this also makes multidimensional lists and such just work without any special handling or deep* methods

Deep copies
	using arr.clone() or a collection constructor gives you a 1-level (shallow) copy
	there are 2 approaches to make a deep copy:
		1. manually via iteration
		2. using streams
			the outer collection becomes a stream which is collected back again
			the inner colleciton can be copied with a copy constructor, eg. in a map()

[Strings]
c++style comments (// and /* */)

reference type/interned/immutable
not array, not indexable with []

+ or .concat() [fluent]
automatically converts with toString() if type is not string

str.length() [insted of size() like collections]
str.toCharArray() char[]
str.charAt(index)
str.trim()
str.startsWith()
str.toUpperCase()
str.substring()
str.replace()
	replace all occurences of string or character
str.replaceFirst()/str.replaceAll()
	replace all or first occurence(s) of REGEX
str.matches()
	full-string REGEX match check
str.split() -> String[]
	REGEX used for thing to split on
	each occurence swallowed and becomes comma in array
	internal empties possible but empties at end are removed
compiled regex patterns have similar methods to the last few above
no built-in reversal in either strings or arrays

to modify part of a string, you need to break it (eg. with substring) and concat the result
	even for single characters
	or alternatively, use toCharArray(), modify the array, and use new String(arr) [incurs 2 copies]

to sort a string, convert to char array, use Arrays.sort(), and new String(arr)
	overloads like no params, range of indices, comparators, etc.

String.join(delimStr, collection)

String has a lot of constructors
	eg. all or part of a char[], copy another String, a StringBuilder, StringBuffer, etc.
		not Character[] though

most built-ins and collections have a proper toString() except for arrays (use Arrays.toString())

C++ style single and double quotes (strict separation of string vs. char literals)
""" for verbatim string (raw and multiline)
escaping just like in C++

Character.isLetter(), Character.isDigit(), etc.

System.out.printf(formatString, ...) like in C++
	does NOT print a newline at end
	%s
		uses toString() of the object passed in
	%d
	%02d [2 digits padded with 0]
	%.2f [2 places after decimal]
	%2$d [2nd arg after format string used for the %d, instead of natural order]
String.format() is like sprintf
do not pass a float when int is expected or vice versa
	but passing short or long instead of int for instance is fine

Double.parseDouble(str) to get double from string
Double.toString(d) to convert primitive to string

java.util.regex.*
	pattern = Pattern.compile(patternString)
	matcher = pattern.matcher(content)
	if (matcher.matches()) {}

math on char -> integer -> can cast back to char

line endings
	file readers are resilient
	writing with \n usuaully ok
	System.lineSeparator() if need to get for system

case insensitivity
	static comparator String.CASE_INSENSITIVE_ORDER
	method s.compareToIgnoreCase()

extra copies
	note that in general, methods that get a string from another string make a true copy
	this is so that new smaller strings won't keep large older strings loaded in memory
	as a result, you have to be careful about extra copies in your algorithms
	this applies to stringBuilder.substring() as well, which returns a String

[Operators]
math & bit & boolean & comparison & assignment operators are exactly like C++
string concat + with things like ints and list automatically converts with toString()
	null becomes "null" in the actual string
string .concat() fluent method available too
no coalescing (other than methods of Optional and Map) or safe navigation
.getClass() for instances and .class for types
A instance of B (for reference types only)[false if null]

Casting Details
	Object o = m;
		implicit cast that compiler can handle - no runtime check needed
	m = n; // same type
		compiler can already tell, so no runtime check needed
	MyClass m = (MyClass)o;
		runtime cast
	short s = (short)x;
		runtime cast
	int x = s;
		runtime cast (implicit)
	Integer x = list.get(0)
		runtime cast because generics store bases
	
	a runtime cast will throw ClassCastException (unchecked) if it fails

[Control Flow]
ranged-based for (enhanced for loop)
	[remember to use : instead of of, in, etc. like some others]
	legal (but uncommon) to put 'final'
if/else if/else and switch work basically just like C++ (with optional braces for single line, default fall-through in switches, etc.)
switches also work on non-numeric types and for enum values, you don't have to specify the enum in front in the cases
for/while/do while work just like C++ (plus the range-based for which c++ now also has)
	remember middle condition is dynamic and variable can be messesd with
try/catch/finally/throw just like in C++
	throwing in a handler rethrows (after passing through finally first)
	catch(ExceptionType1 | ExceptionType2 e) {}
		special syntax for allowing multiple exception types
		then you can use the same code for all of them
		if you rethrow e here, it will be the correct type (not the base)

try-with-resources
	try (BufferedReader reader1 = new BufferedReader(new FileReader("file1.txt"));
             BufferedReader reader2 = new BufferedReader(new FileReader("file2.txt"))) {}
			 variable gone outside the scope (unlike python)
	try(reader)
		only if effectively final and already initialized
	allowed to let exceptions propagate out
assert condition: string
lazy list
	streams are evaluated lazily
	or you can do it yourself by making your own iterator for your object
main function args = just the args themselves (String[])
truthiness: only actual booleans can be used in things like if/else
	need to do == null, == 0, isEmpty(), etc. on anything else

some useful built-in exceptions:
	NumberFormatException (unchecked): bad conversion from string to a number
	ArithmeticException (unchecked)
	UnsupportedOperationException (unchecked)
	IllegalArgumentException (unchecked)
	ClassCastException (unchecked)
	java.io.IOException
		java.io.FileNotFoundException

key exception members
	getMessage()
	getCause() [an exception]
	getStackTrace() [an array of stack trace info elements]
	printStackTrace() [overrides for streams or just prints to System.err]

[Functions]
just like TypeScript, C#, etc. (access, modifiers, etc. all together)
	except all functions are methods of a class (no top-level)
throws keyword to specify exceptions (checked required, unchecked optional)
	unchecked inherit from RuntimeException
	checked inherit from Exception (more general)
positional args only, no keyword args
overloading allowed
	if overloading between static and non-static, the signature can't match
no default args directly (simulate with Optional and/or overloading)
	java.util.Optional
	Optional.of() [no value]
	Optional.of(value) [populated, assumed not null]
	Optional.ofNullable(value) [populated if not null]
	val.isPresent(), val.get(), val.orElse(default), value.orElseThrow(), value.orElseGet(supplier)
	Optional.stream() to get 0 or 1 element stream
	optional.map(), filter(), etc. to do functional operations on the value if present
		return another Optional with result
	optional.ifPresent(consumer) to act on value
	optional.ifPresentOrElse(consumer, runnable) is like ternary operator
	java.util.OptionalInt, etc. for primitive values
variadic functions
	int... numbers
		this param becomes an array
		you can either pass an array to it or pass multiple integer arguments that it will put together for you
		ommit args entirely to get empty array
not supported: spread, nested functions, inline functions, macros, extension methods, ref and out parameters
var
	ok as variable that gets a function call as a value
	not ok as function return type or parameter type
recursion works like normal (by name), but no TCO

params can be marked final, but it only prevents the local references and not the objects
	uncommon

param names aren't part of the unique identity of a method
	just method name and param types
	that makes things like lambdas work despite different param names being used
	also means you can implement multiple interfaces where they use different param names but same types, with 1 method

[Functional]
"skinny arrows"
	Runnable runnable = () -> System.out.println("bla");	// ok doesn't return value
	(a, b) -> a + b
	(a, b) -> { return a + b; }
	(Integer a) -> a * a
	x -> x * 2
big difference from all other languages = what the type of a lambda (or a method reference) is and how you call it
	"functional interface" = an interface containing 1 abstract method signature
	assigning a lambda or method to it automatically makes it callable via the method on the interface
	primitive types ok in your own interface, but generic interfaces like in java.util.function can't take them
	@FunctionalInterface annotation recommended on functional interfaces

	functional interfaces can have static and default members too (only the public abstract member matters for lambdas)
		eg. Comparator<T> has a lot of statics such as Comparator.naturalOrder() and defaults as well
		eg. Function<T1, T2> has compose() default method for doing function composition
		default methods are fluently chained rather than modifying any state

Runnable = takes nothing, returns void
	.run()
java.util.concurrent.Callable<V> = like runnable but returns a value
	.call()
		can throw any checked exception
java.util.function.Predicate<T> = takes val and returns boolean
	.test(T val)
	default methods for combining:
		.and(predicate)
		.or(predicte)
		.negate()
	static methods for creating:
		.isEqual(otherObj)
java.util.function.BiPredicate<T1, T2> = 2 input arg version of Predicate
	.test(T1 t1, T2 t2)
	same methods as Predicate<> besides that
java.util.function.Consumer<T> = takes val and return void
	.accept(T val)
	default methods:
		.andThen(consumer) for chaining consumers for each value
java.util.function.Supplier<T> = takes nothing and returns a value
	.get()
java.util.function.Function<TArg, TReturn> = takes single param and returns value
	.apply(TArg arg)
	default methods:
		.compose(beforeFunction) to apply another function first and then apply this one
			eg. think of f(g(x)) - you have f(g) and then you make it f(g(x)) by calling this
		.andThen(afterFunction) to do the opposite of compose
			eg. you have g(x) and then you make it f(g(x))
	static methods:
		.identity() to always return argument as return
java.util.function.BiFunction<TArg1, TArg2, TReturn> = function of 2 params
	.apply(arg1, arg2)
	default methods:
		.andThen(function) to apply further transform on the result
java.util.function.BiConsumer and java.util.function.BiPredicate = 2 arg input verisons of those

java.util.function.UnaryOperator<T> = Function<T, T>
	all members of Function
java.util.function.BinaryOperator<T> = BiFunction<T, T, T>
	static methods:
		maxBy() and minBy() both taking Comparator<T>
	plus all members of BiFunction

java.util.function has versions of the above with various combinations of primitives as well
	to get around the limitation of generics not accepting primitives
	in general, composition methods tend to stick to their own type
	the naming convention seems to be:
		add AsType to the end of methods that return a primitive
		leave name alone if just taking primitive as args

	eg. BooleanSupplier
		.getAsBoolean()
	eg. DoubleBinaryOperator
		.applyAsDouble(d1, d2)
	eg. DoubleFunction<R>
		.apply(d)
	eg. DoubleToIntFunction
		.applyAsInt(d)
	eg. ObjectIntConsumer
		.accept(obj, n)
	eg. ToIntFunction<T> // note this is different from IntFunction!
		.applyAsInt(T t)
	eg. ToLongBiFunction<T1, T2>
		.applyAsLong(T1 t1, T2 t2)
	
	note that the 3 primitives considered are int, long, and double (just like with streams)

"effectively final rule" - closures (and other code) must treat enclosed variable as final
	but they can change members, so that's how you can use a lambda to modify state
not supported: _ for ignored args, partial application (just use a lambda), type inference (var) on lambda variable

Method References
	to assign a class method to a functional interface variable (treat it like a lambda)
	looks like scope resolution :: in C++
		eg. MyClass::MyMethod
	if you use the class name to the left, it is "unbound"
		then it has to be called with the 'this' object as the first argument
			unless it's a static method - then it is unbound but has no 'this'
	if you use an instance to the left, it is "bound"
		the 'this' is stored internally where you don't need to see it
		just call it like it's a static method or lambda
	you are not allowed to treat a static method as an instance method by just binding its first arg
	if the method is overloaded, the compiler can usually deduce which one from the context
	constructors as methods are special
		use 'new' as the name and treat as static
		input = c'tor args, output = instance of the type
		eg. MyClass::new taking c'tor args
		eg. int[]::new taking length of array
	methods of generic methods (eg. ArrayList::add) are special yet again
		use the unbound one on the RH side (no diamond) and the bound one on the LH side
		the LH side protects inappropriate usage
		type is erased at runtime which is why method reference acts that way
		BiConsumer<ArrayList<Integer>, Integer> adder = ArrayList::add;
			note that you had to use ArrayList on both sides in this case, not List
		leaving out <Integer> on the LH side would trigger unchecked warning
			in the case of a method like stream.collect(), the overall context tells it how to bind T and figure it out
	return type of a lambda/reference doesn't have to be exact match for the functional interface
		eg. void can take any return type and just ignore it
		eg. functional interface can take base class of what method returns
		eg. autoboxing can happen
		except for the void case, it's mostly about "assignability"
Streams API
	this is the way you do functional operations on collections in Java (but it's also used other places)
	java.util.stream.*
	someCollection.stream() will give you a Stream<T> object
	then call methods on that Stream<T>, such as .map(), .filter(), .reduce() // which doens't need a collector
		1st arg of reduce should be "identity" object, not the first sequence thing
	when you're ready to make it back into a collection, call the .collect() method
		eg. .collect(Collectors.toList()) or toSet, whatever
	various collectors like getting max value, converting to string, groupBy (returns a Map), etc.
	do the above fluently (eg. List<int> newList = list.stream().map().collect())
	custom collectors can be implemented via Collector<> interface (which is complicated)
		alternatively, you can use the overload of collect() that lets you pass 3 functions
		collect(mutableCollectionSupplier, biConsumerToAddItem, biConsumerToAddOtherCollection)
		the 3rd function is used for parallel streams to do merging
		in addition to your own lambdas, these are common usages/examples:
			.collect(ArrayList::new, ArrayList::add, ArrayList::addAll)
			.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)
	reduce() is similar to collect() but has some other signatures
		reduce(supplier, adder, combiner) much like collect()
			but expects fluently returned values
			some collections (StringBuilder) do this already, and some (List) don't
		reduce(identity, accumulator) is like the sum() case
			but the restriction is that accumulator is a BinaryOperator<T> (all 3 types match)
		reduce(accumulator) returns Optional in case not enough elements of sequence
		in general, reduce can be used mutably or immutably
	Collectors doesn't deal with arrays
		stream.toArray() returns Object[] (which can't be cast)
		stream.toArray(Integer[]::new) returns Integer[] // no primitives allowed
		primitive arrays like IntStream have their own toArray() with primitive return array types
	the toMap() collector requires a method reference/lambda for key and value
		it will take whatever object it has, which can, for instance, be a Map.Entry<>
		then apply the methods you give it (such as unbound getKey and getValue methods)
	Map doesn't support stream(), but keySet(), values(), and entrySet() of course do

	forEach(x -> System.out.println(x))
		does not return another stream
		if the stream has no guarnateed order (eg. parallel), use forEachOrdered() instead if needed
	forEach(System.out::println)
		clearer style

	findFirst()/findAny()
		terminal operations that get 1 single value (first or non-guranteed order)
		use these after filter() to find the first or random matching value based on lambda
			ok due to lazy evaluation
		both return an Optional<> so you need to check it

	Stream.of() for creating based on values
		variadic (args or array)
		don't use a primitive array - that will get interpretted as Stream<int[]> instead
			Integer[] works though
	Arrays.stream() is a workaround for primitives
		has 3 overloads for int[], long[], double[]
			you're out of luck for other primitives than those 3
			have to do it less directly somehow (eg. for loop)
		returns IntStream, LongStream, DoubleStream
		also has generic version that does what Stream.of() already does
		all the overloads can also take optional range start and end
		Arrays.asList() has no overloads because no such thing as IntList

	s.chars() gives you an IntStream for a string
		a way to avoid using toCharArray() to make a copy
		has to use IntStream because no CharStream available
		once you have the IntStream, you can do any lazy transformations
			you can be confident all the values will fit in char

	any operation on stream closes it
		different from Observables in JS
		have to remake or collect intermediate to provide branching

	IntStream = primitive int stream (not Stream<>) for perf.
		IntStream.range(0, 10) for a stream of 0..9
		IntStream.of(1, 2, 3) for variadic args(or single array) giving values
		stream.mapToInt(n -> n) // boxed to primitive (could use Integer::intValue too)
		s.max(), s.asDoubleStream(), s.forEach()
		s.toArray() to collect as an array of int
		s.boxed() to make a Stream<Integer>
		s.<T>mapToObj() to provide custom conversion to Stream<T>
		cannot collect() [use boxed() or mapToObj first]
			the method is there but it doesn't work, probably because of generics
		can assume most Stream stuff is there (eg. of(), concat(), etc.)
	DoubleStream and LongStream also
		only these 3 types
		smaller values must upsize to the next one

	tips for readability:
		use static imports (eg. toList())
		use method references instead oflambdas (eg. Integer::valueOf)

	lazy evaluation
		only terminal operations (get actual value(s)) cause real evaluation
	infinite sequences
		Stream.iterate(seed, lambdaOnPrevValue) -> infinite lazy sequence
		eg. Stream.iterate(1, n -> n + 1) -> all positive integers
		eg. STream.iterate(0, n -> n + 2) -> all even nonnegative integers
		then you can use map() etc. to transform further
		do not accidentally assume n is the index! (be careful)

	other interesting stream methods
		allMatch(pred), anyMatch(pred), noneMatch(pred)
		count(), max(comparator), min(comparator)
			note that count() is a long instead of int
			implies that streams can be more than 2 GB elements
		distinct()
		mapToDouble(fn), etc. (to get DoubleStream for instance)
		flatMap(fn) (map elements to streams and then concat them lazily)
		flatMapToDouble(fn), flatMapToLong(fn), flatMapToInt(fn)
			like flat map but produces a primitive stream from primitive streams
		generate(supplier) to generate based on a generator function
			infinite only - no way to signal stop
		limit(n) and skip(n)
		toArray()
		sorted() and sorted(comparator)
		peek(fn) [like tap() in rxjs]

	static members
		concat(stream1, stream2)
			lazily do stream1 elements then stream2 Elements
		empty()
			to get an empty stream

	Other Interesting Collectors members
		- `<Map<TKey, List<TValue>> groupingBy(Function<TValue, TKey> classifier)`
			- create a dictionary of lists of values from the stream matching a classifier (the keys)
		- `<Map<TKey, TTransformed> groupingBy(Function<TValue, TKey> classifier, Collector<TValue>)`
			- a way to further transform the lists into single values using collectors
		- `partitioningBy` is like `groupingBy` but the key is a `Boolean` and it takes a `Predicate`
		- `joining(delim)`, `joining(delim, prefix, suffix)`, `joining()`
			- for making string
		- `maxBy(comparator)` and `minBy(comparator)` to get max and min values
		- `summingInt(toIntFunction)` and similar
			- you provide mapping to primitives and then it sums for you

	Other uses of Streams
		Random.ints(), Random.longs(), etc. [infinite random sequences]
		optional.stream() [0 or 1 elements]
		java.nio.file.Files.lines(Paths.get(path))
			use with try-with-resources

	Parallel Streams
		collection.parallelStream()
		stream.parallel()
		uses ForkJoin framework under the hood

		terminal operations like collect(), findFirst(), etc. put the order back
		intermediate operations like map() don't respect the order (for parallelism)
			some operations like sort() will still have order dependence and not benefit
		need to benchmark for specific problem to see if worth it
		forEach vs. forEachOrdered behaves differently in this case

		can turn back into sequential stream with stream.sequential()
		
	Unordered Streams
		stream.unordered()
		intermediate and terminal operations lose order dependency
		may have performance benefits in some cases
		unordered collections like HashSet<T> will already use this out of the box

	Stream Builder
		Stream.builder().add(val1).add(val2).build()

	AutoCloseable
		streams are autocloseable so that you can use them with file I/O etc.
			then the try-with-resources will close the file
		does not interact badly with using map() etc. inside the try {}

	Fibonacci Example (mine)
		Stream.iterate(new int[] {0, 1}, a -> new int[] {a[1], a[0] + a[1]}).mapToInt(a[0])
			then just limit() and toArray() to get final result

	Newer (9+) Methods
		`dropWhile(predicate)`
			- skips elements as long as predicate keeps matching
			- for ordered stream only
		`takeWhile(predicate)`
			- takes elements as long as predicate keeps matching
			- for ordered stream only
		`ofNullable(e)`
			- similar to Optional.stream()
			- 1 element if non-null, otherwise 0
		`mapMulti*`
			- methods for mapping multiple elements onto each element
		`iterate(seed, predicate, operator)`
    		- new overload of iterate() to allow for stopping when a condition stops being met (non-infinite)
			- functions like a for loop where the index variable is the thing being generated

	Method References
		don't forget to try to use method references instead of lambdas when you can
		eg. System.out::println for forEach() or peek()
		eg. Objects::nonNull for predicates

	Iterator
		stream.iterator() gets an Iterator<T>
			closes the stream (terminal)
			still lazy
		stream doesn't implement Iterable technically, so can't do range-for

	Zip
		not available, but you can simulate it yourself with iterator() and generate()
		save 2 (effectively final) iterators and call generate with a lambda
		use sentinal values for hasNext() being false and then use takeWhile() to cut off the end

	Infinite Repeated Value Stream
		Stream.generate(() -> 100)

	Chess Queen Attacks
		to avoid writing 8 nasty for loops
		create one-liner methods to do upward, downward, and repeated infinite sequences from a number
		then make a zip method to make chess squares sequence from two of those (infinite)
			use a Square class instead of a List for clarity
		then make a predicate to check for valid squares based on boundaries and criteria of the problem
		then make a countAttacks method that does takeWhile() on that predicate on the zipped squence and count()
		the final result is the sum of 8 calls to countAttacks(zip()) with all the combos of the methods

		the iterative alternative is 8 for loops, each with either nesting or hardcoding one of the variables
		then each for loop has to check other criteria (like if hits obstacles) and bail
		then just increment count each non-bailed iteration
		conceptually the same but uglier, more repetitive, and have to craft each loop w/ copy/paste

	Matrix Slicing
		List<List<>>
			subList().stream().map(sublist).collect()
				rows are independent copies but cells are pointing into original rows
				avoids copying all the elements
				but slice is vulnerable to changes in the original, including cells & row sizes
				do another map(new ArrayList<>()) or similar to make it a true deep copy
		List<String>
			subList().stream().map(substring).collect()
				deep copy already from the beginning (which may be less efficient)
		[][]
			because you can't treat these like in C++, better to pass a wrapper instead

	Array Conversion Patterns
		Upcast from supported
			long[] a = Arrays.stream(intArr).asLongStream().toArray()
		Upcast from unsupported
			long[] a = IntStream.range(0, shortArr.length).mapToLong(i -> shortArr[i]).toArray();
		Downcast to supported
			int[] a = Arrays.stream(longArr).mapToInt(n -> (int)n).toArray();
			// the asLongStream() type methods only upconvert, no downconversions
		Downcast to unsupported
			short[] a = new short[intArr.length]; for (int i = 0; i < intArr.length) {a[i] = intArr[i];}

		Boxing
			Integer[] a = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
			Integer[] a = Arrays.stream(intArr).map(n -> n).toArray(Integer[]::new);
		Unboxing
			int[] a = Arrays.stream(integerArr).mapToInt(Integer::intValue).toArray();
		Boxed Type to Boxed Type
			Long[] a = Stream.of(integerArr).map(Integer::longValue).toArray(Long[]::new);

		int[] to Character[]
			Character[] a = intArr.mapToObj(n -> (char)n).toArray(Character[]::new);
				// relies on auto-boxing
        	Character[] a = (new String(charArr)).chars().mapToObj(n -> (char)n).toArray(Character[]::new);
				//inefficient because extra string
		char[] to Character[]
			upcast from unsupported to get IntStream, then mapToObj as in int[] to Character[]
	Stream Conversion Patterns
		follow the array patterns but leave off the beginning or end as appropriate
		note that generics won't have primitives no matter what
	Stream Equality (3 ways)
		1. zip and do allMatch(p -> p[0] == p[1])
		2. use iterators and use the same logic as comparing two linked lists
		3. collect to lists and use .equals()

Exceptions
	lambdas can't have throws specifications, but interface members and methods can
	basically when you assign a lambda to a functional interface, it is assumed to match the throws
	you can throw less than what is specified, but not more (in terms of checked exceptions)
	this means that for instance, if you use Thread with Runnable, you can't throw any checked exceptions
		have to rewrap to unchecked or silently deal with it internally somehow

IIFE
	((Runnable) () -> System.out.println("Hi!")).run();
	Predicate<Integer> p = ((Predicate<Integer>) x -> x > 0).and(x -> x % 2 == 0);
		don't forget to specify the type args instead of using the raw type or it won't work

[Classes]
overall syntax looks like a lot of other languages
	access specifier on class, then methods as described in [functions] above, and variables
	final for constants, static for statics, even the class can be static, etc.
	'this' implicitly like in C++
		not required to access members from inside like in JavaScript/TypeScript/Python
	constructor named after class like C++ (and overloadable)
always use new() [no stack variables like in C++ or ommitting entirely like in Python]
finalize() for destructor on garbage collection
Cloneable interface clone() method for copy
	actually a marker interface - clone() is on Object and throws by default
default constructor (just 1) if no constructor, otherwise only the one(s) you specify
not supported: operator overloading, partial classes, custom value types, properties (as other languages use them)[setValue, getValue pattern], call operator
	a key effect of not supporting properties is that there can't be read-only fields (except by methods)
name hiding also not supported (all methods virtual and always get the most derived one no matter which reference type)
	except for private members which are always hidden and non-virtual

static members can be accessed via method or class and use . (not :: like C++, only method references use that)

values can be initialized inline or left to their defaults
	need not be constant expressions
	more caveats about this in Construction Order below

Access Modifiers
	public, private, protected, default (which is never specified)
	default means package (not file necessarily)
	applies to methods, variables, classes within classes, and top-level classes
	like C++, can access and possibly change private members from other instances (we are all robots)
	"friend class" equivalance = nested class, package-private members
	'private' members are not virtual
		subclass can provide one of same name and it means different thing
Inheritance
	"extends" to subclass
	"implements" to implement interface (comma separator for multiple)
	@Override annotation for overridden methods (in java.lang)(technically optional since all are virtual)[even for interfaces]
	super() to call base constructor in constructor
	super.method() to call base method from derived method
	can "extend" 1 class but "implements" as many interfaces as you want
	can mark a method as "final" to prevent overriding
	can mark a class as "final" to prevent subclassingf
	covariant return types supported
	you can increase access in a subclass (eg. make a protected member public)
		but you can't go the other way
		remember that private members aren't seen by the subclass, so you're not exposing anything
	static members are not virtual and exhibit name hiding behavior
		a subclass type or instance can access all statics from it and all bases
			but any of the same signature in subclass will hide the base
		a base class reference or the type itself will see its ow statics, not the overriden ones
		interfaces are special - classes implmenting them do not see the statics at all
			they have to be referenced via the interface as the type
Initialization Blocks
	no initialization list like in C++, but this is very similar intent
	naked {} inside class means code that will run before the constructor, which you can use to initialize things
	static {} are static initialization blocks that effectively gives you a static constructor like in C#
	multiple {} and/or static {} in class are run in sequence
Delegating Constructors
	this() within constructor to call another overload (presumably has to be first)

ABCs
	mark the class as 'abstract' and then mark methods as 'abstract' (no bodies or =0)
	an interface is not an ABC because it can't have variables inside an instance
Interfaces
	'interface' keyword and then abstract methods (no body, no =0 like C++, NO 'abstrat' keyword)
	all methods public and abstract by default (and can't be changed)
		the normal case is to just have those
		need to explicitly declare the overridden methods as 'public' when implementing
	can also have static members
		variables with no modifiers automatically public static final
		methods marked with static can have a body
	can also have 'default' methods
		body used in implementing class if not overriden
		effectively adds another public abstract method but subclass can ignore it if wants to use default
			should not collide with an explcitly public abstract method
	can also have 'private' methods (with bodies only)
		only to be used by static and default methods (not from outside)
	
	method name collisions = same method just use for both automatically
		if default methods, have to override it
			Interface1.super.f() to call within the class method

	an abstract class can leave out interface methods, but a concrete class cannot
		an ABC can specify missing methods as abstract, or just ignore them
		either way, a concrete class must have everything filled in

	interface can inherit one or more other interfaces via 'extends'

	interfaces can be generic (as many of the built-in collection ones are)
Object
	root of all reference types (implicitly inherited if no inheritance specified)
	@Override methods to provide systemic behavior
		toString(), equals(), hashCode(), etc.
	not abstract
		new Object() is allowed
			eg. if need opaque object reference for synchronization lock, etc.
Objects static class
	some null-safe versions of normal Object methods
	Objects.equals(a, b)
	Objects.hashCode(o)
	Objects.toString(o) and Objets.toString(o, default)
		returns null or default on null
	Objects.hash(o1, o2, o3)
		variadic method to hash multiple objects into 1 hash
		useful to call for hashCode() implementation of class with its members
		hashes the varargs array using Arrays.hashCode()
	Objects.isNull(o) and Objects.nonNull(o)
		useful for predicates

Useful Built-in Interfaces
	Cloneable (marker)
	AutoCloseable
	java.io.Serializable (old-fashioned, often better to use a library)

Nested Classes (a weirdness of Java)
	to provide a nested class like you would in another language (just namespaced under the parent),
		you need to make it a "static" class (even if it has no static members)
	without static, it is an "inner class" and has to be constructed with the outer class instance as an arg
		Outer.InnerClass inner = outer.new InnerClass()
	methods of "inner classes" can access members of the outer class without any qualifier
		so it's basically just a subsection of the main class rather than its own thing
		can access private members
	nested interfaces behave more like normal nested types (always static)

Boxing/Unboxing
	implicitly works most of the time (autoboxing/autounboxing)
		can use Integer.valueOf() and boxedInt.intValue() to do it explicitly if needed
			eg. to cast to another reference type, you need to box first
	short lowercase primtivies <-> capitalized full word boxed types (eg. Integer, Character)
	the boxed types also have static methods you can call to do useful stuff and get attributes like:
		MAX_VALUE
	boxed types are still interned unless you used 'new' to create them
	boxed types are IMMUTABLE (value can't be reset for an instance)
	a lot of operations like <, +, etc. implicitly unbox and rebox and work as expected
		even in generic methods that use the boxed types
	Integer::sum

Anonymous Class
	MyInterface obj = new MyInterface() {
            @Override
            public void display() {
                System.out.println("Inside AnonymousClass");
            }
        };

	works for either interface or class with same syntax
		only 1 thing, no way to specify more
	no way to specify constructor because no name
		can do {} though, which will safely run after the base is constructed

	can provide c'tor args for base class in the ()

Construction Order
	1. super() call [which must be first or not present in c'tor] kicks off base construction
		super() cannot be called with any instance members of derived class because not constructed
		if super() call not present, it's implicitly there at the beginning
	2. all base construction events happen completely
	3. all {} and = in the class body are run as a flat sequence in order
		{} can only access variables declared before it physically
		can call methods in both {} and = statements but beware of construction order
	4. rest of c'tor body is run

Serializable
	java.io.Serializable is a marker interface only
	it applies to a class and its subclasses automatically (due to inheritence)
		base c'tor should have no args
	member variables are automatically included in serialization unless marked as "transient" (special language keyword)
	security risk because data can be crafted to blow up the stack or something (invalid object)
	instead of methods on the class, you use java.io.ObjectOutputStream and java.io.ObjectInputStream
		try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            Person person = new Person("John", 25);
            out.writeObject(person);
        } catch (IOException e) {
            e.printStackTrace();
        }

		try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person deserializedPerson = (Person) in.readObject();
            System.out.println(deserializedPerson.getName());  // Outputs: John
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
	to customize the process instead of taking the automatic behavior:
		implement a private writeObject() and readObject() method in the class
			not part of Object or Serializable - just understood by Java
			they take streams and then you serialize/deserialize yourself
		readResolve() can also be used to return specific reference such as singleton
			but enum is often better for that Pattern
	the most important built-in stuff, including Enum, ArrayList, etc. implement Serializable

[Generics]
type parameters can only be reference types (no primitives)(but arrays are allowed, even arrays of primitives!)
generic methods are weird in Java
	public static <T> void f(T t) {}	// the <T> goes before the return type
	myObj.<Integer>f();			// the <T> goes after the dot
		only if need to specify (just myObj.f() if can be inferred)
		CANNOT call as <Integr>f() with no . in front
generic classes are more normal (<T> after class)
	type can be inferred or specified as normal
	use the diamond operator on constructors to avoid unchecked warning from compiler
	unchecked warning is triggered when you use raw types and should never be suppressed
<T extends Number> type constraints (Number of a subclass of Number)
	<T extends MyClass & MyOtherInterface>
type inference boxes for you when it can
nested <> are fine

not supported: metaprogramming, void as type arg, overloading by # type args
	there is a workaround for void as type arg (java.lang.Void type)
		subclass of Object with no members (can't convey any state)
		can pass null
		no way to intermix with true void
Type Erasure
	runtime type of generic has no type args
Raw Types
	use of raw types triggers an unchecked warning from compiler
	List<Integer> l = new List();
		technically allowed and will work correctly
		bad style because less explicit and could result in refactoring mistakes
		use <> operator
	List l = ...
		the interface used on the left is raw
		the compiler will allow you to use any type with it because the type is unknown
		List<Integer> l2 = l;  List<String> l3 = l;
			both of these work because for all the compiler knows, this is List<Object>
		l.add("Hi") will work even if the instance is List<Integer>
			because the generic class is just dealing with Object references
				or if it does <T extends...> then whatever that type is
		if the instance has <T extends...> then l.add() will check against that
			but could still be the wrong type compared to code using it
		x = l2.get(0) will throw exception at runtime because it will cast
			because generics are dealing with Object, an implicit cast has to happen
			thus, the runtime type is checked in the assignment
		however, using System.out.println(l.get(0)) will not throw an exception
			because println takes Object and doesn't care
	this is allowed due to backward compatibility from before generics were introduced
	also, the raw type is legit to use for STATICS in the class
diamond operator: List<Integer> l = new ArrayList<>();
	other scenarios where it works:
		passing into method because it knows what method expects
		List<List<>> can be List<> if subtype can be inferred too
		only class creation (not function call)
	sometimes, ommiting the <> will work, but you should include it anyway
		more explicit/readable and makes some compiler warnings go away
Wildcards
	because casting element types in the parent generic type doesn't work, the concept of wildcards is needed
		for method params, variable declarations, etc.
	List<?> is like List<Object> but with no casting needed
	List<? extends Number> works like <T exends Number>
		and can use & operator if needed
	it is possible to cast to the wildcard version first and then to the Object version and such (runtime error when access but not create if wrong)
	wildcard type constraints are totally separate from generic type constraints
		you can't ommit or copy and paste them - have to consider the covariance/contravariance
	you are allowed to return wildcards from methods but most of the time won't want to
		using a generic type param instead lets the caller specify the type and use it as more than Object
	also in many cases a method could take a wildcard but takes a generic type arg instead
		such as in standard library sort and search methods
	<T extends Comparable<? super T>
		this example shows a case where wildcards wouldn't even cut it by themselves
		Collections.sort() looks like this
			but Collections.swap() is not generic and takes List<?> because it doesn't need that interface
		this idiom means we'll take a Dog that is a subclass of Animal even if only Animal implements Comparable
Covariance/Contravariance
	<? extends Number> is Covariance [read-only]
		don't know the type but know it's AT LEAST a Number
		that means we can read Number from the generic (return values)
			but we can't write values to it (pass parameters)
	<? super Number> is Contravariance [write-only] (only for wildcards, not generics themselves)
		don't know the type but know it's AT MOST a Number
		that means we can write Number (pass as parameter)
			but we can't read values from it (return values)
Casting
	you can cast to T inside a generic as long as the thing being casted is a reference type
		it won't be autoboxed, but if you need to box, you can use something like Integer.valueOf()
	because T is determined by an outsider, you can't assume too much about it
		eg. if T extends Integer, you can't just return an Integer (but you can cast if you know it's ok)
Comparable<T>
	class MyClass implements Comparable<MyClass> {
		public int compareTo(MyClass o) {}
		// < 0 if this < o, > 0 if this > 0, 0 if =
	}
	this defines the "natural ordering" used by collections if no comparator passed in
	a way to do comparisons in generics without having to rely on a type or even Number
	the numeric boxed types implement this
	note that a - b is a valid integer comparator of a and b
		a < b won't work directly because boolean instead of tri-valued int
Comparator<T>
	functional interface with compare(T o1, T o2) method
	also static methods like reverseOrder()
	also default methods like thenComparing() for chaining
		Collections.sort(people, Comparator.comparing(Person::getLastName)
                                           .thenComparing(Person::getFirstName));
Math Operators on Generic Types
	if T extends a specific type like Integer, operators like < may work
		probably internally calling intValue()
		Integer is 'final' though, so you can't subclass it to get operator overloading
	T extends Number does not make that work
Subclass as Type Arguments
	class MyClass implements Comparable<MyClass>
	<T extends Comparable<T>>
Static Methods
	treat as standalone methods (put <T> in front)
	call on unbound class (eg. MyClass.<Integer>create())
Nested Classes
	static = on unbound type (MyClass.MyChild) [acts like static method]
	other = on bound type (MyClass<Integer>.MyChild)
Variadic Generic Functions
	<T> void f(T... args) {}
		if you pass int[], T = int[] and has 1 element!
			because generics can't be int
		if you pass Integer[], T = Integer and has all the Elements

[Imports]
import java.util.List;	// only 1 per line allowed
import java.util.*;	// can import all things from a package
import static java.lang.Math.PI;	// importing a static variable into the file by name (state shared between all places that import)
import static java.lang.Math.Square;	// importing static method to be called unqualified by name (simulated top-level function)
import static java.lang.Math.*;	// importing all static members of class

in theory, if a static member is not final, you can change it without qualifying the class if it's static imported

portions of the path are both subfolders in the path (relative to the classpath java is invoked with) and also the package name
no renaming of symbols like in other languages
subpackages are not automatically imported by importing their parent, those are separate concerns

package com.example;	// to specify the package (which should match the path of the folder relative to classpath)
a package is a folder containing class files

you can have multiple top-level classes in a .java file, but:
	only one can be public
	the public one should have the same name as the .java file
		if no public one, can name file anything

only classes and enums (which act like classes) can be top-levels (not functions or variables)
	but can have effectively global stuff by making static and importing statically

you can use types without importing them (use as fully-qualified name)
	a way to deal with naming conflicts

[stdlib]
java.lang auto imported symbols

System.out.println(), System.out.print(), System.out.printf()
	println has overloads for a lot of types and Object (which uses toString)
	it also has an empty overload
		useful for: blank lines, going to next line after a print() or printf(), etc.
pass System.in to InputStreamReader and that to BufferedReader in try-resources (java.io.*)
	readLine() will start at current position (no newline), echo what is typed, and then go to next line
		returns String that keeps all spaces but not the newline that ended it
		ok to print() in between (won't get sucked back in)
	IOException thrown
	use Stream.of(str.split()).map(Integer::parseInt).collect(toList()) to get list of integers from user
console = System.console();  console.readLine("Enter a value: "); console.readPassword is same but without echo
System.out, System.in, System.err

System.gc()

Math.floor(), Math.abs(), Math.max(), Math.round(), Math.cos(radians), etc.
	Math.PI and Math.E constants
java.util.Random
	new Random().nextInt(100) or nextFloat(), etc.
	nextGaussian() for gaussian distribution, etc.
	ints(), longs(), etc. for infinite streams
java.math.BigInteger
	for numbers larger than long (eg. unsigned long since no unsigned)

File I/O
	many different ways
	Files.newBufferedReader(Paths.get("myfile.txt"))
	you can write directly, and read either one line at a time, one thing at a time, or via a stream
	new BufferedWriter(new FileWriter(path)) [and read equivs]
		reader.read() for char
		reader.lines() for stream of lines
		reader.readLine() for single line
		reader.skip(n) to skip chars
		writer.write(arr) or writer.write(str)
	binary-based version = java.io.FileOutputStream and java.io.FileInputStream
			eg. stream.write(byte) or stream.write(byte[])
			eg. stream.read(arr) to read into array (maxed to its length)
Paths
	java.nio.file.Path and java.nio.file.Paths
	Path path = Paths.get("C:/Users/John/Documents/file.txt");
	path.isRelative(), path.getParent(), etc.
Environment Variables
	System.getenv(), System.getProperty(), System.setProperty()

java.lang.Thread
	thread = new Thread(() -> {Thread.sleep(1000)})	// 1s
		takes a Runnable
	thread.start()
	thread.isAlive()
	thread.join()
		optional timeout in millis (if thread not dead, return as if nothing wrong)
			join = wait for thread to finish
		check thread.isAlive() if needed after
	Thread.sleep()
		duration in millis plus optionally nanos in addition

	alternatively, you could subclass Thread and override run()
		which will get called when you start() the thread
		the lambda version is more recommended now

	Thread.currentThread() gets current executing thread's instance

	thread.getPriority(), thread.setPriority(), Thread.MIN_PRIORITY (1), Thread.MAX_PRIORITY (10), Thread.NORM_PRIORITY (5)
Interrupting threads
	each thread has an interrupted flag (thread.isInterrupted() or Thread.interrupted() for current thread)
	each thread also has thread.isAlive() which is separate from that
		when a thread completes or dies somehow, isAlive() goes to false
		can be both interrupted and alive at the same time
	thread.interrupt() sets the interrupted flag (but does not affect isAlive())
	calling a method like join(), sleep(), or get() in a thread that has interrupted flag will throw InterruptedException
		these have nothing to do with the thread you're joining, for instance
		if you join an interrupted thread that is still alive, it's fine
	usually, the child thread will detect its own interruption via the exception and/or flag
		then gracefully exit/stop working (die)
		you might choose to throw InterruptedException from the flag check and then consolidate the death code in a handler
	java.lang.InterruptedException is a checked exception
		you should catch it whenever block on a thread and do something like e.printStackTrace()

	you can join a dead thread as well - it will silently just return right away
		won't throw any InterruptedException or anything like that, for instance

	you can't throw any checked exceptions from the child thread that aren't declared in their interfaces
		but you can throw unchecked exceptions
		these will just kill the thread (making join() return immediately in another thread)
		the exception will not propagate to other threads

java.util.concurrent.CompletableFuture
	CompletableFuture<Integer> completableFuture = 
            CompletableFuture.supplyAsync(() -> 42);
				takes a Supplier<T>
	CompletableFuture<String> transformedFuture = 
            completableFuture.thenApply(result -> "The answer is: " + result);
	System.out.println(transformedFuture.get());
	java.util.concurrent.Future<T> and java.util.concurrent.CompletionStage<T> are the implemented interfaces
		Future<T> provides get(), isDone(), cancel(), isCancelled(), with and without timeouts
		CompletionStage<T> provides thenApply(), etc.
	get() throws 2 checked exceptions
		InterruptedException is for the main thread based on its own interrupted flag
		ExecutionException is if any unchecked exception was thrown from inside the future's body
			eg. you may choose to use CompletionException
	to cancel the future from the outside, you can call cancel(true)
		this will throw CancellationException on the call to get()
		it is an unchecked exception
	if you have a Future<T> and you want a CompletableFuture<T>, just block on future.get() in supplyAsync() body
	there are a lot of static and instance methods you can use in CompletableFuture to do even more interesting things

no async/await keywords
synchronized keyword for critical sections (java.util.concurrent for more specialized lock types)
	mark a method as synchronized to use instance as lock object when method called
	mark a static method as synchronized to lock on the class itself
	synchonized(lockObject) {} // block to lock on arbitrary object (which can be 'this' if you want)
	reentrant - same thread can lock multiple times and it will be refcounted

	another example usage is to have lock objects created with Object() in a class
		then you can lock in small blocks within methods for fine-grained control
java.util.concurrent.lock.*
	more flexible than synchronized
		eg. multiple conditions per lock and more types of locks
	Lock interface
		lock(),unlock(),lockInterruptably()
		tryLock(), tryLock(50L, TimeUnit.MILLISECONDS) [booleans, immediate]
		newCondition() to get Condition instance
	Condition interface
		can have multiple per Lock
		do not need to lock to create, but do need to lock to signal or await them
		signal(), signalAll(), await()
			with or without timeouts as above
	ReadWriteLock interface
		separate lock for reading and writing
		unlimited people can hold read lock as long as nobody holds write lock
			write lock is exclusive of everything
	ReentrantLock and ReentrantReadWriteLock
		implementations for Lock and ReadWriteLock
Other Synchronizers
	Semaphore(n)
		acquire()
		release()
	CountDownLatch(n)
		countDown()
		await()
volatile
	keyword for instance variables (not local variables)
	instance variables can end up cached in registers, so multiple threads might de-sync on modification
	volatile tells Java not to do this, which can have a performance impact
	variables that are marked final (or are never modified after creation) don't need this as they won't de-sync
	local variables can't use this because local variables used in lambdas should be effectively final
	synchronized {} blocks automatically sync up memory and cache, so variables inside don't need to be volatile
		lock itself doesn't if it's treated as final
	other utilities like atomic numbers and such in java.util.concurrent also don't require variables to be volatile
		see documentation for guarantees
	volatile does not mean atomic
		for instance post-increment ++ still not atomic on a volatile int
	if an object reference is volatile, that only affects the reference variable (not the contents)
atomiticity
	all primitive numerics are atomic for read/write (but not stuff like ++)
	long and double used to not be but are now (for a very long time now)
java.util.concurrent.atomic
	AtomicInteger, AtomicDouble, AtomicBoolean
	Atomic*Array
	AtomicReference<V>
	LongAccumulator and LongAdder

	AtomicInteger as example
		new AtomicInteger() or new AtomicInteger(10)
			defaults to 0
		get(), set()
		getAndIncrement(), incrementAndGet()
			common pattern, get before or after an update
		addAndGet(), etc.
		getAndSet()

		floatValue() and such for atomic conversions

		getAndUpdate() or updateAndGet() to update value with a function
			eg. to apply an equation or more complex logic atomically
wait()/notify()/notifyAll()
	Object methods (called on lock object)
	must be called from a critical section
	wait() puts thread in waiting state, releases lock, and waits to get notified and get lock back
	notify() takes 1 random thread out of waiting state, but it still has to wait for the lock
		then caller continues within its critical section
	notifyAll() release all from waiting state
	canonical usage is producer/consumer
		product() method fills a buffer and notifies
		consume() method waits and uses buffer
	these are considered old-fashioned (java.util.concurrent has better stuff)
		but still essential to know about
Guarded block
	while(!joy) {
            try {
                // Thread goes to sleep until signalled
                wait();
            } catch (InterruptedException e) {}
        }
	// instead of while (!joy) {} which wastes CPU
main thread ending will not stop threads and futures
	System.exit() to force kill everything immediately

Reactive Streams (not streams API)
	Publisher<T> is like observable from rxjs
		has a .subscribe(subscriber) method and that's it
	Subscriber<T> is passed into it and is an interface to handle the data
		onComplete(), onError(), onNext(), onSubscribe()
		gets a Subscription object in onSubscribe so that it can store and use it in the others
		no implementation - you're supposed to implement it (perhaps via anonymous class)
	Subscription
		passed into Subscriber<T> on subscribe
		request(n) to buffer more items
		cancel() to stop
	SubmissionPublisher<T>
		concrete Subscriber<T> with a lot more functionality and methods than just that
			probably need to store it instead of Publisher<T> reference
			asynchronous buffered data
		mainly submit() and close()

java.util.concurrent.Callable<V>
	like java.lang.Runnable but returns a value of type V

Executors
	interfaces for managing threads (executing tasks) in java.util.concurrent
	instead of using Thread directly, lets you separate the concerns of thread mgmt and business logic

	Executor
		execute(runnable)
			how and when runnable is called is up to the implementation
	ExecutorService (extends Executor)
		submit(runnable or callable)
			gives back a Future<T> or Future<?>
		shutdown()
			prevents new tasks being picked up and kills workers as tasks complete
		awaitTermination(timeout, duration)
			tries to wait for all workers to die with a timeout
			to be called after shutdown()
		shutdownNow()
			call if awaitTermination() doesn't work (at least one worker is taking too long)
			returns List<Runnable> of tasks that didn't finish
			uses interrupt() to tell threads to die
			you should make sure to at least do this by the end (eg. in a finally)
	ScheduledExecutorService (extends ExecutorService)
		periodic and/or delayed execution
		uses ScheduledFuture<T>
		for periodic, the value is meaningless (future is just for management)
			if you want to collect results, do it with a concurrent collection yourself
		schedule() is a bit like setTimeout() in JavaScript, but no empty version
			schedule(callableOrRunnable, duration, unit)
		scheduleAtFixedRate(runnable, initialDelay, duration, unit)
		scheduleWithFixedDelay(runnable, initialDelay, delay, unit)
			times from end of previous instead of start of previous
		
Thread Pools
	implementations of Executors
	left side is executor interface, right side is a static call to java.util.concurrent.Executors
	newFixedThreadPool(n)
		n worker threads
		if CPU-bound threads, might use Runtime.getRuntime().availableProcessors() to get this number
	newCachedThreadPool()
		dynamically sized worker thread pool
	newSingleThreadExecutor()
		one single worker thread
	newScheduled*()
		scheduled versions of the above
		eg. newScheduledThreadPool(n)
		eg. newScheduled*ThreadPool(*)
Fork/Join Framework
	you use a special thread pool (both as interface and implementation)
		ForkJoinPool
	then you call invoke() on a subclass of ForkJoinTask<V>
		the result is a synchronous return value (if applicable)
	you generally will subclass either RecursiveTask<V> to return a value or RecursiveAction
		override the abstract compute() method
			it returns void for RecursiveAction (not a member of ForkJoinTask)
		provide base case(s) and return synchronous values for them
		for recursive cases, create more instances of the same type and call fork()
		then call join() to get the synchrnous results of those and aggregate them together
			unlike in normal threads or futures, this only throws unchecked exceptions
		in RecursiveAction, you can use invokeAll() to invoke a bunch of tasks synchronously
	instead of methods like join() throwing exceptions, you can kind of ignore it in the task
		unchecked exceptions will propagate up (rethrown) to the top level invoke()
		no InterruptedException here
	you can avoid making subclasses for tasks/actions by using ForkJoinTask.adapt() static methods
		adapt(callable) gets a recursive task equivalent that translates checked to unchecked exceptions
		adapt(runnable) gets a recursive action equivalent
		adapt(runnable, value) gets a recursive task equivalent from a runnable with a hardcoded return

Parallel Streams
	you can use a parallel stream (see Streams API way above) to do parallel computations too
		without having to worry about managing thread pools or tasks or anything
Thread-Local Random
	java.util.Random is already thread-safe
		but in tight loops, that makes it slower because threads have to wait on each other to get a random number
	this is usually not necessary as you just want random numbers
	so java.util.concurrent.ThreadLocalRandom.current() gives you a thread-local random number generator
		already created and seeded
CopyOnWriteArrayList and CopyOnWriteSet
	thread-safe List and Set that make new copy on all modification operations internally
	very expensive if doing a lot of writes (don't use in that case)
	iterators obtained before modification remain valid and use the old snapshot
TimeUnit
	java.util.concurrent.TimeUnit enum
	DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS
	represents a unit of time rather than a duration value
	used in a lot of java.util.concurrent utilities such as tryLock() as a unit of measure
		tryLock(long duration, TimeUnit unit)
	not used in the older things like thread.join() and Thread.sleep()
	convenience conversion methods
		eg. DAYS.convert(24, TimeUnit.HOURS) -> returns 1
		eg. HOURS.toDays(24) -> returns 1
	also some threading methods
		eg. SECONDS.sleep(10);	// sleep for 10 SECONDS using Thread.sleep
		eg. SECONDS.timedJoin(thread, 10); // thread.join with timeout
		eg. SECONDS.timedWait(lockObject, timeout); // object.wait()
java.time.Duration
	Duration.ofHours(24).plusDays(2).toMinutes()
	can be negative
	converting to less precision will truncate
System.nanoTime()
	if need to get timestamp before and after algorithm
	then subtract and convert as needed

[Javax]
"Java x"
part of java installation but not quite part of stdlib
used to be where new things would go first - now being used less for that purpose

javax.swing
	GUI applications
	components like JFrame, JLabel, JButton
javax.tools
	compile tools
javax.sql, javax.xml, etc.
javax.imageio
	image editing
javax.servlet
javax.crypto

[JUnit]
@Test test* methods in class
assertTrue() etc.
@BeforeEach, @AfterEach
mockito

[Docstrings]
    /**
     * This function calculates the sum of two integers.
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The sum of the two integers.
     */

put before method, class, or package declaration

[Annotations]
@interface DecoratorName {}
	special @ syntax because annotations have some special syntactic sugar
	you would import the name DecoratorName to use @DecoratorName
can then apply @DecoratorName before targets (such as classes, methods, parameters, etc.)
	eg. @DecoratorName class MyClass {}
	eg. public static void f(@DecoratorName int n, String s) {}
they can even be applied to other annotations (meta-annotations), like @Target and @Retention
the symbols you need are in java.lang.annotation.* (import them)

@Target({FIELD, PARAMETER, METHOD}) // ElementType enum members (imported statically above)
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {}
	note that @Target takes an array but we are allowed to ommit the new ElementType[] for annotations
	this annotation targets member variables, function parameters, and methods
		the default (if not provided) is to allow EVERYTHING
	this annotation is retained at runtime
		it can be seen via reflection (eg. by frameworks like Guice and Spring Boot)
		you could use RetentionPolicy.CLASS to have it only available during compilation (in the .class file)
			this is the default if you don't provide it
annotations can take parameters as methods of the interface
	special "default" keyword for default value
	only compile-time constants allowed as default values and parameter values
	annotations use keyword args (unlike functions), but if only 1 called 'value', can ommit the keyword

public @interface DemoAnnotation {
    // #1: Default Values
    int number() default 5;
    
    String text() default "defaultText";

    // Array attribute with default value
    int[] numberArray() default {2, 3};

    // Array attribute without default value
    String[] textArray();

    // #3: Array Syntax Simplification (shown in usage below)
    // When providing more than one value, you can omit the new TypeName[] syntax.

    // #4: Single-Value Annotations
    // If this was the only element and named `value`, we could omit the name when using it.
    String value();
}
@DemoAnnotation(value = "singleValue", textArray = {"arrayItem1", "arrayItem2"})
public class AnnotatedClass {
    //...
}
	could have left out the value keyword if that was the only arg (since called 'value')

in general, annotations can't do anything fancy like classes can
	no inheritance, no generics, no exceptions, no custom types
	no circular references in meta-annotations

java.lang has some useful built-in annotations already
	@Override
	@Deprecated
	@FunctionalInterface
	@SuppressWarnings("name")
in addition, frameworks like Guice and Spring provide their own

[Records]
*not supported by ijava*
lets you define just what you need in a class and have a bunch of stuff auto-generated

record Person(int arg1, int arg2) {
	public Person {}
}

differs from class in following ways:
	record instead of class
	constructor args moved up to typename
	constructor has no args
	can put whatever you want in the class body
		the arg names at the top are PRIVATE instance variables
automatically generated: constructor, equals, hashCode, toString, getters of same name as params
no automatic copy constructor, but you can pass the private args as constructor args to make a copy

[Switch Expressions]
int m = switch (n) {
	case 1 -> 10; // semicolons here
	case 2 -> 20;
	default -> 30;
}; // need semicolon here

-> instead of : to get values for cases
then the result of the switch is a value
because it returns a value, it has to be EXHAUSTIVE (but can have default)

[Compact Numbers]
can put _ between digits in a numeric literal and they will be ignored (for visual convenience)

[Text Block Formatting]
a verbatim block can have .formatted() after to pass format args

[Pattern Matching instanceof]
enhancement to instanceof to allow casting at same time
if (obj instanceof String str) {
            System.out.println(str.length());
        }

[Sealed Classes]
a new thing to restrict which classes can sublcass a class
note that before this feature, 

[AutoValue]
google library with annotations to make value classes and builders
you provide an abstract class and it can fill in the data for you during the build phase

[Spring Boot]
for defining REST server

@RestController
@RequestMapping("/api/books")
public class BookController {

    @Autowired
    private BookService bookService;  // Assuming a service layer handling the logic
    
    // GET all books
    @GetMapping
    public List<Book> getAllBooks() {
        return bookService.findAll();
    }

    // GET a specific book by ID
    @GetMapping("/{id}")
    public Book getBookById(@PathVariable Long id) {
        return bookService.findById(id);
    }

    // POST a new book
    @PostMapping
    public Book createBook(@RequestBody Book book) {
        return bookService.save(book);
    }

    // PUT (update) a specific book by ID
    @PutMapping("/{id}")
    public Book updateBook(@PathVariable Long id, @RequestBody Book book) {
        // Here, you'd typically ensure the book's ID matches the path variable
        return bookService.update(id, book);
    }

    // DELETE a book by ID
    @DeleteMapping("/{id}")
    public void deleteBook(@PathVariable Long id) {
        bookService.delete(id);
    }
}
// assumes BookService is marked as @Service annotation elsewhere for @AutoWired to work

things like @Service, @RestController, etc. define "beans" that @AutoWired can inject

NOTE: PUT is idempotent (updating some object multiply w/ same state = same effect as doing once)
	  POST is not idempotent (posting new objects one at a time)

[Guice]
import com.google.inject.*;
public class BillingModule extends AbstractModule {
    @Override
    protected void configure() {
        bind(TransactionLog.class).to(DatabaseTransactionLog.class);
		// TransactionLog could be interface or class
    }
}
mark things as @Inject in BillingService
	marking constructor = constructor params filled in (recommended)
	marking method = method called on instance creation
	marking method param = that param filled by injection as specified
		overrides any default behavior from the @Inject above
	marking instance variable = filled on instance creation

Injector injector = Guice.createInjector(new BillingModule());
BillingService billingService = injector.getInstance(BillingService.class);
	all @Inject members filled in based on the module's config
	didn't need to add BillingService itself to module

to differentiate instances for an interface, make an annotation and do this in module:
	bind(TransactionLog.class).annotatedWith(PayPal.class)
                                  .to(PayPalDatabaseTransactionLog.class);

to do a factory method in the module:
	@Provides
    TransactionLog provideTransactionLog() {
        // construct and return the transaction log
        return new DatabaseTransactionLog();
    }
	// instead of the .bind() part

to do a singleton:
	either mark the interface as @Singleton
	or add .in(Singleton.class) to the end of the .bind()

to do a primitive type:
	use a factory method that returns the primitive with @Provides
	also use an annotation (eg. @Provides @Unique)
	then use that same annotation on the parameter or member on the other side
	eg. an AtomicInteger in the module that gives out unique IDs

[Big Data]
Apache Hadoop
	MapReduce (map tasks and reducer tasks)
Apache Spark
Apache Beam
Apache Kafka

[Protobuf]
// Constructing and Serializing a Message
        SimpleMessage message = SimpleMessage.newBuilder()
            .setId(123)
            .setContent("Hello Protocol Buffers!")
            .build();

        try {
            // Write the message to a file
            FileOutputStream outputStream = new FileOutputStream("simple_message.bin");
            message.writeTo(outputStream);
            outputStream.close();

            // Read the message from a file
            FileInputStream inputStream = new FileInputStream("simple_message.bin");
            SimpleMessage readMessage = SimpleMessage.parseFrom(inputStream);
            System.out.println(readMessage);
        } catch (IOException e) {
            e.print
		}

[gRPC]
uses protoc and protos as well
but more complex syntax (just use templates)
client uses generated stub for communication and passes protos
service starts and listens on a port
gRPC-gateway is a way to do REST clients from gRPC definitions

[Effective Java Tips]
** see the Effective Java notebook **
readable on phone

[Design Patterns]
** see the Design Patterns Java notebook **

[Interview Tips ***not from notebooks**]
if need to implement linked list, just do it from scratch
	trying to use built-in and then replacing it sounds cool, but causes problems
	by coding to the List<> interface, you end up coding against a lot of methods you won't need
	also causes weirdness with empty Lists
if in an environment where you can't change the imports, you can always use full-qualified symbols!
	but they may have use * with a bunch of stuff to give you a lot of things
don't be hesitant to make classes for tuples and stuff quickly
	copy and paste is your friend (unless on a whiteboard)
if you have to do I/O, consider testing the functions first using hardcoded data and prints
	depending on time and how much a part of the problem the I/O is
if you need a tree or graph, do it yourself (no java version)
	consider just making Node class a struct-like class with no methods
		then updates can be done inline in the algorithm
		depends on how much time you have and how central the abstraction is
compiler doesn't like constructors without <> operator (unchecked warning)
	it works but the type is erased and you lose type safety

Patterns
	struct-like wrapper for updating multiple variables in a helper
		record = f(record, blabla); // treat as immutable
			OR
		f(record, blabla);	// mutate the instance passed in
		basically simulating python tuple
	dealing with empty linked lists/graphs/trees
		usually easier to just use null
			but may need a static wrapper to avoid hardcoded copies of logic to set if null
	for operations like adding items one at a time, consider a wrapper class
		eg. keeps head and last pointers even if singly-linked list
	DFS = recursion or stack
	BFS = corecusion or queue
	to add funtionality to collection, extend class
		interface remains implemented for you
		don't implement interface unless you're prepareed to do the whole thing
		to add your own interface, just add your own as a mixin
	don't forget to subract '0' from char if it's a digit and doing math
	don't forget that % can be used to check if a number evenly divides another
		that should be obvious but I had a brain fart about it in a practice problem
		did some unnecessary float division with epsilon check
	use infinite lazy streams combined and with takeWhile() and such to make iteration less tedious
	generating all combinations of values of a data structure:
		take a version of the data structure in initial state
		take a parameter saying which thing to vary (eg. cell by row and column)
		call a recursive function that iterates the posisble values of the cell
			then calls itself with next cell
			define it such that the recursive calls will chain all the way to the last cell
	recursion into iteration (eg. if not enough stack)
		this will only work if it looks like TCO (single call)
		wrap recursive part in a while loop that terminates on base condition
		modify the variables at the end of each loop iteration to simulate TCO
		make sure the base case is handled properly (eg. after the while loop)
	backtracking
		problem solving approach where you try out solutions and then undo the last part if fails
		can be recursive but doesn't have to be
		eg. try out different placements of queen on chess board and undo placements that don't succeed
		there may be some element of pruning but it's not a synonym for it
		the "generating combinations" pattern above can be thought of as backtracking
			you back out a change that makes a digit too high and move to next cell, for instance
	building string right to left
		build the reverse string left to right and then reverse it at end
		StringBuilder does not use a deque or anything like that
	detecting sortedness
		iterate through and add boolean for each element that is sorted in proper order relative to previous
			first always true, can use a sentinel value to make that work like Integer.MIN_VALUE
		ranges of false values show ranges of the array that are reverse sorted
		don't forget to check both endpoints if do something like reverse a range
	adding items to beginning of stream
		Stream.concat(Stream.of(), theStream)
	skyline/merging train tracks
		all you can do is go through segment by segment and keep the state however is needed for the problem
		there is no clever stream reduction or something that will get you out of it
Caveats
	don't forget to check both sides if do something like reverse a range in-place to sort
		or both ends of row in a train track within a row
	don't forget to make it generic if you can (eg. T extends Comparable<? super T> instead of Integer)
	if given a List-based tuple or something confusing, don't hesitate to make your own class and transform the collection first
		the payoff can be huge when you have complicated nested iteration logic later
	don't forget to count empty rows (eg. rows with no train tracks where all cells can be lamps)
	certain stream operations are missing from Java that you'd have to do yourself with iteration
		zipping of multiple sequences together
		any operation involving adjacent elements (eg. overlapping line segments)
	be careful of going down a stream based rabbithole or making extra copies to make a stream approach work
		be prepared to do a for loop instead at any time
		eg. if checking a grid instead of transforming it, maybe for loop is better
		eg. if feel stream should work but not seeing how to do it, just do for loop
		eg. if using streams for part of it, ok to do iterative for part of it (since java incomplete)
Process
	make and use your own test cases to catch issues instead of being passive
	use theirs, but also make your own
	also write assumptions, inputs, outputs, etc. in comments to help think through problem
		use /* */ instead of // to make it slightly faster to type multiple lines
HackerRank-specific tips
	if you exceed the time limit, make sure you aren't updating the wrong variable or something
		sometimes you think it's because it's pick and you used n^2, but a lot of time it's a bug
		esp. if n is small
	since they hide the test data, you need to System.out.println() a lot to diagnose failures
		don't be too quite to delete these until you're absolutely done
	make pseudocode and clarifications in comments
		and make your prints look like the pseudocode so you can see if it's working
	there's a hidden area in between panes to scroll the whole window (eg. to get back to the code from looking at tests)
	beware of fake errors (slightly yellow/brown colored) due to thing not being used yet
	var doesn't work in Java 8 but does in 15 (don't get confused by things like that)
	watch out for holding down or repeated spaces causing erroneous . to be inserted
