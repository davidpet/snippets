*************************************************************************************
This document represents items that jumped out at me as needing to be studied for Java interviews at a point in time.
Since in the future, different items would jump out at me based on the experience I have between now and then, it is only an artifact of this moment in time.
Going forward, I should review the actual notebooks, but this is so I can study up quickly at first.
Also, the interview tips section is only in here (not elsewhere).
*************************************************************************************

[Online Documentation]
searching for Java Stream, for instance, gives you a Java 8 result
add 17 to the search string to get Java 17 results
as a result of this, a lot of the info in here may be limited to 8 unnecessarily

[Variables]
String
boolean [true, false]
char, byte, short, int, long
float (32-bit), double (64-bit)
no unsigned
L for long literal (instead of int)
f for float literal (instead of double)
	d for double literal also
exponential notation: 1E9, 0.79E-7, 1.0E+9f, etc.
C++ style quoting for strings and chars

interning for numbers and strings
all reference types are nullable
primitive value types are not Object and have boxed equivalents (which have static things too)

== reference or primitive value, .equals() contents, .compareTo() lex, Object.equals() null safe
implicit widening, c-style narrowing (truncates)
	numeric conversions via cast operator only work for primitives
	to do it for boxed types, use methods like intValue()
		these come from the superclass, Number

float near-equality just via Math.abs() on difference and < tolerance
Double.NaN, Double.POSITIVE_INFINITY, Double.isNaN(), Double.isInfinite()

'final' for all constants (but only reference locked)
	local variables and class members
	also for preventing overrides (same keyword)
'var' keyword for type inference
no typedef
variable scoping like C++ instead of Python
no local inline statics (only class members)

Enums
	enum MyEnum { VALUE1, VALUE2 }
	enum MyEnum { VALUE1(0), VALUE2(1); MyEnum(int val) {} }
	enum MyEnum { VALUE1, VALUE2; public void someOtherMember() {}}
	MyEnum e = MyEnum.VALUE1;
	if (e == MyEnum.VALUE1) {}

	actually defines a class that inherits from java.lang.Enum
		which makes all enums REFERENCE TYPES
			and thus nullable
		certain members like equals() are made final
	c'tor is private and can only be called by the values
		has default if none provided (no value specified in the values)
		nobody else can call the constructor
	values at the top are public static final instances
		combined with new() not working, means == always safe
		if any values provided with (), must have a c'tor
	other members can be made private, public, whatever
	could actually ignore what is passed into c'tor and == would still work
		because still a separate instance for each value
		== does nothing with any data owned by the enum, that is for its own use
	
	e.ordinal() for 0-based Index (regardless of actual value)
	MyEnum.values() for MyEnum[] of all the constant values (just what's defined, no gaps filled or sentinels)
		you can then read their ordinals and any public data defined in the enum
		ordinals are indices into this array

	== 5
		doesn't work because not a number like C++

	e.toString()
		the literal name of the value (eg. VALUE1)
	Enum.valueOf(MyEnum.class, "VALUE1")
		string to enum

	to use numbers (or any # of any type of thing) instead of ordinals:
		provide your own method such as intValue() to get it
		provide your own static method such as valueOf() to loop values() and find Matching
		this is recommended over using ordinals because it's more resilient to inserts and deletions

	Constant-Specific Class body
		enum MyOperation {
			ADD {
				public double apply(double x, double y) { return x + y; }
				public void f() {}
			},
			SUBTRACT {
				public double apply(double x, double y) { return x - y; }
			};

			abstract double apply(double x, double y);
		}
		MyOperation.ADD.apply(10, 20);	// YES
		MyOperation.ADD.f(); // NO
	Enum inheriting interface
		interface Operation {
			double apply(double x, double y);
		}

		enum MyOperation implements Operation {
			ADD {
				public double apply(double x, double y) { return x + y; }
			},
			SUBTRACT {
				public double apply(double x, double y) { return x - y; }
			};
		}

		same as above but interface specifies the abstract method so enum doesn't have to
	Extensible Enums
		a design pattern that makes use of the above
		you can make multiple enums that inherit the same interface
		then code to the interface (eg. Operation) instead of the enum
		in the future people can make more enums and add more constants, but the callee doesn't care

uninitialized values have sensible defaults inc. null for reference and numeric 0s for numbers
	however, local variables are still required to be initialized before use or compile error
		ok to initialize in conditional blocks if exhuastive
		same rule whether final or not
	final class instance variables also have to be initialized before use
		have to be initialized by end of c'tor body (can be inline, in a block, in the c'tor)
		can only be set once, but can be set in a conditional, etc.

[Collections]
in general, ranges are inclusive lower bound and exclusive upper bound
sizes in Java are int, which is signed, so collections have a 2 giga-element limit

literal, indexer, etc. only available for arrays, which are a weird type in general
	others only use methods
array can take primitive types but the others must take boxed types
arrays cannot be concated directly (either with + or with a method)
	you could use streams or something else to do so

int[] numbers = {1, 2, 3, 4, 5}; // fixed size, mutable contents
f(new int[] {1, 2, 3});		// only way to pass an array literal
you cannot skip items or leave off the end like in C++
numbers[0]
numbers.length
Arrays.sort(numbers)
int[][] numbers = {{1, 2}, {3, 4}}
	multidimensional array, but actually array of arrays
	numbers.length is 2 here
	new int[10][] allowed (get 10 nulls)
	new int[][10] not allowed (meaningless)
	new int[10][10] allowed (100 0s)

for (var x : numbers) {} // This is the only thing here that matches other collections
no way to take subarray without making copy
	pass indices or make your own ArraySlice wrapper

Arrays class
	static methods to do collection operations on arrays
		in-place mutability
	searching, sorting, conversion to string, equality, filling, etc.
		a lot of overloads such as ranges, comparators, etc.

	asList() is varargs and thus can take an array or individual arguments
	the list it returns is a mutable view on the original array (2-way mutable) but cannot be resized
	
	list.toArray() makes a separate array copy instead of acting like this

	toString() needed because arr.toString() doesn't work as expected

	hashCode() to get hash code of an array of Object

	equals()
	copyOf(original, length) and copyOfRange(original, from, to)
	parallelSort()
	members overloaded for primitive types

	if arrays might be members of the array, you should use:
		deepToString, deepEquals, deepHashCode
		these will recursively expand the next level down

java.util.* for collection interfaces and implementations

List<T> interface
	ArrayList<T> implementation (like c++ vector)
		c'tor overloads to take collection or initial capacity
	LinkedList<T> implementation
list.add(item)
list.add(index, item)	// insert operation
list.addAll(iterable)
list.get(index)
list.set(index, item)
	you cannot reify the list by setting past the end
list.remove(index)
list.remove(item)
	depends on item.equals() [or both being null] to find FIRST MATCh
list.removeAll(iterable)
list.contains(item)
list.containsAll(iterable)
list.indexOf(item)
list.lastIndexOf(item)
list.size() // instead of .length like with array
list.isEmpty()
list.clear()
list.sort(comparitor) // null for default sort, lambda of 2 things otherwise
	eg. Integer.compare can be used
Collections.sort(list)
Collections.reverseOrder()
list.subList(from, to)	// inclusive, exclusive bounds, gets new List<T>
	this is how you slice, and it's a mutable window into the original
	you can modify, append, etc.
	changing length of source invalidates (exception thrown next time read or use)
	if have chain of sublists, they delegate back to each other
		changing length of most derived changes length of others
		changing length of source invalidates more derived
		not the most efficient of doing recursion like in Quicksort
list.toArray()		// will give Object[]
list.toArray(T[] a)	// to force proper runtime type
for (var x : list) {}

Map<TKey, TValue> interface
	Hashtable<TKey, TValue> implementation (order not guaranteed)
		old and not performant, but is thread-safe
	HashMap<> = recommended for non-multi-threaded
	java.util.concurrent.ConcurrentHashMap = recommended for multithreaded
	LinkedHashMap<TKey, TValue> implementation (ordered by insertion)
	TreeMap<> = ordered by key natural order
	EnumMap<> = enum key version
a lot like List<T> except use keys instead of indices and:
	.put() instead of .set()/.add()
	.containsKey() and .containsValue() instead of just contains
iterate keys with .keySet() which gets a Set<TKey>
iterate values with .values() which gets a Collection<TValue>
	iterable collection in case order matters, but for HashMap it doesn't
.getOrDefault(key, defaultValue)
.remove() can take just key or key and value
.entrySet() gets a set of Map.Entry<TKey, TValue>
	you can use getValue() and getKey() to see the members
	you can use setValue() to modify the value (which affects the map!)
	Map.Entry is an interface
		concrete ones are in java.util.AbstractMap
			SimpleEntry - normal one
			SimpleImmutableEntry - for thread-safe maps
			both have c'tors that can take an entry or a key and value
		also some static members like comparables

Set<T> interface
	HashSet<T> implementation
	EnumSet<T> implementation (for bitfield)
more or less looks like List<T> but with no indices

StringBuilder
	append() // instead of add()
	length() // instead of size()
	capacity()
	toString()/substring()
	insert(index, str) // instead of add()
	delete(index1, index2) // instead of remove()
	reverse() // instead of reverseOrder()
	replace() // instead of using SubList() and changing
StringBuffer
	thread-safe version of StringBuilder

Stack<T>
	push/pop/peek/isEmpty
	concrete
Queue<T>
	add/poll/peek/isEmpty
	interface
		LinkedList, ArrayDeque, PriorityQueue
Deque<T>
	queue members but also addFirst, addLast, pollFirst, etc.
	interface
		LinkedList, ArrayDeque

PriorityQueue<T> (concrete, implements Queue<T>)
	smallest item (by natural sort) comes out first
		can provide custom comparator to change how Ordered
			eg. Comparator.reverseOrder() makes it use max value instead of min
	implemented via heap that uses comparator (minheap by default, maxheap with reverseOrder)

RandomAccess interface
	a marker interface with no members
	used by algorithms like binary search to check whether a collection can do random access
		eg. implemented by ArrayList but not LinkedList
		that way the algorithm won't do something bad like seek back and forth on a linked list

Missing from Java: tuple, struct/value type, tree, graph

	POD Type
		in addition to the newer record type, making a POD like a C++ struct is not that bad
		just making a class with public variables and let the c'tor default

Immutability
	Collections.unmodifiableList(existingList)
		gets a List<T> that will throw if you try to modify the list
	List.of(existingList)
		shorthand for the same thing
	these are both available for sets and maps too

Conversions
	collection constructors take collections as args where appropriate
		but not arrays, because arrays are not collections (use asList if needed)
	Arrays.asList()
		should be efficient since just a view on the array
	List.of() for getting immutable from mutable

Casting
	the issue of boxing only comes up in arrays because they can take primitives
	you cannot cast a whole array between boxed vs. unboxed in one cast
	you can cast an array from Object[] to Integer[] for instance though
		you can't do this (directly) with generics though
		caveat: this only works if the array is created as Integer[] and not Object[]
			so for an API such as stream.toArray(), this won't work
			it's a whole array cast and not an element-by-element one

	to cast elements for collections/generics, the syntax is weird:
		List<Object> objList = (List<Object>)(List<?>)list;
        	List<Integer> castedList = (List<Integer>)(List<?>)objList;
		or just use the wildcard to declare objList and don't cast anything

Aggregates
	Collections.max(), Collections.min()

Sorting/Shuffling
	Collections.sort(), Collections.shuffle()
	Comparator<T> functional interface can tell collections how to sort things
	java.util.Comparator has static methods to get comparators to pass
		Comparator.naturalOrder() = use Compareable<T> of elements
		Comparator.reverseOrder() = use opposite of natural order

Searching
	assuming a sorted collection (natural order)

	Collections.binarySearch(list, item)
		natural order search, taking into account whether instanceof RandomAccess
		depends on Comparable<T>
		gets index if found (same = undefined which will get)
		-(insertionPoint + 1) if not found
			so that you can use < 0 to know
			where you'd insert it if you wanted
	Collections.binarySearch(list, item comparator)
		same but custom comparator
	Arrays.binarySearch()
		same as all the above for arrays
		lots of overloads for primitive types since not generic

Simulating Literals in non-arrays
	Arrays.asList(item1, item2, item3) to make an array list that can't be resized (but is mutable)
	{{ }} anonymous class with initializer block (caution!)
	List.of(), Set.of(), etc. in addition to taking mutable versions of the collections, can take varargs to specify items inline
		explicitly disallow nulls for philosophical reasons
		this restriction doesn't apply to Arrays.asList() or Stream.of()
		also doesn't apply if wrap existing list with unmodificableList() call

Filling with Values
	new int[5] gets 5 0s
	Arrays.fill(arr, 100) fills the array with 100 afterward
	Collections.nCopies(n, val) gets a new immutable list
		pass into ArrayList<> c'tor to get mutable one from it
	Collections.fill(list) to fill existing
	
Cloning
	arr.clone()
	copy constructor for the rest

Extending
	collection types in java.util not marked final, so you can extend

Thread Safety of Collections (and other types)
	to make any non-thread safe thing thread-safe, you need to do your own locking and such
		but some types are already thrad-safe and some have thread-safe alternatives
	primitive numbers themselves are thread-safe
		but operands like ++ (as post-increment) are not because they store and modify non-automatically
		java.util.concurrent.atomic.AtomicInteger is example of an atomic version provided for that purpose
	anything immutable is thread-safe by default ONCE CREATED because you can only read it
		eg. String, Integer, List.of(), etc.
		keep in mind any iterator from an immutable collection is mutable and thus not itself thread-safe
	mutable collections (and arrays) can be assumed to be NOT THREAD-SAFE by default
		Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedSortedSet(), etc.
			can wrap mutable instances of the various interfaces
			because the wrapping is done at the interface level, basically you use the same interface (eg. List<>)
				and the wrapper locks (on itself) before forwarding calls
				if you access the unwrapped one, you are bypassing the locking
			similarly, Collections.unmodifiableList() and those wrap the same interfaces and make any writes fail
				this can also make it thread-safe if you don't need to write to it
				if you don't need writes, this might be a more efficient way to be thread-safe
	the following collections are already thread-safe
		Hashtable is thread-safe but slow (ConcurrentHashMap is faster)
		Stack is thread-safe because inherits Vector
			but Deque is not
	there are also thread-safe alternatives to some of the built-in collections you can instantiate
		Vector <-> List
		ConcurrentHashMap <-> HashMap
		PriorityBlockingQueue <-> PriorityQueue
		StringBuilder <-> StringBuffer

		Vector implements List<> and is thread-safe
			but is much older and retrofitted to support List
			so don't use unless you have to

Sorted interfaces
	SortedSet and SortedMap interfaces
		inherited from Set and Map
		add methods like first, last, subSet (or firstKey, lastKey, subMap)
		implementations include TreeSet and TreeMap

Bitfields (EnumSet)
	EnumSet is built for an enum type and maps 1 enum value per bit as a bitmask
	you use static methods of EnumSet to create them and then treat like any other set
	EnumSet.of(val1, val2)
	EnumSet.allOf(MyEnum.class)
	EnumSet.noneOf(MyEnum.class)
	EnumSet.complementOf(otherSet)
EnumMap
	built around an enum type - uses fixed size array based on knowledge of total keys
	new EnumMap(MyEnum.class)
	new EnumMap(otherEnumMap)

Implementing Objects for Collections
	to put into a collection that uses hashes, you will need hashCode() and equals()
		to do operations like remove() on a list, you will need those as well
		utilize Objects.hash(...) to make this easy
	to support sorting and operations like that, you will need to implement Comparable<T>
	to support writing the collection to a string, implement toString()

Swapping
	Collections.swap(list, i1, i2) for lists only
	none provided for array or in general due to no ref parameters

Iterators/Iterables
	collections implement Iterable<T> interface in java.lang
		has an iterator() member to get an Iterator<T> (java.util)
	Iterator<T> has hasNext() and next() and some default methods
	the interface is compatible with laziness for things like streams

Empty Constants
	Collections.EMPTY_SET, EMPTY_LIST, EMPTY_MAP
	immutable

hashCode(), equals(), and toString() implementations
	collections already implement based on their items
	the abstraction is lower level than the container, so it doesn't depend on other state
	eg. immutable list vs. mutable list have same hash if same items
	this makes collections suitable to be composed into higher collections (eg. use List as tuple)
	this also makes multidimensional lists and such just work without any special handling or deep* methods

Deep copies
	using arr.clone() or a collection constructor gives you a 1-level (shallow) copy
	there are 2 approaches to make a deep copy:
		1. manually via iteration
		2. using streams
			the outer collection becomes a stream which is collected back again
			the inner colleciton can be copied with a copy constructor, eg. in a map()

[Strings]
c++style comments (// and /* */)

reference type/interned/immutable
not array, not indexable with []

+ or .concat() [fluent]
automatically converts with toString() if type is not string

str.length() [insted of size() like collections]
str.toCharArray() char[]
str.charAt(index)
str.trim()
str.startsWith()
str.toUpperCase()
str.substring()
str.replace()
	replace all occurences of string or character
str.replaceFirst()/str.replaceAll()
	replace all or first occurence(s) of REGEX
str.matches()
	full-string REGEX match check
str.split() -> String[]
	REGEX used for thing to split on
	each occurence swallowed and becomes comma in array
	internal empties possible but empties at end are removed
compiled regex patterns have similar methods to the last few above
no built-in reversal in either strings or arrays

to modify part of a string, you need to break it (eg. with substring) and concat the result
	even for single characters
	or alternatively, use toCharArray(), modify the array, and use new String(arr) [incurs 2 copies]

to sort a string, convert to char array, use Arrays.sort(), and new String(arr)
	overloads like no params, range of indices, comparators, etc.

String.join(delimStr, collection)

most built-ins and collections have a proper toString() except for arrays (use Arrays.toString())

C++ style single and double quotes (strict separation of string vs. char literals)
""" for verbatim string (raw and multiline)
escaping just like in C++

Character.isLetter(), Character.isDigit(), etc.

System.out.printf(formatString, ...) like in C++
	does NOT print a newline at end
	%s
		uses toString() of the object passed in
	%d
	%02d [2 digits padded with 0]
	%.2f [2 places after decimal]
	%2$d [2nd arg after format string used for the %d, instead of natural order]
String.format() is like sprintf
do not pass a float when int is expected or vice versa
	but passing short or long instead of int for instance is fine

Double.parseDouble(str) to get double from string
Double.toString(d) to convert primitive to string

java.util.regex.*
	pattern = Pattern.compile(patternString)
	matcher = pattern.matcher(content)
	if (matcher.matches()) {}

math on char -> integer -> can cast back to char

line endings
	file readers are resilient
	writing with \n usuaully ok
	System.lineSeparator() if need to get for system

case insensitivity
	static comparator String.CASE_INSENSITIVE_ORDER
	method s.compareToIgnoreCase()

[Operators]
math & bit & boolean & comparison & assignment operators are exactly like C++
string concat + with things like ints and list automatically converts with toString()
	null becomes "null" in the actual string
string .concat() fluent method available too
no coalescing (other than methods of Optional and Map) or safe navigation
.getClass() for instances and .class for types
A instance of B (for reference types only)[false if null]

Casting Details
	Object o = m;
		implicit cast that compiler can handle - no runtime check needed
	m = n; // same type
		compiler can already tell, so no runtime check needed
	MyClass m = (MyClass)o;
		runtime cast
	short s = (short)x;
		runtime cast
	int x = s;
		runtime cast (implicit)
	Integer x = list.get(0)
		runtime cast because generics store bases
	
	a runtime cast will throw ClassCastException (unchecked) if it fails

[Control Flow]
ranged-based for (enhanced for loop)
	[remember to use : instead of of, in, etc. like some others]
	legal (but uncommon) to put 'final'
if/else if/else and switch work basically just like C++ (with optional braces for single line, default fall-through in switches, etc.)
switches also work on non-numeric types and for enum values, you don't have to specify the enum in front in the cases
for/while/do while work just like C++ (plus the range-based for which c++ now also has)
	remember middle condition is dynamic and variable can be messesd with
try/catch/finally/throw just like in C++
try-with-resources
	try (BufferedReader reader1 = new BufferedReader(new FileReader("file1.txt"));
             BufferedReader reader2 = new BufferedReader(new FileReader("file2.txt"))) {}
			 variable gone outside the scope (unlike python)
	try(reader)
		only if effectively final and already initialized
	allowed to let exceptions propagate out
assert condition: string
lazy list
	streams are evaluated lazily
	or you can do it yourself by making your own iterator for your object
main function args = just the args themselves (String[])
truthiness: only actual booleans can be used in things like if/else
	need to do == null, == 0, isEmpty(), etc. on anything else

some useful built-in exceptions:
	NumberFormatException (unchecked): bad conversion from string to a number
	ArithmeticException (unchecked)
	UnsupportedOperationException (unchecked)
	IllegalArgumentException (unchecked)
	ClassCastException (unchecked)
	java.io.IOException
		java.io.FileNotFoundException

key exception members
	getMessage()
	getCause() [an exception]
	getStackTrace() [an array of stack trace info elements]
	printStackTrace() [overrides for streams or just prints to System.err]

[Functions]
just like TypeScript, C#, etc. (access, modifiers, etc. all together)
	except all functions are methods of a class (no top-level)
throws keyword to specify exceptions (checked required, unchecked optional)
	unchecked inherit from RuntimeException
	checked inherit from Exception (more general)
positional args only, no keyword args
overloading allowed
	if overloading between static and non-static, the signature can't match
no default args directly (simulate with Optional and/or overloading)
	java.util.Optional
	Optional.of() [no value]
	Optional.of(value) [populated, assumed not null]
	Optional.ofNullable(value) [populated if not null]
	val.isPresent(), val.get(), val.orElse(default)
	Optional.stream() to get 0 or 1 element stream
variadic functions
	int... numbers
		this param becomes an array
		you can either pass an array to it or pass multiple integer arguments that it will put together for you
		ommit args entirely to get empty array
not supported: spread, nested functions, inline functions, macros, extension methods, ref and out parameters
var
	ok as variable that gets a function call as a value
	not ok as function return type or parameter type
recursion works like normal (by name), but no TCO

params can be marked final, but it only prevents the local references and not the objects
	uncommon

param names aren't part of the unique identity of a method
	just method name and param types
	that makes things like lambdas work despite different param names being used
	also means you can implement multiple interfaces where they use different param names but same types, with 1 method

[Functional]
"skinny arrows"
	Runnable runnable = () -> System.out.println("bla");	// ok doesn't return value
	(a, b) -> a + b
	(a, b) -> { return a + b; }
	(Integer a) -> a * a
	x -> x * 2
big difference from all other languages = what the type of a lambda (or a method reference) is and how you call it
	"functional interface" = an interface containing 1 abstract method signature
	assigning a lambda or method to it automatically makes it callable via the method on the interface
	primitive types ok in your own interface, but generic interfaces like in java.util.function can't take them
	@FunctionalInterface annotation recommended on functional interfaces

	functional interfaces can have static and default members too (only the public abstract member matters for lambdas)
		eg. Comparator<T> has a lot of statics such as Comparator.naturalOrder() and defaults as well
		eg. Function<T1, T2> has compose() default method for doing function composition
		default methods are fluently chained rather than modifying any state

Runnable = takes nothing, returns void
	.run()
java.util.concurrent.Callable<V> = like runnable but returns a value
	.call()
		can throw any checked exception
java.util.function.Predicate<T> = takes val and returns boolean
	.test(T val)
	default methods for combining:
		.and(predicate)
		.or(predicte)
		.negate()
	static methods for creating:
		.isEqual(otherObj)
java.util.function.BiPredicate<T1, T2> = 2 input arg version of Predicate
	.test(T1 t1, T2 t2)
	same methods as Predicate<> besides that
java.util.function.Consumer<T> = takes val and return void
	.accept(T val)
	default methods:
		.andThen(consumer) for chaining consumers for each value
java.util.function.Supplier<T> = takes nothing and returns a value
	.get()
java.util.function.Function<TArg, TReturn> = takes single param and returns value
	.apply(TArg arg)
	default methods:
		.compose(beforeFunction) to apply another function first and then apply this one
			eg. think of f(g(x)) - you have f(g) and then you make it f(g(x)) by calling this
		.andThen(afterFunction) to do the opposite of compose
			eg. you have g(x) and then you make it f(g(x))
	static methods:
		.identity() to always return argument as return
java.util.function.BiFunction<TArg1, TArg2, TReturn> = function of 2 params
	.apply(arg1, arg2)
	default methods:
		.andThen(function) to apply further transform on the result
java.util.function.BiConsumer and java.util.function.BiPredicate = 2 arg input verisons of those

java.util.function.UnaryOperator<T> = Function<T, T>
	all members of Function
java.util.function.BinaryOperator<T> = BiFunction<T, T, T>
	static methods:
		maxBy() and minBy() both taking Comparator<T>
	plus all members of BiFunction

java.util.function has versions of the above with various combinations of primitives as well
	to get around the limitation of generics not accepting primitives
	in general, composition methods tend to stick to their own type
	the naming convention seems to be:
		add AsType to the end of methods that return a primitive
		leave name alone if just taking primitive as args

	eg. BooleanSupplier
		.getAsBoolean()
	eg. DoubleBinaryOperator
		.applyAsDouble(d1, d2)
	eg. DoubleFunction<R>
		.apply(d)
	eg. DoubleToIntFunction
		.applyAsInt(d)
	eg. ObjectIntConsumer
		.accept(obj, n)
	eg. ToIntFunction<T> // note this is different from IntFunction!
		.applyAsInt(T t)
	eg. ToLongBiFunction<T1, T2>
		.applyAsLong(T1 t1, T2 t2)
	

"effectively final rule" - closures (and other code) must treat enclosed variable as final
	but they can change members, so that's how you can use a lambda to modify state
not supported: _ for ignored args, partial application (just use a lambda), type inference (var) on lambda variable

Method References
	to assign a class method to a functional interface variable (treat it like a lambda)
	looks like scope resolution :: in C++
		eg. MyClass::MyMethod
	if you use the class name to the left, it is "unbound"
		then it has to be called with the 'this' object as the first argument
			unless it's a static method - then it is unbound but has no 'this'
	if you use an instance to the left, it is "bound"
		the 'this' is stored internally where you don't need to see it
		just call it like it's a static method or lambda
	you are not allowed to treat a static method as an instance method by just binding its first arg
	if the method is overloaded, the compiler can usually deduce which one from the context
	constructors as methods are special
		use 'new' as the name and treat as static
		input = c'tor args, output = instance of the type
		eg. MyClass::new taking c'tor args
		eg. int[]::new taking length of array

Streams API
	this is the way you do functional operations on collections in Java (but it's also used other places)
	java.util.stream.*
	someCollection.stream() will give you a Stream<T> object
	then call methods on that Stream<T>, such as .map(), .filter(), .reduce() // which doens't need a collector
	when you're ready to make it back into a collection, call the .collect() method
		eg. .collect(Collectors.toList()) or toSet, whatever
	various collectors like getting max value, converting to string, groupBy (returns a Map), etc.
	do the above fluently (eg. List<int> newList = list.stream().map().collect())
	custom collectors can be implemented via Collector<> interface (which is complicated)
	Collectors doesn't deal with arrays
		stream.toArray() returns Object[] (which can't be cast)
		stream.toArray(Integer[]::new) returns Integer[] // no primitives allowed
		primitive arrays like IntStream have their own toArray() with primitive return array types
	the toMap() collector requires a method reference/lambda for key and value
		it will take whatever object it has, which can, for instance, be a Map.Entry<>
		then apply the methods you give it (such as unbound getKey and getValue methods)
	Map doesn't support stream(), but keySet(), values(), and entrySet() of course do

	forEach(x -> System.out.println(x))
		does not return another stream
		if the stream has no guarnateed order (eg. parallel), use forEachOrdered() instead if needed
	forEach(System.out::println)
		clearer style

	findFirst()/findAny()
		terminal operations that get 1 single value (first or non-guranteed order)
		use these after filter() to find the first or random matching value based on lambda
			ok due to lazy evaluation
		both return an Optional<> so you need to check it

	Stream.of() for creating based on values
		variadic (args or array)
		don't use a primitive array - that will get interpretted as Stream<int[]> instead
			Integer[] works though

	any operation on stream closes it
		different from Observables in JS
		have to remake or collect intermediate to provide branching

	IntStream = primitive int stream (not Stream<>) for perf.
		IntStream.range(0, 10) for a stream of 0..9
		IntStream.of(1, 2, 3) for variadic args(or single array) giving values
		stream.mapToInt(n -> n) // boxed to primitive (could use Integer::intValue too)
		s.max(), s.asDoubleStream(), s.forEach()
		s.toArray() to collect as an array of int
		s.boxed() to make a Stream<Integer>
		s.<T>mapToObj() to provide custom conversion to Stream<T>
		cannot collect() [use boxed() or mapToObj first]
			the method is there but it doesn't work, probably because of generics
		can assume most Stream stuff is there (eg. of(), concat(), etc.)

	tips for readability:
		use static imports (eg. toList())
		use method references instead oflambdas (eg. Integer::valueOf)

	lazy evaluation
		only terminal operations (get actual value(s)) cause real evaluation
	infinite sequences
		Stream.iterate(seed, lambdaOnPrevValue) -> infinite lazy sequence
		eg. Stream.iterate(1, n -> n + 1) -> all positive integers
		eg. STream.iterate(0, n -> n + 2) -> all even nonnegative integers
		then you can use map() etc. to transform further
		do not accidentally assume n is the index! (be careful)

	other interesting stream methods
		allMatch(pred), anyMatch(pred), noneMatch(pred)
		count(), max(), min()
			note that count() is a long instead of int
			implies that streams can be more than 2 GB elements
		distinct()
		mapToDouble(fn), etc. (to get DoubleStream for instance)
		flatMap(fn) (map elements to streams and then concat them lazily)
		flatMapToDouble(fn), etc.
		generate(supplier) to generate based on a generator function
			infinite only - no way to signal stop
		limit(n) and skip(n)
		toArray()
		sorted() and sorted(comparator)
		peek(fn) [like tap() in rxjs]

	static members
		concat(stream1, stream2)
			lazily do stream1 elements then stream2 Elements
		empty()
			to get an empty stream

	Other uses of Streams
		Random.ints(), Random.longs(), etc. [infinite random sequences]
		optional.stream() [0 or 1 elements]
		java.nio.file.Files.lines(Paths.get(path))
			use with try-with-resources

	Parallel Streams
		collection.parallelStream()
		stream.parallel()
		uses ForkJoin framework under the hood

		terminal operations like collect(), findFirst(), etc. put the order back
		intermediate operations like map() don't respect the order (for parallelism)
			some operations like sort() will still have order dependence and not benefit
		need to benchmark for specific problem to see if worth it
		forEach vs. forEachOrdered behaves differently in this case

		can turn back into sequential stream with stream.sequential()
		
	Unordered Streams
		stream.unordered()
		intermediate and terminal operations lose order dependency
		may have performance benefits in some cases
		unordered collections like HashSet<T> will already use this out of the box

	Stream Builder
		Stream.builder().add(val1).add(val2).build()

	AutoCloseable
		streams are autocloseable so that you can use them with file I/O etc.
			then the try-with-resources will close the file
		does not interact badly with using map() etc. inside the try {}

	Fibonacci Example (mine)
		Stream.iterate(new int[] {0, 1}, a -> new int[] {a[1], a[0] + a[1]}).mapToInt(a[0])
			then just limit() and toArray() to get final result

	Newer (9+) Methods
		`dropWhile(predicate)`
			- skips elements as long as predicate keeps matching
			- for ordered stream only
		`takeWhile(predicate)`
			- takes elements as long as predicate keeps matching
			- for ordered stream only
		`ofNullable(e)`
			- similar to Optional.stream()
			- 1 element if non-null, otherwise 0
		`mapMulti*`
			- methods for mapping multiple elements onto each element
		`iterate(seed, predicate, operator)`
    		- new overload of iterate() to allow for stopping when a condition stops being met (non-infinite)
			- functions like a for loop where the index variable is the thing being generated

	Method References
		don't forget to try to use method references instead of lambdas when you can
		eg. System.out::println for forEach() or peek()
		eg. Objects::nonNull for predicates

	Iterator
		stream.iterator() gets an Iterator<T>
			closes the stream (terminal)
			still lazy
		stream doesn't implement Iterable technically, so can't do range-for

	Zip
		not available, but you can simulate it yourself with iterator() and generate()
		save 2 (effectively final) iterators and call generate with a lambda
		use sentinal values for hasNext() being false and then use takeWhile() to cut off the end

	Infinite Repeated Value Stream
		Stream.generate(() -> 100)

	Chess Queen Attacks
		to avoid writing 8 nasty for loops
		create one-liner methods to do upward, downward, and repeated infinite sequences from a number
		then make a zip method to make chess squares sequence from two of those (infinite)
			use a Square class instead of a List for clarity
		then make a predicate to check for valid squares based on boundaries and criteria of the problem
		then make a countAttacks method that does takeWhile() on that predicate on the zipped squence and count()
		the final result is the sum of 8 calls to countAttacks(zip()) with all the combos of the methods

		the iterative alternative is 8 for loops, each with either nesting or hardcoding one of the variables
		then each for loop has to check other criteria (like if hits obstacles) and bail
		then just increment count each non-bailed iteration
		conceptually the same but uglier, more repetitive, and have to craft each loop w/ copy/paste

Exceptions
	lambdas can't have throws specifications, but interface members and methods can
	basically when you assign a lambda to a functional interface, it is assumed to match the throws
	you can throw less than what is specified, but not more (in terms of checked exceptions)
	this means that for instance, if you use Thread with Runnable, you can't throw any checked exceptions
		have to rewrap to unchecked or silently deal with it internally somehow

IIFE
	((Runnable) () -> System.out.println("Hi!")).run();
	Predicate<Integer> p = ((Predicate<Integer>) x -> x > 0).and(x -> x % 2 == 0);
		don't forget to specify the type args instead of using the raw type or it won't work

[Classes]
overall syntax looks like a lot of other languages
	access specifier on class, then methods as described in [functions] above, and variables
	final for constants, static for statics, even the class can be static, etc.
	'this' implicitly like in C++
		not required to access members from inside like in JavaScript/TypeScript/Python
	constructor named after class like C++ (and overloadable)
always use new() [no stack variables like in C++ or ommitting entirely like in Python]
finalize() for destructor on garbage collection
Cloneable interface clone() method for copy
default constructor (just 1) if no constructor, otherwise only the one(s) you specify
not supported: operator overloading, partial classes, custom value types, properties (as other languages use them)[setValue, getValue pattern], call operator
	a key effect of not supporting properties is that there can't be read-only fields (except by methods)
name hiding also not supported (all methods virtual and always get the most derived one no matter which reference type)
	except for private members which are always hidden and non-virtual

static members can be accessed via method or class and use . (not :: like C++, only method references use that)

values can be initialized inline or left to their defaults
	need not be constant expressions
	more caveats about this in Construction Order below

Access Modifiers
	public, private, protected, default (which is never specified)
	default means package (not file necessarily)
	applies to methods, variables, classes within classes, and top-level classes
	like C++, can access and possibly change private members from other instances (we are all robots)
	"friend class" equivalance = nested class, package-private members
	'private' members are not virtual
		subclass can provide one of same name and it means different thing
Inheritance
	"extends" to subclass
	"implements" to implement interface (comma separator for multiple)
	@Override annotation for overridden methods (in java.lang)(technically optional since all are virtual)[even for interfaces]
	super() to call base constructor in constructor
	super.method() to call base method from derived method
	can "extend" 1 class but "implements" as many interfaces as you want
	can mark a method as "final" to prevent overriding
	can mark a class as "final" to prevent subclassingf
	covariant return types supported
	you can increase access in a subclass (eg. make a protected member public)
		but you can't go the other way
		remember that private members aren't seen by the subclass, so you're not exposing anything
	static members are not virtual and exhibit name hiding behavior
		a subclass type or instance can access all statics from it and all bases
			but any of the same signature in subclass will hide the base
		a base class reference or the type itself will see its ow statics, not the overriden ones
		interfaces are special - classes implmenting them do not see the statics at all
			they have to be referenced via the interface as the type
Initialization Blocks
	no initialization list like in C++, but this is very similar intent
	naked {} inside class means code that will run before the constructor, which you can use to initialize things
	static {} are static initialization blocks that effectively gives you a static constructor like in C#
	multiple {} and/or static {} in class are run in sequence
Delegating Constructors
	this() within constructor to call another overload (presumably has to be first)

ABCs
	mark the class as 'abstract' and then mark methods as 'abstract' (no bodies or =0)
	an interface is not an ABC because it can't have variables inside an instance
Interfaces
	'interface' keyword and then abstract methods (no body, no =0 like C++, NO 'abstrat' keyword)
	all methods public and abstract by default (and can't be changed)
		the normal case is to just have those
		need to explicitly declare the overridden methods as 'public' when implementing
	can also have static members
		variables with no modifiers automatically public static final
		methods marked with static can have a body
	can also have 'default' methods
		body used in implementing class if not overriden
		effectively adds another public abstract method but subclass can ignore it if wants to use default
			should not collide with an explcitly public abstract method
	can also have 'private' methods (with bodies only)
		only to be used by static and default methods (not from outside)
	
	method name collisions = same method just use for both automatically
		if default methods, have to override it
			Interface1.super.f() to call within the class method

	an abstract class can leave out interface methods, but a concrete class cannot
		an ABC can specify missing methods as abstract, or just ignore them
		either way, a concrete class must have everything filled in

	interface can inherit one or more other interfaces via 'extends'

	interfaces can be generic (as many of the built-in collection ones are)
Object
	root of all reference types (implicitly inherited if no inheritance specified)
	@Override methods to provide systemic behavior
		toString(), equals(), hashCode(), etc.
	not abstract
		new Object() is allowed
			eg. if need opaque object reference for synchronization lock, etc.
Objects static class
	some null-safe versions of normal Object methods
	Objects.equals(a, b)
	Objects.hashCode(o)
	Objects.toString(o) and Objets.toString(o, default)
		returns null or default on null
	Objects.hash(o1, o2, o3)
		variadic method to hash multiple objects into 1 hash
		useful to call for hashCode() implementation of class with its members
		hashes the varargs array using Arrays.hashCode()
	Objects.isNull(o) and Objects.nonNull(o)
		useful for predicates

Useful Built-in Interfaces
	Cloneable
	AutoCloseable

Nested Classes (a weirdness of Java)
	to provide a nested class like you would in another language (just namespaced under the parent),
		you need to make it a "static" class (even if it has no static members)
	without static, it is an "inner class" and has to be constructed with the outer class instance as an arg
		Outer.InnerClass inner = outer.new InnerClass()
	methods of "inner classes" can access members of the outer class without any qualifier
		so it's basically just a subsection of the main class rather than its own thing
		can access private members
	nested interfaces behave more like normal nested types (always static)

Boxing/Unboxing
	implicitly works most of the time (autoboxing/autounboxing)
		can use Integer.valueOf() and boxedInt.intValue() to do it explicitly if needed
			eg. to cast to another reference type, you need to box first
	short lowercase primtivies <-> capitalized full word boxed types (eg. Integer, Character)
	the boxed types also have static methods you can call to do useful stuff and get attributes like:
		MAX_VALUE
	boxed types are still interned unless you used 'new' to create them
	boxed types are IMMUTABLE (value can't be reset for an instance)
	a lot of operations like <, +, etc. implicitly unbox and rebox and work as expected
		even in generic methods that use the boxed types

Anonymous Class
	MyInterface obj = new MyInterface() {
            @Override
            public void display() {
                System.out.println("Inside AnonymousClass");
            }
        };

	works for either interface or class with same syntax
		only 1 thing, no way to specify more
	no way to specify constructor because no name
		can do {} though, which will safely run after the base is constructed

	can provide c'tor args for base class in the ()

Construction Order
	1. super() call [which must be first or not present in c'tor] kicks off base construction
		super() cannot be called with any instance members of derived class because not constructed
		if super() call not present, it's implicitly there at the beginning
	2. all base construction events happen completely
	3. all {} and = in the class body are run as a flat sequence in order
		{} can only access variables declared before it physically
		can call methods in both {} and = statements but beware of construction order
	4. rest of c'tor body is run

[Generics]
type parameters can only be reference types (no primitives)(but arrays are allowed, even arrays of primitives!)
generic methods are weird in Java
	public static <T> void f(T t) {}	// the <T> goes before the return type
	myObj.<Integer>f();			// the <T> goes after the dot
		only if need to specify (just myObj.f() if can be inferred)
		CANNOT call as <Integr>f() with no . in front
generic classes are more normal (<T> after class)
	type can be inferred or specified as normal
	use the diamond operator on constructors to avoid unchecked warning from compiler
	unchecked warning is triggered when you use raw types and should never be suppressed
<T extends Number> type constraints (Number of a subclass of Number)
	<T extends MyClass & MyOtherInterface>
type inference boxes for you when it can
nested <> are fine

not supported: metaprogramming, void as type arg, overloading by # type args
	there is a workaround for void as type arg (java.lang.Void type)
		subclass of Object with no members (can't convey any state)
		can pass null
		no way to intermix with true void
Type Erasure
	runtime type of generic has no type args
Raw Types
	use of raw types triggers an unchecked warning from compiler
	List<Integer> l = new List();
		technically allowed and will work correctly
		bad style because less explicit and could result in refactoring mistakes
		use <> operator
	List l = ...
		the interface used on the left is raw
		the compiler will allow you to use any type with it because the type is unknown
		List<Integer> l2 = l;  List<String> l3 = l;
			both of these work because for all the compiler knows, this is List<Object>
		l.add("Hi") will work even if the instance is List<Integer>
			because the generic class is just dealing with Object references
				or if it does <T extends...> then whatever that type is
		if the instance has <T extends...> then l.add() will check against that
			but could still be the wrong type compared to code using it
		x = l2.get(0) will throw exception at runtime because it will cast
			because generics are dealing with Object, an implicit cast has to happen
			thus, the runtime type is checked in the assignment
		however, using System.out.println(l.get(0)) will not throw an exception
			because println takes Object and doesn't care
	this is allowed due to backward compatibility from before generics were introduced
	also, the raw type is legit to use for STATICS in the class
diamond operator: List<Integer> l = new ArrayList<>();
	other scenarios where it works:
		passing into method because it knows what method expects
		List<List<>> can be List<> if subtype can be inferred too
		only class creation (not function call)
	sometimes, ommiting the <> will work, but you should include it anyway
		more explicit/readable and makes some compiler warnings go away
Wildcards
	because casting element types in the parent generic type doesn't work, the concept of wildcards is needed
		for method params, variable declarations, etc.
	List<?> is like List<Object> but with no casting needed
	List<? extends Number> works like <T exends Number>
		and can use & operator if needed
	it is possible to cast to the wildcard version first and then to the Object version and such (runtime error when access but not create if wrong)
	wildcard type constraints are totally separate from generic type constraints
		you can't ommit or copy and paste them - have to consider the covariance/contravariance
	you are allowed to return wildcards from methods but most of the time won't want to
		using a generic type param instead lets the caller specify the type and use it as more than Object
	also in many cases a method could take a wildcard but takes a generic type arg instead
		such as in standard library sort and search methods
	<T extends Comparable<? super T>
		this example shows a case where wildcards wouldn't even cut it by themselves
		Collections.sort() looks like this
			but Collections.swap() is not generic and takes List<?> because it doesn't need that interface
		this idiom means we'll take a Dog that is a subclass of Animal even if only Animal implements Comparable
Covariance/Contravariance
	<? extends Number> is Covariance [read-only]
		don't know the type but know it's AT LEAST a Number
		that means we can read Number from the generic (return values)
			but we can't write values to it (pass parameters)
	<? super Number> is Contravariance [write-only] (only for wildcards, not generics themselves)
		don't know the type but know it's AT MOST a Number
		that means we can write Number (pass as parameter)
			but we can't read values from it (return values)
Casting
	you can cast to T inside a generic as long as the thing being casted is a reference type
		it won't be autoboxed, but if you need to box, you can use something like Integer.valueOf()
	because T is determined by an outsider, you can't assume too much about it
		eg. if T extends Integer, you can't just return an Integer (but you can cast if you know it's ok)
Comparable<T>
	class MyClass implements Comparable<MyClass> {
		public int compareTo(MyClass o) {}
		// < 0 if this < o, > 0 if this > 0, 0 if =
	}
	this defines the "natural ordering" used by collections if no comparator passed in
	a way to do comparisons in generics without having to rely on a type or even Number
	the numeric boxed types implement this
Comparator<T>
	functional interface with compare(T o1, T o2) method
	also static methods like reverseOrder()
	also default methods like thenComparing() for chaining
		Collections.sort(people, Comparator.comparing(Person::getLastName)
                                           .thenComparing(Person::getFirstName));
Math Operators on Generic Types
	if T extends a specific type like Integer, operators like < may work
		probably internally calling intValue()
		Integer is 'final' though, so you can't subclass it to get operator overloading
	T extends Number does not make that work
Subclass as Type Arguments
	class MyClass implements Comparable<MyClass>
	<T extends Comparable<T>>
Static Methods
	treat as standalone methods (put <T> in front)
	call on unbound class (eg. MyClass.<Integer>create())
Nested Classes
	static = on unbound type (MyClass.MyChild) [acts like static method]
	other = on bound type (MyClass<Integer>.MyChild)
Variadic Generic Functions
	<T> void f(T... args) {}
		if you pass int[], T = int[] and has 1 element!
			because generics can't be int
		if you pass Integer[], T = Integer and has all the Elements

[Imports]
import java.util.List;	// only 1 per line allowed
import java.util.*;	// can import all things from a package
import static java.lang.Math.PI;	// importing a static variable into the file by name (state shared between all places that import)
import static java.lang.Math.Square;	// importing static method to be called unqualified by name (simulated top-level function)
import static java.lang.Math.*;	// importing all static members of class

portions of the path are both subfolders in the path (relative to the classpath java is invoked with) and also the package name
no renaming of symbols like in other languages

package com.example;	// to specify the package (which should match the path of the folder relative to classpath)
a package is a folder containing class files

you can have multiple top-level classes in a .java file, but:
	only one can be public
	the public one should have the same name as the .java file
		if no public one, can name file anything

only classes and enums (which act like classes) can be top-levels (not functions or variables)
	but can have effectively global stuff by making static and importing statically

you can use types without importing them (use as fully-qualified name)
	a way to deal with naming conflicts

[stdlib]
java.lang auto imported symbols

System.out.println(), System.out.print(), System.out.printf()
	println has overloads for a lot of types and Object (which uses toString)
	it also has an empty overload
		useful for: blank lines, going to next line after a print() or printf(), etc.
pass System.in to InputStreamReader and that to BufferedReader in try-resources (java.io.*)
	readLine() will start at current position (no newline), echo what is typed, and then go to next line
		returns String that keeps all spaces but not the newline that ended it
		ok to print() in between (won't get sucked back in)
	IOException thrown
	use Stream.of(str.split()).map(Integer::parseInt).collect(toList()) to get list of integers from user
console = System.console();  console.readLine("Enter a value: "); console.readPassword is same but without echo
System.out, System.in, System.err

System.gc()

Math.floor(), Math.abs(), Math.max(), Math.round(), Math.cos(radians), etc.
	Math.PI and Math.E constants
java.util.Random
	new Random().nextInt(100) or nextFloat(), etc.
	nextGaussian() for gaussian distribution, etc.
	ints(), longs(), etc. for infinite streams
java.math.BigInteger
	for numbers larger than long (eg. unsigned long since no unsigned)

File I/O
	many different ways
	Files.newBufferedReader(Paths.get("myfile.txt"))
	you can write directly, and read either one line at a time, one thing at a time, or via a stream
	new BufferedWriter(new FileWriter(path)) [and read equivs]
Paths
	java.nio.file.Path and java.nio.file.Paths
	Path path = Paths.get("C:/Users/John/Documents/file.txt");
	path.isRelative(), path.getParent(), etc.
Environment Variables
	System.getenv(), System.getProperty(), System.setProperty()

java.lang.Thread
	thread = new Thread(() -> {Thread.sleep(1000)})	// 1s
		takes a Runnable
	thread.start()
	thread.isAlive()
	thread.join()
		optional timeout in millis (if thread not dead, return as if nothing wrong)
			join = wait for thread to finish
		check thread.isAlive() if needed after
	Thread.sleep()
		duration in millis plus optionally nanos in addition

	alternatively, you could subclass Thread and override run()
		which will get called when you start() the thread
		the lambda version is more recommended now

	Thread.currentThread() gets current executing thread's instance
Interrupting threads
	each thread has an interrupted flag (thread.isInterrupted() or Thread.interrupted() for current thread)
	each thread also has thread.isAlive() which is separate from that
		when a thread completes or dies somehow, isAlive() goes to false
		can be both interrupted and alive at the same time
	thread.interrupt() sets the interrupted flag (but does not affect isAlive())
	calling a method like join(), sleep(), or get() in a thread that has interrupted flag will throw InterruptedException
		these have nothing to do with the thread you're joining, for instance
		if you join an interrupted thread that is still alive, it's fine
	usually, the child thread will detect its own interruption via the exception and/or flag
		then gracefully exit/stop working (die)
		you might choose to throw InterruptedException from the flag check and then consolidate the death code in a handler
	java.lang.InterruptedException is a checked exception
		you should catch it whenever block on a thread and do something like e.printStackTrace()

	you can join a dead thread as well - it will silently just return right away
		won't throw any InterruptedException or anything like that, for instance

	you can't throw any checked exceptions from the child thread that aren't declared in their interfaces
		but you can throw unchecked exceptions
		these will just kill the thread (making join() return immediately in another thread)
		the exception will not propagate to other threads

java.util.concurrent.CompletableFuture
	CompletableFuture<Integer> completableFuture = 
            CompletableFuture.supplyAsync(() -> 42);
				takes a Supplier<T>
	CompletableFuture<String> transformedFuture = 
            completableFuture.thenApply(result -> "The answer is: " + result);
	System.out.println(transformedFuture.get());
	java.util.concurrent.Future<T> and java.util.concurrent.CompletionStage<T> are the implemented interfaces
		Future<T> provides get(), isDone(), cancel(), isCancelled(), with and without timeouts
		CompletionStage<T> provides thenApply(), etc.
	get() throws 2 checked exceptions
		InterruptedException is for the main thread based on its own interrupted flag
		ExecutionException is if any unchecked exception was thrown from inside the future's body
			eg. you may choose to use CompletionException
	to cancel the future from the outside, you can call cancel(true)
		this will throw CancellationException on the call to get()
		it is an unchecked exception

no async/await keywords
synchronized keyword for critical sections (java.util.concurrent for more specialized lock types)
	mark a method as synchronized to use instance as lock object when method called
	mark a static method as synchronized to lock on the class itself
	synchonized(lockObject) {} // block to lock on arbitrary object (which can be 'this' if you want)
	reentrant - same thread can lock multiple times and it will be refcounted

	another example usage is to have lock objects created with Object() in a class
		then you can lock in small blocks within methods for fine-grained control
java.util.concurrent.lock.*
	more flexible than synchronized
		eg. multiple conditions per lock and more types of locks
	Lock interface
		lock(),unlock(),lockInterruptably()
		tryLock(), tryLock(50L, TimeUnit.MILLISECONDS) [booleans, immediate]
		newCondition() to get Condition instance
	Condition interface
		can have multiple per Lock
		do not need to lock to create, but do need to lock to signal or await them
		signal(), signalAll(), await()
			with or without timeouts as above
	ReadWriteLock interface
		separate lock for reading and writing
		unlimited people can hold read lock as long as nobody holds write lock
			write lock is exclusive of everything
	ReentrantLock and ReentrantReadWriteLock
		implementations for Lock and ReadWriteLock
Other Synchronizers
	Semaphore(n)
		acquire()
		release()
	CountDownLatch(n)
		countDown()
		await()
volatile
	keyword for instance variables (not local variables)
	instance variables can end up cached in registers, so multiple threads might de-sync on modification
	volatile tells Java not to do this, which can have a performance impact
	variables that are marked final (or are never modified after creation) don't need this as they won't de-sync
	local variables can't use this because local variables used in lambdas should be effectively final
	synchronized {} blocks automatically sync up memory and cache, so variables inside don't need to be volatile
		lock itself doesn't if it's treated as final
	other utilities like atomic numbers and such in java.util.concurrent also don't require variables to be volatile
		see documentation for guarantees
	volatile does not mean atomic
		for instance post-increment ++ still not atomic on a volatile int
	if an object reference is volatile, that only affects the reference variable (not the contents)
atomiticity
	all primitive numerics are atomic for read/write (but not stuff like ++)
	long and double used to not be but are now (for a very long time now)
wait()/notify()/notifyAll()
	Object methods (called on lock object)
	must be called from a critical section
	wait() puts thread in waiting state, releases lock, and waits to get notified and get lock back
	notify() takes 1 random thread out of waiting state, but it still has to wait for the lock
		then caller continues within its critical section
	notifyAll() release all from waiting state
	canonical usage is producer/consumer
		product() method fills a buffer and notifies
		consume() method waits and uses buffer
	these are considered old-fashioned (java.util.concurrent has better stuff)
		but still essential to know about
Guarded block
	while(!joy) {
            try {
                // Thread goes to sleep until signalled
                wait();
            } catch (InterruptedException e) {}
        }
	// instead of while (!joy) {} which wastes CPU
main thread ending will not stop threads and futures
	System.exit() to force kill everything immediately

Reactive Streams (not streams API)
	Publisher<T> is like observable from rxjs
		has a .subscribe(subscriber) method and that's it
	Subscriber<T> is passed into it and is an interface to handle the data
		onComplete(), onError(), onNext(), onSubscribe()
		gets a Subscription object in onSubscribe so that it can store and use it in the others
		no implementation - you're supposed to implement it (perhaps via anonymous class)
	Subscription
		passed into Subscriber<T> on subscribe
		request(n) to buffer more items
		cancel() to stop
	SubmissionPublisher<T>
		concrete Subscriber<T> with a lot more functionality and methods than just that
			probably need to store it instead of Publisher<T> reference
			asynchronous buffered data
		mainly submit() and close()

java.util.concurrent.Callable<V>
	like java.lang.Runnable but returns a value of type V

Executors
	interfaces for managing threads (executing tasks) in java.util.concurrent
	instead of using Thread directly, lets you separate the concerns of thread mgmt and business logic

	Executor
		execute(runnable)
			how and when runnable is called is up to the implementation
	ExecutorService (extends Executor)
		submit(runnable or callable)
			gives back a Future<T> or Future<?>
		shutdown()
			prevents new tasks being picked up and kills workers as tasks complete
		awaitTermination(timeout, duration)
			tries to wait for all workers to die with a timeout
			to be called after shutdown()
		shutdownNow()
			call if awaitTermination() doesn't work (at least one worker is taking too long)
			returns List<Runnable> of tasks that didn't finish
			uses interrupt() to tell threads to die
			you should make sure to at least do this by the end (eg. in a finally)
	ScheduledExecutorService (extends ExecutorService)
		periodic and/or delayed execution
		uses ScheduledFuture<T>
		for periodic, the value is meaningless (future is just for management)
			if you want to collect results, do it with a concurrent collection yourself
		schedule() is a bit like setTimeout() in JavaScript
Thread Pools
	implementations of Executors
	left side is executor interface, right side is a static call to java.util.concurrent.Executors
	newFixedThreadPool(n)
		n worker threads
	newCachedThreadPool()
		dynamically sized worker thread pool
	newSingleThreadExecutor()
		one single worker thread
	newScheduled*()
		scheduled versions of the above
Fork/Join Framework
	you use a special thread pool (both as interface and implementation)
		ForkJoinPool
	then you call invoke() on a subclass of ForkJoinTask<V>
		the result is a synchronous return value (if applicable)
	you generally will subclass either RecursiveTask<V> to return a value or RecursiveAction
		override the abstract compute() method
			it returns void for RecursiveAction (not a member of ForkJoinTask)
		provide base case(s) and return synchronous values for them
		for recursive cases, create more instances of the same type and call fork()
		then call join() to get the synchrnous results of those and aggregate them together
			unlike in normal threads or futures, this only throws unchecked exceptions
		in RecursiveAction, you can use invokeAll() to invoke a bunch of tasks synchronously
	instead of methods like join() throwing exceptions, you can kind of ignore it in the task
		unchecked exceptions will propagate up (rethrown) to the top level invoke()
		no InterruptedException here

Parallel Streams
	you can use a parallel stream (see Streams API way above) to do parallel computations too
		without having to worry about managing thread pools or tasks or anything
Thread-Local Random
	java.util.Random is already thread-safe
		but in tight loops, that makes it slower because threads have to wait on each other to get a random number
	this is usually not necessary as you just want random numbers
	so java.util.concurrent.ThreadLocalRandom.current() gives you a thread-local random number generator
		already created and seeded
CopyOnWriteArrayList and CopyOnWriteSet
	thread-safe List and Set that make new copy on all modification operations internally
	very expensive if doing a lot of writes (don't use in that case)
	iterators obtained before modification remain valid and use the old snapshot
TimeUnit
	java.util.concurrent.TimeUnit enum
	DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS
	represents a unit of time rather than a duration value
	used in a lot of java.util.concurrent utilities such as tryLock() as a unit of measure
		tryLock(long duration, TimeUnit unit)
	not used in the older things like thread.join() and Thread.sleep()
	convenience conversion methods
		eg. DAYS.convert(24, TimeUnit.HOURS) -> returns 1
		eg. HOURS.toDays(24) -> returns 1
	also some threading methods
		eg. SECONDS.sleep(10);	// sleep for 10 SECONDS using Thread.sleep
		eg. SECONDS.timedJoin(thread, 10); // thread.join with timeout
		eg. SECONDS.timedWait(lockObject, timeout); // object.wait()
java.time.Duration
	Duration.ofHours(24).plusDays(2).toMinutes()
	can be negative
	converting to less precision will truncate
System.nanoTime()
	if need to get timestamp before and after algorithm
	then subtract and convert as needed

[JUnit]
@Test test* methods in class
assertTrue() etc.
@BeforeEach, @AfterEach
mockito

[Docstrings]
    /**
     * This function calculates the sum of two integers.
     *
     * @param a The first integer.
     * @param b The second integer.
     * @return The sum of the two integers.
     */

put before method, class, or package declaration

[Annotations]
@interface DecoratorName {} // may need @Retention and @Target annotations on it
can then apply @DecoratorName before targets (such as methods)
retrievable via reflection on the annotated symbol (used by linters, compiler, etc.)
more syntax for adding params and defaults

java.lang has some useful built-in ones
	@Override
	@Deprecated
	@FunctionalInterface
	@SuppressWarnings("name")

[Records]
*not supported by ijava*
lets you define just what you need in a class and have a bunch of stuff auto-generated

record Person(int arg1, int arg2) {
	public Person {}
}

differs from class in following ways:
	record instead of class
	constructor args moved up to typename
	constructor has no args
	can put whatever you want in the class body
		the arg names at the top are PRIVATE instance variables
automatically generated: constructor, equals, hashCode, toString, getters of same name as params
no automatic copy constructor, but you can pass the private args as constructor args to make a copy

[Switch Expressions]
int m = switch (n) {
	case 1 -> 10; // semicolons here
	case 2 -> 20;
	default -> 30;
}; // need semicolon here

-> instead of : to get values for cases
then the result of the switch is a value
because it returns a value, it has to be EXHAUSTIVE (but can have default)

[Compact Numbers]
can put _ between digits in a numeric literal and they will be ignored (for visual convenience)

[Text Block Formatting]
a verbatim block can have .formatted() after to pass format args

[Pattern Matching instanceof]
enhancement to instanceof to allow casting at same time
if (obj instanceof String str) {
            System.out.println(str.length());
        }

[Sealed Classes]
a new thing to restrict which classes can sublcass a class
note that before this feature, 

[AutoValue]
google library with annotations to make value classes and builders
you provide an abstract class and it can fill in the data for you during the build phase

[Effective Java Tips]
** see the Effective Java notebook **
readable on phone

[Design Patterns]
** see the Design Patterns Java notebook **

[Interview Tips ***not from notebooks**]
if need to implement linked list, just do it from scratch
	trying to use built-in and then replacing it sounds cool, but causes problems
	by coding to the List<> interface, you end up coding against a lot of methods you won't need
	also causes weirdness with empty Lists
if in an environment where you can't change the imports, you can always use full-qualified symbols!
	but they may have use * with a bunch of stuff to give you a lot of things
don't be hesitant to make classes for tuples and stuff quickly
	copy and paste is your friend (unless on a whiteboard)
if you have to do I/O, consider testing the functions first using hardcoded data and prints
	depending on time and how much a part of the problem the I/O is
if you need a tree or graph, do it yourself (no java version)
	consider just making Node class a struct-like class with no methods
		then updates can be done inline in the algorithm
		depends on how much time you have and how central the abstraction is
compiler doesn't like constructors without <> operator (unchecked warning)
	it works but the type is erased and you lose type safety

Patterns
	struct-like wrapper for updating multiple variables in a helper
		record = f(record, blabla); // treat as immutable
			OR
		f(record, blabla);	// mutate the instance passed in
		basically simulating python tuple
	dealing with empty linked lists/graphs/trees
		usually easier to just use null
			but may need a static wrapper to avoid hardcoded copies of logic to set if null
	for operations like adding items one at a time, consider a wrapper class
		eg. keeps head and last pointers even if singly-linked list
	DFS = recursion or stack
	BFS = corecusion or queue
	to add funtionality to collection, extend class
		interface remains implemented for you
		don't implement interface unless you're prepareed to do the whole thing
		to add your own interface, just add your own as a mixin
	don't forget to subract '0' from char if it's a digit and doing math
	don't forget that % can be used to check if a number evenly divides another
		that should be obvious but I had a brain fart about it in a practice problem
		did some unnecessary float division with epsilon check
	use infinite lazy streams combined and with takeWhile() and such to make iteration less tedious
	generating all combinations of values of a data structure:
		take a version of the data structure in initial state
		take a parameter saying which thing to vary (eg. cell by row and column)
		call a recursive function that iterates the posisble values of the cell
			then calls itself with next cell
			define it such that the recursive calls will chain all the way to the last cell
	recursion into iteration (eg. if not enough stack)
		this will only work if it looks like TCO (single call)
		wrap recursive part in a while loop that terminates on base condition
		modify the variables at the end of each loop iteration to simulate TCO
		make sure the base case is handled properly (eg. after the while loop)
	backtracking
		problem solving approach where you try out solutions and then undo the last part if fails
		can be recursive but doesn't have to be
		eg. try out different placements of queen on chess board and undo placements that don't succeed
		there may be some element of pruning but it's not a synonym for it
		the "generating combinations" pattern above can be thought of as backtracking
			you back out a change that makes a digit too high and move to next cell, for instance

HackerRank-specific tips
	if you exceed the time limit, make sure you aren't updating the wrong variable or something
		sometimes you think it's because it's pick and you used n^2, but a lot of time it's a bug
		esp. if n is small
	since they hide the test data, you need to System.out.println() a lot to diagnose failures
		don't be too quite to delete these until you're absolutely done
	make pseudocode and clarifications in comments
		and make your prints look like the pseudocode so you can see if it's working
	there's a hidden area in between panes to scroll the whole window (eg. to get back to the code from looking at tests)
	beware of fake errors (slightly yellow/brown colored) due to thing not being used yet
	var doesn't work in Java 8 but does in 15 (don't get confused by things like that)
	watch out for holding down or repeated spaces causing erroneous . to be inserted
