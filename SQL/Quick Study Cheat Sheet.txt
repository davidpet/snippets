*************************************************************************************
This document represents items that jumped out at me as needing to be studied for SQL interviews at a point in time.
Since in the future, different items would jump out at me based on the experience I have between now and then, it is only an artifact of this moment in time.
Going forward, I should review the actual notebooks, but this is so I can study up quickly at first.

Also, since there are a lot of dialect-specific things and advanced topics only a DBA
probably needs, it is not a very complete cheat sheet, at least this time around.
*************************************************************************************

[Syntax]
statements end with ;
	some systems allow DELIMITER command to specify a new one temporarily
	this is useful for things like stored procedures
	just remember to DELIMITER ; when done
-- this is a comment for the rest of the line
/* this is a multiline comment */

identifiers, operators, etc. are not case sensitive but built-in stuff is usually capitalized
	equality in strings is case sensitive by default

[Data Types]
INT
FLOAT
DECIMAL(m, n): fixed length before and after decimal point
CHAR(n): fixed length string (null not counted)
VARCHAR(n): variable length string (up to max) (null not counted)
BIT: boolean (0 or 1)
DATE: set to a string that has a proper date format (eg. 2012-01-01)
DATETIME: same but with timestamp after space
JSON: json string with object data

CAST(column1 AS DATE)
	in some systems, CONVERT() instead
DATE '2012-02-02'
	called type constructor

[Strings]
strings usually single-quoted (double-quoted not always even supported)
other types of quoting like [] and `` are system-dependent
double up quotes to escape them
+ for concat
N prefix before quote for unicode
double quotes can also be used to make identifiers CASE SENSITIVE
	by default they are not

SUBSTR(column1, start, stop)

UPPER(col)
LOWER(col)

LENGTH(strcol)
CONCAT()
REPLACE()
TRIM()
REPEAT()
REVERSE()

[Nullability]
all data types can have the value NULL if not present
NULL can be specified in a column spec (eg. in CREATE TABLE)

WHERE column1 IS NULL
WHERE column1 IS NOT NULL

COALESCE(column1, 0)
IFNULL(column1, 0) = same thing as COALESCE

[Select Statement]
overall order of clauses: [SELECT [DISTINCT]] [FROM] [JOIN] [WHERE] [ORDER BY] [LIMIT] [OFFSET] [GROUP BY] [HAVING]
actual execution order is: [FROM] [JOIN] [WHERE] [GROUP BY] [HAVING] [SELECT] [DISTINCT] [ORDER BY] [LIMIT/OFFSET]
	part of SELECT comes before GROUP BY though
	this is evidenced by the fact that you can use column aliases in a GROUP BY
	but GROUP BY also makes aggregates

[SELECT] = for defining what columns will be present in result
	SELECT *
		all columns
	SELECT column1, SUM(column2) AS total_column2, column3 AS col3
		SUM() is an aggregate
		others are AVG(), MAX(), MIN(), etc.
		they mostly make sense in terms of statements involving a GROUP BY (though can work standalone)
		COUNT(*) to count # of rows
		COUNT(col) to count # of non-null column values
		
		COUNT(name) can also be used to turn a whole result set into 1 row aggregated
			if no GROUP BY and no other columns listed
			if other non-aggregate columns, that's an error
		COUNT(DISTINCT name) can deduplicate
		eg. SELECT COUNT(name) - COUNT(DISTINCT name) AS duplicates FROM MyTable;
	AS lets you alias the column names in the results
		they are not usable in the WHERE but are in the ORDER BY and GROUP BY

	SELECT name, age, CASE 
				WHEN age < 30 THEN 'No Bonus'
				WHEN age > 30 THEN 'Bonus'
				ELSE 'Some bonus'
			  END AS bonus

	SELECT UPPER(name), age * 10

	SELECT column1 as "The First Column"
		a way to have multiple words (case sensitive)

	SELECT DISTINCT column1, column2
		deduplicates whole result set rows
		note that strings are case sensitive in this context
[FROM] = specifying what table to use
	can alias table names here which applies in rest of statement
		eg. FROM employees AS e
		then you can use e as the tablename in all other parts of the statement
[JOIN] = joining with another table
	eg. FROM employees INNER JOIN department ON employees.department_id = departments.id
	can alias the columns from the tables in the SELECT statement
	can filter with WHERE clause (using the table names from the join)

	INNER JOIN = all combinations matching the ON
	LEFT JOIN = all rows from left, matched with right where applicable
		LEFT OUTER JOIN = synonymous
	RIGHT JOIN = all rows from right, matched with left where applicable
		RIGHT OUTER JOIN = synonymous
	FULL OUTER JOIN = all rows from both tables, matched when applicable
	CROSS JOIN = all combos of rows from both tables (no ON)
	
	self join = a term for using the same table as both sides of the join
	
[WHERE] = which rows to include (no aliases)
	eg. col1 = 25
	eg. col2 <> 25
	eg. col3 = 'hi'
	eg. age <= 30 AND salary > 5500
	eg. salary BETWEEN 5500 AND 6500
	eg. name LIKE '%mi%'
		each % is a wildcard'
	eg. salary IS NOT NULL

	can use table name inc. alias as prefix if needed
		but not column aliases in this part yet
	columns don't have to be explicitly mentioned (or even included) in the SELECT

	for json, use ->> operator to dereference column as a field from the JSON
		for inserting a new row, need to use a json string

	NOTE: you can leave off table name if not ambiguous
ORDER BY column ASC
	or DESC
	default is ASC

	ORDER BY column1 ASC, column2 DESC
		for 2 level ordering
LIMIT n
	only get first n rows
OFFSET n
	skip first n rows
GROUP BY column1, column2
	generally you select column1 and column2 in the SELECT
	then you can aggregate other columns with MAX, AVG, etc.
	each combo of column1 and column2 is a row
HAVING
	a condition on aggregates of groups (eg. SUM())
	the resulting filtration happens on whole groups from group by

subqueries grouped with () can be used for single values if aggregate
	WHERE EXISTS () if a subquery returns at least 1 row

Full Examples:
	SELECT * FROM Book; /* all rows, all columns */

	SELECT * FROM Book WHERE price > 100.00 ORDER BY title;

	SELECT col1 AS column1, col2 AS column2, SUM(col3) AS column3_sum FROM employees
		WHERE column1 > 10  ORDER BY column3_sum GROUP BY column1, column2;

	SELECT e.id, e.name, o.id AS orderId, o.product FROM employees AS e INNER JOIN orders AS o ON e.id = o.customer_id

[Union, Intersect, Except]
SELECT * FROM table1 INTERSECT SELECT * FROM table2;
	combines two WHOLE QUERIES (including the where, etc.)
	
INTERSECT = rows that are identical in results from both tables
UNION = deduplicated rows from results from either table
EXCEPT = result rows in first and not in 2nd

[Database Creation]
CREATE DATABASE mydatabase;
USE DATABASE mydatabase;
DROP DATABASE mydatabase;

[Table Creation]
-- can leave out the OR REPLACE
-- query involving Customers table still needs an ON with the 2 fields being compared with =
CREATE OR REPLACE TABLE employees (
    id INT PRIMARY KEY, -- primary key (automatically indexed as UNIQUE)
    name VARCHAR(50),
    age INT UNIQUE, -- putting UNIQUE here means the column is indexed as each row having unique value
    salary DECIMAL(10,2) NULL, -- nullable column
    customer_id INT, -- this will be used as foreign key
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id) -- link foreign key to other table's primary key
);

CREATE TABLE IF NOT EXISTS employees (...);

CREATE TABLE employees 2 AS SELECT * FROM employees; -- cloning a table

DESCRIBE employees;

[Table Deletion]
DROP TABLE employees;
DROP TABLE IF EXISTS employees;

[Inserting Rows]
INSERT INTO employees (id, name, age, salary)
VALUES (1, 'John Doe', 30, 5000.00),
       (2, 'Jane Smith', 25, NULL),
       (3, 'Mike Johnson', 35, 8000.00),
       (4, 'Sarah Williams', 40, NULL);

[Updating Rows]
UPDATE employees SET salary = 75000.00 WHERE id = 2;

[Deleting Rows]
DELETE FROM employees WHERE id = 1;

TRUNCATE TABLE employees; -- clearing

[Changing Table Spec]
ALTER TABLE, ALTER COLUMN, etc.

[Temporary Table]
CREATE TEMPORARY TABLE mytable AS SELECT * FROM employees;
	this table will die after this session ends
	you can also DROP TABLE it explicitly

[Normalization/Denormalization]
having a lot of smaller tables with foreign keys to avoid redundancy is known as Normalization
having a bigger table with rows that have a lot of duplicated fields (as if JOINed) and a few columns different is Denormalization
generally you have one or the other depending on the needs of the system
Denormalization is faster for larger queries while Normalization uses less space

[Indexing]
primary key automatically indexed as unique
can also specify unique index in the CREATE TABLE as above
attempting to insert a redundant value is an ERROR

you can also index retroactively:
CREATE INDEX idx_name ON employees (name); -- not unique
CREATE UNIQUE INDEX idx_id ON employees (id);
CREATE INDEX idx_age_salary ON employees (age, salary); -- combination of columns indexed
CREATE UNIQUE INDEX idx_name_age ON employees (name, age);

you are indexing the existing columns but you have an index name that you can DROP INDEX on later for instance

indices are transparent to the queryer
	they have a performance hit on inserting new items but make queries faster
	excessive indexing will use extra storage and slow down insert/update/delete operations

[Foreign Keys]
since you still have to do an ON statement, foreign keys don't appear to do much on the surface
they have some less obvious benefits:
	prevent inserting row with invalid foreign key
	some systems automatically delete obsolete rows of the foreign table when delete rows of the parent table

[Views]
A view acts like a table for querying and lives in the DB, but it is just a query that gets executed when needed
	this makes it dynamically responsive to changes in the tables it queries against

CREATE OR REPLACE VIEW myview AS SELECT * FROM employees WHERE age < 30;
	the part after AS becomes what's stored in the DB as the query to execute dynamically
DROP VIEW IF EXISTS myview;
	delete the view
SELECT * FROM myview;
	query just like any table

[Built-in Functions]
** many others mentioned in [Strings] section **
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
EXTRACT(YEAR FROM col)

[User-Defined Functions and Stored Procedures]
user-defined functions are stored in the DB to return a value
stored procedures are stored in the DB to execute actions (eg. maintenance)
syntax of both is rather ugly - not included here because can't run in Jupiter
you can also have triggers and transactions (w/ commit and rollback)

[ACID]
** the syntax here is hypothetical as JupySQL doesn't allow any of it **

Atomicity = transactions
Consistency = schema constraints
Isolation = transactions
Durability = once transaction over, the result is permanent

BEGIN TRANSACTION;

-- do multiple reads and updates

IF ERRORS <> 0 ROLLBACK; -- end transaction with nothing changed
IF ERRORS = 0 COMMIT;  -- end transaction with everything atomically committed

up to the DB system and config what granularity of timestamps, locking, etc. used
	and what kind of consistency, parallelism, etc. is desired
	eg. could lock rows, or whole tables, etc.

sidenote: languages like Clojure can do OCC with help of CAS (compare and swap)

APIs for programming languages often have their own transaction calls instead of having to do it in SQL

[APIs]
think of entity framework
an entity's type determines what table it belongs in already (because a table is a list of entities of a type)
you create an instance of the entity and save it (eg. with session object that is connected to DB)
session can also start and commit/rollback transactions
a session can have a query method to take a SQL query and give back, for instance, a list of entities
	in Java you need to pass a class object to let it know what kind of object to create from it
remember to rollback transaction if an exception is thrown

Java = Hibernate
C# = Entity framework
Python = SQLAlchemy

[Security of Connection String]
if stored locally, must be encrypted
have to think about how to store the decryption key though
external solutions from Google and AWS can help make it more secure
easier to make secure on a web app than on a desktop app (because can choose what's exposed to clients)
