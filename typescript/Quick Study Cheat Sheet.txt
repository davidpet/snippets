** rewrite of this sheet is in progress **
** steps:
** 1. go through notebooks again in detail and merge into what's here (mostly replace, but make sure nothing missed)
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (since JS/TS has some in common with python note in common with Java)
** 4. also include: pure JS, HTML, CSS/SASS, Dom, Angular, React
** 5. any other popular libraries
** 6. include info on latest versions (and mark current version here)

[Variables]
boolean (true/false)
number (both float and integer)
  all the usual literals (inc. exponential, hex, etc.)
  built-in symbols for dealing with floating point:
    NaN
    Infinity
    -Infinity
    isNan()
    isFinite()
string (lowercase)
bigint (if need more than 54-bit integers)
  trailing n literal (eg. 'const x = 10n;`)

let x: number = 5; // mutable
const x: number = 5; // immutable
let x = 5; // type inference (the variable is typed, but it was inferred at compile-time)

let point: {x: number, y: number} = {x: 10, y: 20}; // custom object
let obj: object = {x: 10, y: 20}; // works because all objects inherit object
let point: {x: number, y: number} = {x, y}; // Shorthand Property Names
  x and y are used as both the keys and the variables to get the values from
  if the variables were called something else, you'd still have to say x: somethingElse and y: somethingElseElse

let a: any = 5;
  a could be any type
  often used for compatibility with JavaScript code where anything goes
  a could be reassigned a different type of object arbitrarily
  you can do whatever operations you want on it, like you're in JavaScript land
let a: unknown = 5;
  similar to any, but you can't do any operations on it that are type-specific
  you have to convert to a type first (eg. via type narrowing)
  otherwise, it's similar to using object directly

let n: null = null; // the type of null is null
let u: undefined = undefined; // the type of undefined is undefined

let n: never = f(); // the function is not expected to return (eg. because always throws)

let x: number | string;   // type unions
  can at any time assign a number or string (and back and forth) to the variable
let x: number | null;   // nullable type via union
let x: number | undefined;

static variables only exist as class members (no local statics)

scoped like Java, not Python
  block-scoped, not function-scoped

primitives are mutable variables (while the objects themselves are immutable)
  as in most languages
the primitive types (from JS) are: string (!!!), boolean, number, undefined, null, symbol, bigint
  they are true value types and don't have any methods to call themselves
  when you do something like 5.toString(), that is an error because it tries to call it on the primitive
JS has boxed types String and Number, for instance, but it's a little different from boxing in Java
  if you do 'const x = 5' and then 'x.toString()', JS will autobox and call the method inline!
  in general, you should never have to use the boxed types directly (and it is very uncommon to do so)

objects are mutable reference types (as in most languages)
  let obj1 = {x: 10, y: 20};
  let obj2: {x: number, y: number} = obj;
  obj2.x = 100;  // this changes obj1 (a reference, not a copy)
structural typing does not imply copying - just matching
strings are immutable like in Java, C#, etc.
  but they are not reference types!
collections, including arrays, are mutable reference types

Nullability
  let x: number;    // no value specified
    x is actually undefined, even though we didn't say it could be undefined with a type union!
  let x: number|undefined;  // same thing, but other code will be able to tell it could be undefined better
  let x: number|null = null;  // explicit nullability specification
  if (x === null || x === undefined) {...}
  note that both null and undefined are real valeus from JavaScript and === will work even if the type is wrong

Type Alias
    type Person = {
      name: string;
      age: number;
      email: string;
    };

    type BetterPerson = Person;

    const x: BetterPerson = {name: "bob", age: 20, email: "bob@bob.com"};

Enums
  regular enums and string enums
    eg. can just give values with no = to auto-assign like in other c-like languages
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
  let playerDirection: Direction = Direction.Up;

Interning
  only applies to strings, not numbers or anything else
  if you create a String() instead of string(), === will do reference comparison
    and be false even for same literal string
  otherwise, === will be true because of the shared pool of strings
    you don't usually need to worry about that

JS vs. TS Types
  most of the types discussed here and in Collections come from JS
  but the following are added by TS:
    enums
    tuples (which is really just an array with mixed types)
    any
    unknown
    never
    void
  also, generics don't exist in JS
    Map is a container that can take objects of any type and doesn't enforce they match
      like using raw type in Java
    TS adds generics functionality to provide safety when you develop and compile your code

[Collections]
Literals
  only array and object have literals ([] and {})

Arrays
  let a: number[] = [1, 2, 3, 4, 5];
  let a: Array<number> = [1, 2, 3, 4, 5];

  a[0] // read-write
  a.length

  a.push(val) // append to end
  val = a.pop() // remove from end [treat like stack]

  b = a.slice(start, stop); // inclusive start, exclusive stop
    b is a COPY of a range of a

  array is iterable via 'for...of' (and normal for loop w/ length) construct
  can also use a.forEach((num) => {})

  const a = [...firstList, ...secondList]; // spread operator (in-place)

  const [first, second, ...rest] = a; // destructuring
    rest is another array here
    use _, __, etc. for don't care values
      const [first, _, ...rest] = a; // ignoring 2nd value

  a.filter() and a.map()
    both return an array, not some lazy stream like Python
  
  [][] for multidimensional arrays
    nested [] just as you'd expect

Tuples
  similar to array, but fixed length and not homogeneous type
  let tuple: [number, string, boolean] = [10, 'hi', true];
      tuple[0] (read-write)
        not immutable like in Python
  tuple.length
  can destructure just like an array
    const [a, b, c] = tuple;
  can use 'for...of' like with arrays

Sets
  let s: Set<number> = new Set([1, 2, 3, 4, 5]);
      add(), has(), delete(), size()
  const s = new Set<number>();

  s.add(value);
  s.size // not a function for some reason
  s.has(value)
  s.delete(value)
  s.forEach((value) => {console.log(value);});
  s.forEach((value, index) => {}) // JS knows based on the lambda passed in
  use 'for...of' construct like with arrays

Maps
  let m: Map<string, number> = new Map([
      ["a", 10,],
      ["b", 20,],
  ])
  const m2 = new Map<string, number>();

  m.set(key, value)
  m.get(key)
    m.get(key) || defaultValue
    note that you CANNOT do m[key] (even though you can for objects)
  m.has(key)
  m.delete(key)
  m.size()  // # of keys
  m.clear()

  for (const [key, value] of m) {
    console.log(key);
    console.log(value);
  }
  also can use m.keys(), m.values(), m.entries()

Objects (as structs)
  let o: {a: number, b: string} = {a: 10, b: 'hi'};

  type Entry = { // note similarity to C struct syntax (plus =)
    a: number;
    b: string;
  };
  let o: Entry = {a: 10, b: 'hi'};

  interface Entry {
    a: number;
    b: string;
  }
  let o: Entry = {a: 10, b: 'hi'};  // equivalent to the 'type' version

  let o = {a: 1, b: 2, c: 3}; // we will ignore c
  let {a, b} = o;  // destructure into variables called a and b with those values from the object
  let {a: x, b: y} = o; // renaming the variables to x and y locally

  keys can be quoted or unquoted (or not even strings at all)
    const obj = {a: 1, "b": 2, true: false, 1: "One",};
    obj.a, obj.b, obj.true (actually a string key), no way to do obj.1
    to access an object field using a string (or other type of thing) as the key:
      obj["a"], obj["b"], obj["true"], obj[1] (not a string)
    unquoted string keys in an object may be subject to minification (and their usages as well)
      the minifier may be smart enough to not minify it (but maybe you want it to)
    even class variables can have quotes around them, but that's weird
  
  Object.keys(o), Object.values(o), Object.entries(o)
    to iterate over fields in an object as if a map

  Copying Objects
    spread operator
    let m = {...n, x: 20}; // x will replace the value of n.x if present (or add as new)
    // m and n are separate, not linked together

Objects (as classes)
  'class' instead of 'interface' and can have constructor, methods, etc.
  created with 'new' instead of structurally like with structs
  covered in detail in "Classes" section below

Readonly
  let a: ReadonlyArray<number> = [1, 2, 3, 4, 5];
    also ReadonlyMap, etc.
  not truly readonly, just enforces the usage (like C++ const)

[Strings]
strings are immutable (mutation functions return new copy)
  but they are not reference types like in other languages!
there is no char type - a character in a string is a single-item string (same type)
strings are based on unicode and are not null-terminated

s + t + 3
  concatenates two strings and a number (converted to string)

'' and "" are both for string (char is just a single character string, not special thing)
`Hello, {name}!` // 'name' should be variable in current scope
  backtick quote
  variable can be a number too!
  the thing in {} can also be a TS expression instead of just a name!
`` is a multiline string (backtick quote)
  if you don't have a newline it will just be single line, but you can have newlines in it
    no need to escape the newlines
to use a normal string with an object of params, you have to do it yourself using string.replace()
  there is no built-in way, but many frameworks have it
there are no raw strings

s.length
s[0], s.charAt() // read-only
  these are single-character strings!
  there is no char type
s.substring(start, stop) and s.slice(start, stop) // equivalent, just like array slicing
s.toUpperCase(), so.toLowerCase()
s.split(delim) gets a string[]
  can convert s to string[] of single-character strings:
    s.split('') // empty-string
s.replace(old, new)
  old can be a string or a regex pattern
s.includes(substr)
s.startsWith(substr)
s.endsWith(substr)

for...of iterates over characters (single-length strings)

Conversions
  s = n.toFixed(2) // format a number as a fixed-point decimal string
  parseInt() and parseFloat() to get numbers from strings
  +s // number to string via unary plus operator
  JSON.stringify() to make object into json string
  JSON.parse() to make json string into object
  n.toString() to get string from number
  o.toString() to get string from object (as it defines for itself)
    arrays do not have this
    set and map do not implement it properly

Base64
  btoa(original)
    gives a base64 encoded string
  atob(encoded)
    gives back original string from base64 encoding

console.log()
  console.log(a, b) logs both with space in between
  eg. console.log("field:", value);
  console.log(o) works on objects (will show keys-values) and built-in types
    much better than toString() and such
  output goes into debug console (eg. Chrome Devtools)
  console.log() for empty line
    can also use \n in strings
console.error()
  like console.log() but more serious (shows up red)
console.warn()
  less series than console.error()
console.info()
  similar to console.log()
there are color escape codes available too

Regular Expressions
  const pattern = /\d+/g
    makes a regular expression object directly using perl-like syntax
    no need for raw strings because already raw (unquoted)
    the // quotes it, but global flag comes after /
  pattern.test(text)
    true if a match anywhere in text
  matches = text.match(pattern)
    if you use /g flag, gets multiple matches as array of strings
    if you don't use /g flag, gets tuple with info about 1 match
  text.replace(pattern, replacement)
    replace all occurences of pattern with replacement
    can use $1, etc. for capture groups

[Operators]
all the usual arithmetic, arithmetic assignment, bitwise, and comparison operators from c-like language
  and ternary operator
  and pre and post increment/decrement
&&, ||, ! for conditions

type narrowing (a unique feature of TS)
  if (typeof x === "string") {
    let y: string = x;  // legal because x is type string in this scope
  }
  if (x !== null) {
    // in here, you can treat x as not nullable
  }

== for a number or string will try to coerce one to match the other (eg. number to string) before comparison
  it comes from JavaScript and causes a lot of bugs
=== (also from JavaScript) does not do this coercion
  thus, it is called strict equality
  it is mostly (and often mandatorily) recommended instead of == in TypeScript
both == and === will check value equality for numbers and strings
both == and === will check reference equality (not value) for reference types like objects and arrays
=== works correctly with null or undefined (and similar) as well
  you are permitted to do the === check even if the type says it can't be null or undefined
!= and !=== correspond to == and ===
for value equality in a custom object, you have to implement .equals() for the class
arrays don't have .equals(), but you can use JSON.stringify(arr) === JSON.stringify(otherArr)

Casting/Coercion
  x as OtherType // compiler will keep you honest
    will only do things like any to a specific type or polymorhpic stuff
    wil not do things like string to number
    for things the compiler can't see are wrong, you may get unexpected behavior
      eg. let s: string = "hi";
          let o: any = s;
          let b: boolean = o as boolean;
          console.log(b);
          // you expect it to print a boolean, but it prints a string
      this is because 'as' is a pure TypeScript compiler feature
        it is removed entirely in the emitted JavaScript code
  let y: number = +s; // coercion to number via unary + operator
    eg. string to number
    will throw exception if bad format
  n.toString()
    but 10.toString() not allowed because of parsing issues
  
?? nullish coalescing
  x ?? "hi"
    will be x unless x is null or undefined, then it will be "hi"
  note a general truthiness check - just null|undefined check

! non-null assertion
  let x: number = nullableNumber!;
    TS doesn't actually do anything at runtime here (including throwing anything)
    you are just telling the compiler to trust you that the thing cannot be nullable here anymore
    you could very easily be wrong and have null at runtime when the compiler thinks you can't (be careful!)
      could end up causing other bugs and throwing other kinds of errors at runtime

? safe-navigation operator (also called optional chaining, or Elvis operator)
  a?.b?.c?.d
  if any link in the chain is nullish (null|undefined), stops and returns that

typeof x
  gets a string representing the primitive type of an object (in JS)
  note it's not a function call (no parenth)
    eg. typeof x === "string"
  because it's so primitive, it doesn't work for polymorphism in class hierachy
    all reference types are seen as 'object', including arrays
    even null is 'object' (but 'undefined' is 'undefined')
  number, boolean, and string work as you'd expect (it's very useful for these specific types)

x instanceof MyClass
  boolean check of whether the class is in the inheritance chain of x
  it works because JavaScript uses prototype inheritance, so JS will check the prototype chain for the class object
  but it won't detect structural typing, so be very careful relying on this!

"fn" in y
  membership check
  if y is an object, this will check if it has a method or variable called 'fn'
  may be defeated by minification

Truthiness
  !! and ! are opposites
    !! makes value into boolean based on truthiness, ! does same but negates it
  falsey: null, undefined, 0, "", NaN, false
  truthy: empty collections, empty arrays, empty objects, anything else
  boolean operators like && and || return actual values (not boolean conversion)
    they evaluate the conditions in terms of truthiness (as with !! and !)
    and then do short-circuiting based on that
    then the last value seen is the one returned (the original value, not the boolean)
  you can use || as a truthiness coalescing operator
  statements like if() do an impliict truthiness conversion too
    for instance, you can do if (myIntValue && myStringValue)
    but your linter and coding conventions may wish you to use !! to be more explicit

Spread Operator
  const a = [1, 2, 3];
  const b = [...a, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

semicolons are technically optional
  JS people don't like them
  TS people like them
  leaving it out can actually ruin the parsing of some multi-line statements

[] operator for indexing
  available on arrays and objects, but not for getting keys/values in a map

[Control Flow]
'if/else if/else', 'while', 'do/while', and 'switch' work exactly like other c-like languages
'break' and 'continue' as well

'for' loops have these forms
  for (let i = 0; i < 10; i++) {} // typical C-style
  for (const item of arr) {} // like Java range-for but 'of' instead of :
  for (const index in arr) {} // not recommended because unexpected behavior

  for (const [keyOrIndex, value] of collection) {}
    works for a lot of collections (eg. map, array)
    also, can call .keys(), .values(), .entries() members to iterate over those specific things
    for objects, use Object.keys(obj), Object.values(obj), and Object.entries(obj)

  for await (const item of asyncCollection) {}
    for asynchronous items (wait for 1 at a time)
    eg. promises

try {
  throw new Error("Uh oh!");
}
catch (error) {
  // use instanceof operator to check type of exception
}
finally {}

Not Available: context management, asserts (have to use libraries)

[Functions]
types look a lot like python type annotations (but compiler actually cares)
unlike in C/C++/Java/etc., you have to put 'function' in front if not a class method
  this is similar to having to use 'def' in Python
unlike in Python, you can't arbitrarily reassign a function to a different lambda or something
  functions are not just treated as variables
  HOWEVER, in pure JS you could do that (TS compiler is the one preventing it)

function add(x: number, y: number): number {
    return x + y;
}

Optional Params
  function greet(name?: string): void {
    if (name) {
      console.log(`Hello, ${name}!`);
    } else { // name is undefined
      console.log("Hello, stranger!");
    }
  }

  greet(); // Output: Hello, stranger!
  greet("John"); // Output: Hello, John!

Default Params
  function power(base: number, exponent: number = 2): number {
    return Math.pow(base, exponent);
  }

Named Params
  not a first-class language feature, but you can do it with objects

  function greet({ name, age }: { name: string; age: number }): void {
    console.log(`Hello, ${name}! You are ${age} years old.`);
  }
  greet({ name: "John", age: 30 }); // Output: Hello, John! You are 30 years old.

Rest Params
  function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

  function processOptions(options: { [key: string]: any }): void {
    // use options as an iterable object with keys and values
    // key is not a variable - it is telling it how to interpret the options object
    // this makes use of index signatures
  }
  processOptions({a: 1, b: 2});
  // could use ...options to process multiple objects

Overloading
  doesn't work because of redefinition of symbols
  the usual way is to use type unions w/ instanceof, optional params, etc.
  there is a way to declare your intent to have overloads to the compiler, intellisense, etc.
    function f(a: number, b: number);
    function f(a: number, b: string);
    function f(a: number, b: number|string) {// implementation goes here}
    // similarly b could be optional if you had f(a: number) in the list

Generators
  function* lazyList(limit: number): IterableIterator<number> {
      let i = 0;
      while (i < limit) {
        yield i++;
      }
    }
  const l = lazyList(5);
  console.log(l.next().value);
    OR for (const item of l) {console.log(item);}
    OR const a = Array.from(l) // to make into eager array
  can send values into the .next() call just like python for two-way communication

nested functions allowed but uncommon due to multiline lambdas
    unlike Python

return type can be ommited to let it be inferred
    eg. void, esp. private method
    general rule: maybe ommit if can be easily inferred
      but include by default, except for private methods

never is a special return type that means the function never returns
  eg. if the body throws

[Functional]
"fat arrows" with all the usual combos
  multiline body, implicit return, type inference on args, etc.
  you can't leave out the () though

const addNumbers = (a: number, b: number): number => a + b;
let greetFunc: (name: string) => void;
let run: () => void;
const run = () => console.log('hi');  // void statements allowed on void returns
const fns: (() => void)[] = []; // list of lambdas

function expressions: like lambdas (and assignable to varaibles like lambdas)
  looks like defining a function but without the name

  const fn = function (x: number, y: number): number {
    return x + y;
  }

  completely interchangeable with lambdas and functions just like lambdas are
  subtle difference = handling of 'this'

to return an object from a lambda with {} and no body, you have to wrap it in extra ()
  because it will think the {} is a method body
  eg. (a, b) => ({x: a, y: b})

IIFE:
   (() => {
    console.log("lambda call!");
  })();

variables with function types can be assigned lambdas or normal functions
  then you can call the variable just like it was a normal function
but you cannot rebind a normal function to a different function or a lambda in TS
  in JS you can
  in TS, you can think of it like it's a "const" variable (though it's not exactly the same)
  also in JS, people like to use lambdas assigned to constants instead of using 'function'
    less popular in TS
functions (inc. top-level, lambdas, methods, and function expressions) are reference type
  they even have methods

closures usually are by reference (even for primitives)
  but loop variables are an exception (eg. for loop iteration variable)
  to make a value close by value instead of reference, you need to make it a parameter of a function
    in other words, lexically capture it
    eg. a nested function, an IIFE lambda around the lambda, etc.
  this is similar to Python except for the part about loop variables

you can use _, __, ___, etc. as "don't care" values for lambdas, destructuring, etc.
  technically those are actual names (valid identifiers)
  but by convention they are d.c. values

this
  the 'this' keyword is not as straightforward as other languages
    it has a lot of JS weirdness that TS is stuck with
    not just for use in classes (normal functions have it too)
  
  in a top-level function that is not lambda or function expression, 'this' is either:
    the global object (eg. window in a browser) by default
    undefined if in strict mode
  in a lambda (with arrow), it is captured from surrounding scope
    eg. if in a class, it is the class instance
    eg. if in a top-level function, it is whatever it is there
  in a function expression, it depends on the context
  in a method of a class, 'this' is the instance
    and you're required to use 'this' to access members (similar to 'self' in Python)
      but don't include in method signature

  you can call the bind() method on a function object to explicitly bind 'this' to something
    eg. to treat a free function as a method of a class when called
    see Partial Application for more details

Partial Application
  // just binding 'this'
  function f() { console.log(this); }
  const g = f.bind([1, 2, 3]);

  f();  // prints global object or undefined
  g();  // prints [1, 2, 3]

  // binding 'this' and some args
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  const g = f.bind(this, 10, 20);
  g(30);  // prints global object and returns 60

Applying Arguments from Iterable
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  
  f.apply(this, [10, 20, 30]); // prints global object and returns 60
  f(...arr) where arr = [10, 20, 30] would also work
    using spread operator to expand args
    when you don't need to bind 'this'

Applying Arguments Positionally
  f.call(this, 10, 20, 30);
  this is similar to bind() except it's actually calling
  a convenient way to bind 'this' without having to make a variable for the result

map, reduce, filter
  map, reduce, and filter are array methods that return new arrays
  note that reduce signature looks like arr.reduce(fn, seed) [weird order]

[Classes]
looks mostly like Java with some differences noted here
also worth noting that a class is syntactic sugar for making an object (as described in collections)
  just with function variables for methods and prototype for inheritance

things in common with Java worth noting here again:
  all methods are virtual with no need to specify overriding
  inheritance works the same way (on the surface)
  use 'new' keyword to make a new instance
  default constructor w/ no args only if no construtor specified
  can only extend a class but implement multiple interfaces (no python/c++ diamond behavior)

need to use 'this' in front of all member access from methods (never implicit)
  but also not passed in as param like in python
members are 'public' by default because that's how JS works (where there is no access level)
  no such thing as package-private like Java: just public, private, protected
methods do not have 'function' keyword, which makes them look more Java-like and less JS-like
member variables are declared in the body like Java (not in the c'tor like Python)
  but there is a special construct called Parameter Properties covered below that can act that way
unlike within code statements, variable declarations in classes don't use 'const' or 'let'
  act as 'let' by default
  can be made to act as 'const' with the 'readonly' qualifier
static variables and methods allowed
  accesed by ClassName.member
no destructors/finalizers

instead of being named for the class, the constructor is called 'constructor' and there can only be one

Properties
  put 'get' in front of a method to make it a readable property
  put 'set' in front of a void method to make it a writeable property
  if a 'get' and 'set' method have the same name, they are the same property
    usually impossible since no overloading
  you can independently control access to the getter and setter
  you can access a property from an instance as if it was a variable

Parameter Properties
  a constructor parameter with an access specifier in front
  automatically makes the parameter into a member variable of the class (without having to decalre it in the body)
  eg. used to inject services in Angular
  JS implements this by doing this.x = x in the c'tor (for example)
    TS won't let you do that directly because that violates the type safety of classes

Adding Fields Dynamically to Classes at runtime
  eg. m.x = 10 when x is not a member of the class
  this is ILLEGAL in TS because if violates type safety
  but it is LEGAL in JS (just like python) and is used by parameter properties

Syntax Example
  class MyClass {
    x: number;
    private y: number;
    protected z = 20; // type inferred
    static a: number = 100;

    private readonly myConstant = "Hello";

    constructor(name: string, age: number, private readonly service: Service) {
    }

    getSpecies(): void {
    }
  }

  class MyDerivedClass extends MyClass implements SomeInterface1, SomeInterface2 {
    getSpecies(): void {
      // overrides without having to say so
    }

    // etc. etc.
  }

  const m = new MyClass("Bob", 20, myService);

Nullability of Members
  name?: string;  // shorthand for string | undefined
  name: string | null;
  name!: string;  // supposed to be populated by the end of the c'tor
    treated as non-nullable throughout the class (trusting that you will fill it before it's used)

Construction Order
  inline variable initializers run like normal code (not compile-time constants)
  they can reference each other (still have to use 'this')
  can call instance methods, etc.
  presumably should only reference variables declared higher in the list? (but fns don't matter)

  super() calls the superclass constructor
    you are required to do it explicitly if you have a c'tor in a base class
    but it doesn't have to go first
    this has some weird caveats to know about
      base fields aren't available until after super() is called beause that's when it really creates the base
      you also can't use 'this' until after super() is called for similar reasons
    the compiler enforces all this for you

Prototype Inheritance
  because inheritance is impelmented in the JS layer using prototypes, that is the basis for inheritance behavior in TS
  this has some key differences from inheritance in languages like C++ and Java (and similarities to Python):
    variable names are virtual too, not just method names
    private variables of the same name in a derived class are forbidden
      this is because when it makes the JS equivalent, it will name clash, making it not private after all
  only 1 thing of each name because it's like a dictionary (no overloading)

ABC
  can only be inherited by abstract classes unless all abstract methods are overriden
  cannot instantiate with 'new'

  abstract class MyClass {
    abstract f(): void;
  }

  abstract class MyOtherClass implements MyInterface {} // interface introduces abstract methods into the class

Interfaces
  unlike Java, can have both fields and methods
  worth noting: unlike a class, which emits JS code, interfaces don't emit any JS code and aren't a JS feature
    it just helps the compiler to keep you honest before compiling to JS
  
  interface Person {
    name: string;
    age: number;

    greet(): void;  // abstract method
  }

  can be used like a base class in polymorphism just like other languages

  private members are not allowed

  Partial<Person> gets an interface that looks like Person but all fields are optional
    like adding ? to all fields that don't have it yet

Class as Interface
  unique feature
  you can pretend a concrete class is an interface and pass it as 'implements'
  all the implementation gets sucked out and only the prototypes are used (abstract)
  classes with private members cannot be used this way

Nested Classes
  a class can't be defined in another class like in other languages
  but it can be defined in a function body, so that's a potential workaround

Structural Typing
  very idiomatic TS concept
  adds some order to the chaos of JS duck-typing
  objects that are structurally compatible with other objects can be detected by the compiler
    but they cannot be detected easily at runtime
      eg. instanceof is useless for this
    to actually do it, you'd have to manually check all the properties
  the basic idea is if the interface of the object you pass in looks like the interface expected,
    then the compiler will let it through
    eg. even if the function expects a class and you pass a custom object without using new or the real class
    the compiler enforces that the structure is right, but you are free to shoot yourself in the foot
  optional fields expected on the left side of the = can be ommited or supplied on the right side
  optional fields expected on the right side of the = must not be required on the left side
  order of members does not matter in structural typing, only names and types
  if you use structural typing with a class, it's treated like an interfaces
    you're basically making an object with the right interface but missing the prototype chain
      it will not behave properly with polymorphic constructs

Object
  all reference types implicitly inherit from Object (and not primitives)
  you can do new Object() for an opaque object

  members commonly overriden:
    toString() and toLocaleString()
    valueOf()
      return a primitive value for operations like arithmetic
      default implementation just returns the reference itself
    equals()
      not used by maps and sets (=== instead)
  
  no hashing
    objects are not hashed the way they are in other languages for use in maps and sets
    the object's reference is treated as the key, and it is unique per instance
    there is no way to treat it as a value like you could in Java
    primitives are hashed as you'd expect them to be

  other methods:
    hasOwnProperty() can tell if a property lives on this object instead of a superclass

  even when you use an interface or structural typing, it is understood all objects have Object members
    and they do not in any way interfere or participate in structural typing checks

Adding Properties to Objects
  const m = MyClass();
  m.x = 10; // ILLEGAL if x is not a member of MyClass (unless pure JS)

  function f() {}
  f.x = 10; // LEGAL (to support decorators?)

Expandable Object
  relies on index signature feature

  interface MyObject {
    [key: string]: any;
  }
  const myObject: MyObject = {};
  myObject.field1 = "hi";
  console.log(myObject.field);
  console.log(myObject['field1']);

Not supported: operator overloading, partial classes
  though index signatures appear on the surface to be operator overloading

override keyword:
  newer addition to TypeScript
  usually optional to use, but Angular turns on the compiler option to make it mandatory by default
  eg. override f(): void {}
  only for overriding base class methods (not implementing interface methods)

Index Signatures
  pure JS allows you to use m.x and m['x'] to add arbitrary variables to any reference object
    arrays are special in that a[1] and a.toString and a['toString'] internally all use the same [] operator
    maps technically have [] but it is only the one from Object (doesn't participate in the key-value pairs of the map construct)
  TS prevents m.x from working if x is not defined on the class, for type safety
    m['x'] may still work, depending on compiler settings (possible to make it fail compiler based on the string inside)
    when the check is not enabled, m['x'] would return undefined if not there
  index signatures are a way to turn some of the JS flexibility back on from within TS
    it is a pure compile-time feature that just affects what you're allowed to do with regard to the above
    an index signature is defined on an interface or class to specify what kinds of types can be keys and values for []
      implicitly understood that m.x is m['x'] in this case
      eg. [index: string]: string; // m.x = 'hi' allowed, m.x = 100 disallowed
      eg. [index: string]: string|number; // type unions allowed
      eg. [index: string|number]: string|number;
    an index signature never has "implementation" because it's just to guard uses of the object
    you could use 'any' as a type to make it fully JS-like
    you can use 'readonly' before the indexer to make it not allow assignment
    other variables defined in the class, subclasses, or superclasses, will only be checked if the key type matches
      eg. [index: number] will not complain about a member x: string
      otherwise, the variables will cause compile error if the left side matches but right side does not
    in structural typing, it is more strict
      any properties passed in must pass the indexer check regardless of whether the left type matches
    members of Object are not checked against indexers because they're fundamental to the language

Anonymous Classes
  function f() {
        return {x: 10, y: 20, z: 30, volume: function() {return this.x * this.y * this.z;}};
  }

Polymorphism
  assigning a derived class to a base class reference works as you'd expect in any language
  going the other way requires the 'as' operator to assert to TS that you're sure it's right
    unless you turn off strict checks, which is a bad idea
  you can also use type narrowing with 'instanceof' to assign it in a block without needing 'as'
  VERY IMPORTANT: if an object was assigned via structural typing, it is missing the inheritance chain
    an object not created via 'new' on the derived class will not pass 'instanceof' checks
    and lots of other things will go wrong - do not mix the concepts!
  remember that structural typing treats classes like interfaces!

[Generics]
can be used with any type args, not just reference types
type arg goes to the right of name for both functions and classes
elemnents of the type must be treated as Object
  primitives will be auto-boxed as needed for you

functions can infer types or be called explicitly as f<number>()
classes can infer or give explicitly too

<T extends MyInterface> to be able to use members of MyInterface in the generic

JS has no concept of generics, and the compiled JS code just uses the raw types
  eg. const m = new Map(); // can add whatever key and value types you want

type annotations must use the generic type (eg. Map<string, string>) [which often can be inferred]
the right-side of assignment (eg. 'new' operator) can use the raw type or the specific type
  if specific, you can't conflict with what you put on the left
if you left the left side infer and use the raw type on the right side, it acts like a raw type in Java
  TS will just believe you when you assign it to type param version

a generic with void as a type arg is sort of special
  eg. Box<void> can be constructed as Box(undefined) or Box() assuming c'tor takes T arg
  this is very useful in rxjs for subjects that need to signal without emitting a specific value

[Imports/Modules]
Exporting
  'export' in front of any variable, class, etc. you want to export
    eg. export const PI = 3.141519;
    eg. export class MyClass {}
    just making them public is not enough to make them exportable
      though they still exist and can be seen by the exportd functions from within here
  you can also declare exports at the top instead of inline throughout the file
    export {MyClass, PI};
    export {MyClass as MyType}; // provide a 2nd name to use in addition to MyClass which was exported already
      you can rename variables, classes, etc.
      if you already exported them, then you are giving them two names (eg. for different kinds of clients)
Barreling
  you can export symbols from another file and have them pretend to be part of this file
    no indirection for the user
    eg. export * from './otherfile';
  in addition, you can add a layer of indirection if you want
    export * as subfile from './otherfile';
      then client sees it as subfile.MyClass, etc. after importing from you
Default Export
  export default class MyClass {}
    only 1 default allowed per module
  the difference is you can drop the {} on import for the default symbol only
    import MyClass from './mymodule';
    import {OtherClass} from './mymodule';

Importing From TS Files
  in another TS file, import by relative path from the file itself (not working directory or project)
    eg. import {PI} from './myconstants';
        console.log(PI);

    note the following:
      {} around the names to import (unless importing the default export)
      quote the path
      use ./ for relative path (necessary)
      no file extension on the TS file importing from
    
    eg. import {PI} from './subfolder/myconstants';
Importing from Node Modules
  import {SomeSymbol} from 'somepackage';
    the main difference here is the lack of ./
    instead of relative import, it's an absolute import
    somepackage is expected to be npm installed into the folder containing this TS file
      or one of its parents
Multiple Imports
  import {x, y} from './constants';
Renaming
  import {PI as myPi} from './constants';
  console.log(myPi);
  import {x as myX, y as myX} from './constants';
Import All Importable
  import * as Constants from './constants';
  console.log(Constants.PI);
Import Type
  not technically required but added in later TS and recommended for clarity
  import type {MyClass} from './types';
  import {type MyClass, PI} from './types'; // mixed classes and variables

Statefulness of Imports
  you can't directly assign a variable that was imported to change it
    eg. import {x} from './myfile'; x = 100; // ILLEGAL
  but objects referenced via imports are living stateful objects that you can change
    eg. import {m} from ../myfile'; m.x = 100; // FINE
  all the various places that import or rename that variable will see the change!
  the top-level code from the imported module is only run once on the first import
    then the state just continues to live and get returned by other modules that import it

old concepts/keywords you may see (discouraged in new code):
  namespace
  module

Ambient Declarations
  similar concept to a header in C++
  just telling the compiler how to use a JS library
    the contents of an ambient declaration go away in the emitted JS, but it helps you safely use the library
  you compile against the ambient declaration and then make sure the JS library behind it is there at runtime
    via webpack, etc.
  typically in a .d.ts file named for the JS library
    many JS libraries come bundled with .d.ts files, and many have them available as separate packages
  use the 'declare' keyword to make a declaration ambient

  Examples
    declare const someVariable: string;  // we can code against a string variable someVariable
    declare function someFunction(a: number): void; // can call this and assume it will exist
    declare class MyClass {constructor(arg: string); method(): void;} // all abstract, assume will work out

    code that makes use of someVariable, someFunction, and MyClass will have type checking according to the above
    then the emitted JS code will use those symbols in the normal JS type unsafe way
    then any JS code included into the bundled JS for the app will have those symbols defined so that the code works

  the 'declare' keyword is also used in a hack in Angular to prevent issues with minification in reactive forms
    I'm not sure the details of how it works
    you declare your @ViewChild FormGroup variable in the angular component class as 'declare' and it works out

  Definitely Typed
    a repository of community-provided .d.ts files for common JS libraries
    just do 'npm install @types/the-package' to install TS ambient declarations for JS library the-package
    eg. @types/jquery
    eg. @types/node
    and of course you need to install the real JS libraries for those types to work
    eg. jquery, node in above

    some JS libraries will already come with .d.ts files becuase they're commonly used by TS users

[stdlib]
** no imports needed **

Math
Date
Promise<T>
setTimeout(() => {})
XmlHttpRequest for ajax stuff

async/await keywords
    mark function as async and have it explicitly return a Promise<T>
    inside the function, pretend it returns T
    can await a promise inside the function
    other async functions can await your function

[Angular]
templates + styles (encapsulated via shadow DOM and/or extra classes/selectors)
templates compiled into JS code to build DOM
TS code as well
Modules
bootstrapping
dependency injection
jasmine testing

[CSS]
/* Apply to all elements */
* {
  box-sizing: border-box;
}

/* Tag selector */
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  margin: 0;
  padding: 0;
}

/* ID selector */
#myButton {
  background-color: #008cba; /* Blue background */
  color: white; /* White text */
  border: none; /* No border */
  padding: 15px 32px; /* Padding */
  text-align: center; /* Centered text */
  text-decoration: none; /* No underline */
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer; /* Pointer cursor on hover */
}

/* Class selector */
.myClass {
  color: red;
}

/* Descendant selector */
nav ul {
  list-style-type: none; /* No bullets */
  padding: 0;
}

nav ul li {
  display: inline; /* Display inline */
  margin-right: 10px; /* Margin to the right */
}

/* Child selector */
nav > ul {
  border-bottom: 1px solid #ccc;
}

/* Adjacent sibling selector */
h1 + p {
  font-size: 1.2em;
}

/* General sibling selector */
h1 ~ p {
  color: green;
}

/* Attribute selector */
input[type="text"] {
  padding: 5px;
  border-radius: 4px; /* Rounded borders */
  border: 1px solid #ccc;
}

/* Pseudo-class selector */
a:hover {
  color: orange;
}

/* Pseudo-element selector */
p::first-letter {
  font-size: 2em;
  color: red;
}

/* Media query */
@media (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

[HTML/DOM]
<form id="myForm">
        <label for="name">Name:</label><br />
        <input type="text" id="name" name="name" required /><br />
        <label for="email">Email:</label><br />
        <input type="email" id="email" name="email" required /><br />
        <label for="pwd">Password:</label><br />
        <input type="password" id="pwd" name="pwd" required /><br />
        <input type="submit" value="Submit" />
      </form>

<script>
      // Prevent form from being submitted
      document
        .getElementById("myForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();
          console.log("Form submission prevented.");
        });

      // Log a message when the button is clicked
      document
        .getElementById("myButton")
        .addEventListener("click", function (event) {
          console.log("Button clicked.");
        });
    </script>

[React]
React = unidirectional flow, virtual DOM (always being "rebuilt")
dynamically returning templated HTML code from functions
Redux for state management
    and built-in state management functions

[ToDo]
function expression 'this' binding (more useful for anonymous classes?)
