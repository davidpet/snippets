** rewrite of this sheet is in progress **
** steps left:
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (since JS/TS has some in common with python note in common with Java)
** 4. possibly expand the web sections in example notebooks: HTML, CSS/SASS, Flexbox/Grid
** 5. any other popular libraries (eg. rxjs)
** 6. include info on latest versions (and mark current version here)
** 7. any outstanding ToDo items at the bottom

[Playgrounds]
https://www.typescriptlang.org/play - TypeScript playground
  not just for testing TypeScript code
  can also show you the JS code emitted, which is useful for learning JS when you know TS
    or understanding better what concepts in TS actually mean
Javascript - just use Chrome Devtools, console tab
  you can enter a statement and hit Enter to run it
  will see the DOM of the current page and keep state
  even comes with jquery ready to use

[Variables]
boolean (true/false)
number (both float and integer)
  all the usual literals (inc. exponential, hex, etc.)
  built-in symbols for dealing with floating point:
    NaN
    Infinity
    -Infinity
    isNan()
    isFinite()
string (lowercase)
bigint (if need more than 54-bit integers)
  trailing n literal (eg. 'const x = 10n;`)

let x: number = 5; // mutable
const x: number = 5; // immutable
let x = 5; // type inference (the variable is typed, but it was inferred at compile-time)

let point: {x: number, y: number} = {x: 10, y: 20}; // custom object
let obj: object = {x: 10, y: 20}; // works because all objects inherit object
let point: {x: number, y: number} = {x, y}; // Shorthand Property Names
  x and y are used as both the keys and the variables to get the values from
  if the variables were called something else, you'd still have to say x: somethingElse and y: somethingElseElse

let a: any = 5;
  a could be any type
  often used for compatibility with JavaScript code where anything goes
  a could be reassigned a different type of object arbitrarily
  you can do whatever operations you want on it, like you're in JavaScript land
let a: unknown = 5;
  similar to any, but you can't do any operations on it that are type-specific
  you have to convert to a type first (eg. via type narrowing)
  otherwise, it's similar to using object directly

let n: null = null; // the type of null is null
let u: undefined = undefined; // the type of undefined is undefined

let n: never = f(); // the function is not expected to return (eg. because always throws)

let x: number | string;   // type unions
  can at any time assign a number or string (and back and forth) to the variable
let x: number | null;   // nullable type via union
let x: number | undefined;

static variables only exist as class members (no local statics)

scoped like Java, not Python
  block-scoped, not function-scoped

primitives are mutable variables (while the objects themselves are immutable)
  as in most languages
the primitive types (from JS) are: string (!!!), boolean, number, undefined, null, symbol, bigint
  they are true value types and don't have any methods to call themselves
  when you do something like 5.toString(), that is an error because it tries to call it on the primitive
JS has boxed types String and Number, for instance, but it's a little different from boxing in Java
  if you do 'const x = 5' and then 'x.toString()', JS will autobox and call the method inline!
  in general, you should never have to use the boxed types directly (and it is very uncommon to do so)

objects are mutable reference types (as in most languages)
  let obj1 = {x: 10, y: 20};
  let obj2: {x: number, y: number} = obj;
  obj2.x = 100;  // this changes obj1 (a reference, not a copy)
structural typing does not imply copying - just matching
strings are immutable like in Java, C#, etc.
  but they are not reference types!
collections, including arrays, are mutable reference types

Nullability
  let x: number;    // no value specified
    x is actually undefined, even though we didn't say it could be undefined with a type union!
  let x: number|undefined;  // same thing, but other code will be able to tell it could be undefined better
  let x: number|null = null;  // explicit nullability specification
  if (x === null || x === undefined) {...}
  note that both null and undefined are real valeus from JavaScript and === will work even if the type is wrong

Type Alias
    type Person = {
      name: string;
      age: number;
      email: string;
    };

    type BetterPerson = Person;

    const x: BetterPerson = {name: "bob", age: 20, email: "bob@bob.com"};

Enums
  regular enums and string enums
    eg. can just give values with no = to auto-assign like in other c-like languages
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
  let playerDirection: Direction = Direction.Up;

Interning
  only applies to strings, not numbers or anything else
  if you create a String() instead of string(), === will do reference comparison
    and be false even for same literal string
  otherwise, === will be true because of the shared pool of strings
    you don't usually need to worry about that

JS vs. TS Types
  most of the types discussed here and in Collections come from JS
  but the following are added by TS:
    enums
    tuples (which is really just an array with mixed types)
    any
    unknown
    never
    void
  also, generics don't exist in JS
    Map is a container that can take objects of any type and doesn't enforce they match
      like using raw type in Java
    TS adds generics functionality to provide safety when you develop and compile your code

Symbol/symbol
  symbol is a primitive type (ES6) referring to a globally unique object
  Symbol() gives you a new symbol
    (looks like a class but it's not because you don't use 'new')
  Symbol('this is my symbol')
    can provide a string for debug output purposes
    but two Symbol() calls with the same arg will give two different unique symbols
  Symbol has members you can use that are known as "well-known symbols"
    Symbol.iterator, Symbol.search, etc.
  symbol (lowercase) is the type you would use to declare a symbol as a variable
    then call Symbol() without 'new' to create it
  a symbol can be used as a key in a map
  it can also be used as a key in an object, by using the computed property syntax
    eg. private [mySymbol]: number;
  one special behavior of symbol keys is they are ignored by Object.keys()
    so in a way it's kind of a hidden property

var
  var is the old-fashioned way of declaring variables (before let and const came along)
  you should avoid it in new code, but may see it in legacy code
  var is like let with these differences:
    function scoped like python
      eg. if you declare in a condition, you can see it outside the condition
    can read it anywhere in the function, even if not declared yet
      called "hoisting"
      value is undefined if not set yet
    window automatically gets any top-level vars (but not let or const)
    can redeclare same symbol with var again with no issue

[Collections]
Literals
  only array and object have literals ([] and {})

Arrays
  let a: number[] = [1, 2, 3, 4, 5];
  let a: Array<number> = [1, 2, 3, 4, 5];
  let a = [1, 2, 3, 4, 5];
  let a: number = []; // no type inference if empty

  a[0] // read-write
    no negative indices like Python
  a.length

  a.push(val) // append to end (O(1) like Java ArrayList)
  a.push(val1, val2, val3) // append multiple to end
  val = a.pop() // remove from end (O(1) like Java ArrayList)
    undefined if empty

  a.unshift(val) // append to front (O(n))
  a.unshift(val1, val2, val3) // append multiple to front, keeping this order
  val = a.shift(val) // remove from front (O(n))
    undefined if empty
  
  b = a.slice(start, stop); // inclusive start, exclusive stop
    b is a COPY of a range of a

  array is iterable via 'for...of' (and normal for loop w/ length) construct
  can also use a.forEach((num) => {})

  const a = [...firstList, ...secondList]; // spread operator (in-place)

  const [first, second, ...rest] = a; // destructuring
    rest is another array here
    use _, __, etc. for don't care values
      const [first, _, ...rest] = a; // ignoring 2nd value

  a.filter() and a.map()
    both return an array, not some lazy stream like Python
  
  a.indexOf()
    for reference types, looks for reference
  
  [][] for multidimensional arrays
    nested [] just as you'd expect

  Array.from() can make an array-like thing into a true array
    the thing you pass in must support indexing and length like an array
    or alternatively, must be something iterable
    this is also another way to shallow-copy an array

  inference of mixed types
    const a = [1, 'hi', true];
      type is (number|string|boolean)[]
    const a = [new MyClass(), new MySubClass()];
      type is MyClass[]
    const a = [new MyClass(), new MySubClass(), new Object()];
      type is Object[]

  Reification
    const a = [1, 2, 3];
    a[4] = 5;
    console.log(a[3]);  // undefined
    console.log(a.length);  // 5

    const b = [1, 2, 3, , 4]; // same thing as above

    JS stores arrays like this sparsely

  const s = arr.join(',');
    joining array elements into string with delim
  
Tuples
  similar to array, but fixed length and not homogeneous type
  let tuple: [number, string, boolean] = [10, 'hi', true];
      tuple[0] (read-write)
        not immutable like in Python
  tuple.length
  can destructure just like an array
    const [a, b, c] = tuple;
  can use 'for...of' like with arrays

Sets
  let s: Set<number> = new Set([1, 2, 3, 4, 5]);
      add(), has(), delete(), size()
  const s = new Set<number>();

  s.add(value);
  s.size // not a function for some reason
  s.has(value)
  s.delete(value)
  s.forEach((value) => {console.log(value);});
  s.forEach((value, index) => {}) // JS knows based on the lambda passed in
  use 'for...of' construct like with arrays

Maps
  let m: Map<string, number> = new Map([
      ["a", 10,],
      ["b", 20,],
  ])
  const m2 = new Map<string, number>();

  m.set(key, value)
  m.get(key)
    m.get(key) || defaultValue
    note that you CANNOT do m[key] (even though you can for objects)
  m.has(key)
  m.delete(key)
  m.size()  // # of keys
  m.clear()

  for (const [key, value] of m) {
    console.log(key);
    console.log(value);
  }
  also can use m.keys(), m.values(), m.entries()

Objects (as structs)
  let o: {a: number, b: string} = {a: 10, b: 'hi'};

  type Entry = { // note similarity to C struct syntax (plus =)
    a: number;
    b: string;
  };
  let o: Entry = {a: 10, b: 'hi'};

  interface Entry {
    a: number;
    b: string;
  }
  let o: Entry = {a: 10, b: 'hi'};  // equivalent to the 'type' version

  let o = {a: 1, b: 2, c: 3}; // we will ignore c
  let {a, b} = o;  // destructure into variables called a and b with those values from the object
  let {a: x, b: y} = o; // renaming the variables to x and y locally

  keys can be quoted or unquoted (or not even strings at all)
    const obj = {a: 1, "b": 2, true: false, 1: "One",};
    obj.a, obj.b, obj.true (actually a string key), no way to do obj.1
    to access an object field using a string (or other type of thing) as the key:
      obj["a"], obj["b"], obj["true"], obj[1] (not a string)
    unquoted string keys in an object may be subject to minification (and their usages as well)
      the minifier may be smart enough to not minify it (but maybe you want it to)
    even class variables can have quotes around them, but that's weird
    quoted keys can have spaces in them!
  
  Object.keys(o), Object.values(o), Object.entries(o)
    to iterate over fields in an object as if a map
    does not include functions or symbol keys

  Copying Objects
    spread operator
    let m = {...n, x: 20}; // x will replace the value of n.x if present (or add as new)
    // m and n are separate, not linked together

  Computed Properties
    instead of providing a name or a quoted name for a key
    you can put [] around some TS expression to have the key computed at runtime
    the key does not become a string (unless that's what you compute)
      to get the value back later, you have to use the computed thing again
    besides the [] around the key, the rest of the syntax is the same as normal
      works for variables, functions, etc.
      works for interfaces, anonymous objects, classes, etc.
    Objects.keys() will get all the keys in their original types
      but it will purposely ignore keys that are of type symbol

    const m = {
        ['x']: 100, // retrievable as m.x or m['x']
        [20]: 200,  // retrievable as m[20]
        [30]: 300,
        [40](a: number) { return a*a; }, // callable as m[40](someNumber)
        [t + 'Bob']: 400, // retrievable as m['Hi, Bob'] or m[t + 'Bob']
        'a b c ': 500, // retrievable as m['a b c']
    };

Objects (as classes)
  'class' instead of 'interface' and can have constructor, methods, etc.
  created with 'new' instead of structurally like with structs
  covered in detail in "Classes" section below
  a lot of the ideas about objects as structs above apply
    the end result of creating an instance is that kind of object anyway

Readonly
  let a: ReadonlyArray<number> = [1, 2, 3, 4, 5];
    also ReadonlyMap, etc.
  not truly readonly, just enforces the usage (like C++ const)

Stack, Queue, Deque
  no explicit built-in structures for these, but you can use methods of Array
    or roll your own, or install 3rd party libraries like 'deque' from npm
    for queue and deque, the efficiency will be bad if you use js Array
  Stack
    use push() and pop() [O(1)]
  Queue
    use push() and shift() [O(n)]
  Deque
    use push(), pop(), shift(), and unshift() to manage both ends [O(n)]

WeakMap and WeakSet
  like Map and Set
  but don't prevent garbage collection of their keys
  auto-updated when it happens
  no enumeration or size because of dynamic nature

Summary of Class-Like Objects and Their Differences
  Type Literals = TS feature, declared with 'type' or as an anonymous type on a variable declaration (left side)
  Interface = TS feature, declared with 'interface' construct

  Class = JS feature, declared with 'class' keyword
  Anonymous Object/Class = JS feature, assigned as a {} literal

  Method Signature = the normal way of defining a function (eg. f(); or f() {})
  Function Type Property = the lambda/function expression/method reference way (eg. f: () => void;)

  Function Expressions = alternative to lambda where you put the word 'function'
    only for the right side of assignments or passed into places
    the type (left side of assignment) looks the same whether it is a lambda or function expression

  the TS specific ones are type only, so you can specify either method signature or function type property
  the JS ones let you specify all 3 kinds of functions (method signature, lambda, function expression)
  class lets you specify the type (method signature or function type property) while anonymous objects do not

  the TS specific ones let you separate members with either , or ;
    ; is more typical, although inline type literals may have , to match the style of the right side of =
  classes need ; to separate, not comma
    and function bodies {} are exempt, even if they are part of lambdas
  anonymous objects always have to be separated with ,
    even if there is a function body {}

  : is usually for types and = is usually for values, with some exceptions:
    on function names, colon gives a return type instead (optional)
    TS specific ones are types only, so = is not used
    anonymous objects are special - only use : and no =
      and values but no types, except optionally on method return types

  'this' is only relevant to classes and anonymous objects because the others have no bodies
    'this' is bound to the class instance inside a class, shadowing the global object
      unless the method is static
      that is true for all 3 ways to define functions as members of the class
      it is also true for lambdas defined in the bodies of class methods
        this is to allow you to return a lambda that continues to interact with the instance that created it
    inside an anonymous object definition, things get more differentiated
      a lambda/arrow function will bind 'this' to the enclosing scope of the anonymous object
        instead of treating the lambda as a method of the class, it will treat it as a method of whatever is making the class
      a method of function expression, on the other hand, will bind 'this' to the anonymous object itself
        allowing it to act as a method of the anonymous object
    outside of classes and anonymous objects, `this` will just be the global object (eg. window)
      unless explicitly bound
    there is an additional caveat that when a function or function expression is inside the body of a function,
      the 'this' binding will depend on the call site rather than the definition site
      this lets you return a lambda from a method and have it act as a method of the class that uses it

[Strings]
strings are immutable (mutation functions return new copy)
  but they are not reference types like in other languages!
there is no char type - a character in a string is a single-item string (same type)
strings are based on unicode and are not null-terminated

s + t + 3
  concatenates two strings and a number (converted to string)

'' and "" are both for string (char is just a single character string, not special thing)
`Hello, {name}!` // 'name' should be variable in current scope
  backtick quote
  variable can be a number too!
  the thing in {} can also be a TS expression instead of just a name!
`` is a multiline string (backtick quote)
  if you don't have a newline it will just be single line, but you can have newlines in it
    no need to escape the newlines
to use a normal string with an object of params, you have to do it yourself using string.replace()
  there is no built-in way, but many frameworks have it
there are no raw strings

s.length
s[0], s.charAt() // read-only
  these are single-character strings!
  there is no char type
s.substring(start, stop) and s.slice(start, stop) // equivalent, just like array slicing
s.toUpperCase(), so.toLowerCase()
s.split(delim) gets a string[]
  can convert s to string[] of single-character strings:
    s.split('') // empty-string
s.replace(old, new)
  old can be a string or a regex pattern
s.includes(substr)
s.startsWith(substr)
s.endsWith(substr)

for...of iterates over characters (single-length strings)

Conversions
  s = n.toFixed(2) // format a number as a fixed-point decimal string
  parseInt() and parseFloat() to get numbers from strings
  +s // number to string via unary plus operator
  JSON.stringify() to make object into json string
    JSON.stringify(o, null, 2) to pretty-print with 2 spaces per indent
  JSON.parse() to make json string into object
  n.toString() to get string from number
  o.toString() to get string from object (as it defines for itself)
    arrays do not have this
    set and map do not implement it properly

Base64
  btoa(original)
    gives a base64 encoded string
  atob(encoded)
    gives back original string from base64 encoding

console.log()
  console.log(a, b) logs both with space in between
  eg. console.log("field:", value);
  console.log(o) works on objects (will show keys-values) and built-in types
    much better than toString() and such
  output goes into debug console (eg. Chrome Devtools)
  console.log() for empty line
    can also use \n in strings
console.error()
  like console.log() but more serious (shows up red)
console.warn()
  less series than console.error()
console.info()
  similar to console.log()
there are color escape codes available too

Regular Expressions
  const pattern = /\d+/g
    makes a regular expression object directly using perl-like syntax
    no need for raw strings because already raw (unquoted)
    the // quotes it, but global flag comes after /
  pattern.test(text)
    true if a match anywhere in text
  matches = text.match(pattern)
    if you use /g flag, gets multiple matches as array of strings
    if you don't use /g flag, gets tuple with info about 1 match
  text.replace(pattern, replacement)
    replace all occurences of pattern with replacement
    can use $1, etc. for capture groups

joining is done by Array
  arr.join(',')
there is no StringBuilder type object
  use arrays and join(), or template strings

[Operators]
all the usual arithmetic, arithmetic assignment, bitwise, and comparison operators from c-like language
  and ternary operator
  and pre and post increment/decrement
&&, ||, ! for conditions

type narrowing (a unique feature of TS)
  if (typeof x === "string") {
    let y: string = x;  // legal because x is type string in this scope
  }
  if (x !== null) {
    // in here, you can treat x as not nullable
  }
  if (x) {
    // in here, x is not undefined or null
  }

== for a number or string will try to coerce one to match the other (eg. number to string) before comparison
  it comes from JavaScript and causes a lot of bugs
=== (also from JavaScript) does not do this coercion
  thus, it is called strict equality
  it is mostly (and often mandatorily) recommended instead of == in TypeScript
both == and === will check value equality for numbers and strings
both == and === will check reference equality (not value) for reference types like objects and arrays
=== works correctly with null or undefined (and similar) as well
  you are permitted to do the === check even if the type says it can't be null or undefined
!= and !=== correspond to == and ===
for value equality in a custom object, you have to implement .equals() for the class
arrays don't have .equals(), but you can use JSON.stringify(arr) === JSON.stringify(otherArr)

Casting/Coercion
  x as OtherType // compiler will keep you honest
    will only do things like any to a specific type or polymorhpic stuff
    wil not do things like string to number
    for things the compiler can't see are wrong, you may get unexpected behavior
      eg. let s: string = "hi";
          let o: any = s;
          let b: boolean = o as boolean;
          console.log(b);
          // you expect it to print a boolean, but it prints a string
      this is because 'as' is a pure TypeScript compiler feature
        it is removed entirely in the emitted JavaScript code
  let y: number = +s; // coercion to number via unary + operator
    eg. string to number
    will throw exception if bad format
  n.toString()
    but 10.toString() not allowed because of parsing issues
  
?? nullish coalescing
  x ?? "hi"
    will be x unless x is null or undefined, then it will be "hi"
  note a general truthiness check - just null|undefined check

! non-null assertion
  let x: number = nullableNumber!;
    TS doesn't actually do anything at runtime here (including throwing anything)
    you are just telling the compiler to trust you that the thing cannot be nullable here anymore
    you could very easily be wrong and have null at runtime when the compiler thinks you can't (be careful!)
      could end up causing other bugs and throwing other kinds of errors at runtime

? safe-navigation operator (also called optional chaining, or Elvis operator)
  a?.b?.c?.d
  if any link in the chain is nullish (null|undefined), stops and returns that

typeof x
  gets a string representing the primitive type of an object (in JS)
  note it's not a function call (no parenth)
    eg. typeof x === "string"
  because it's so primitive, it doesn't work for polymorphism in class hierachy
    all reference types are seen as 'object', including arrays
    even null is 'object' (but 'undefined' is 'undefined')
  number, boolean, and string work as you'd expect (it's very useful for these specific types)

x instanceof MyClass
  boolean check of whether the class is in the inheritance chain of x
  it works because JavaScript uses prototype inheritance, so JS will check the prototype chain for the class object
  but it won't detect structural typing, so be very careful relying on this!

"fn" in y
  membership check
  if y is an object, this will check if it has a method or variable called 'fn'
  may be defeated by minification

Truthiness
  !! and ! are opposites
    !! makes value into boolean based on truthiness, ! does same but negates it
  falsey: null, undefined, 0, "", NaN, false
  truthy: empty collections, empty arrays, empty objects, anything else
  boolean operators like && and || return actual values (not boolean conversion)
    they evaluate the conditions in terms of truthiness (as with !! and !)
    and then do short-circuiting based on that
    then the last value seen is the one returned (the original value, not the boolean)
  you can use || as a truthiness coalescing operator
  statements like if() do an impliict truthiness conversion too
    for instance, you can do if (myIntValue && myStringValue)
    but your linter and coding conventions may wish you to use !! to be more explicit

Spread Operator
  const a = [1, 2, 3];
  const b = [...a, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

semicolons are technically optional
  JS people don't like them
  TS people like them
  leaving it out can actually ruin the parsing of some multi-line statements

[] operator for indexing
  available on arrays and objects, but not for getting keys/values in a map

[Control Flow]
'if/else if/else', 'while', 'do/while', and 'switch' work exactly like other c-like languages
'break' and 'continue' as well

'for' loops have these forms
  for (let i = 0; i < 10; i++) {} // typical C-style
  for (const item of arr) {} // like Java range-for but 'of' instead of :
  for (const index in arr) {} // not recommended because unexpected behavior

  for (const [keyOrIndex, value] of collection) {}
    works for a lot of collections (eg. map, array)
    also, can call .keys(), .values(), .entries() members to iterate over those specific things
    for objects, use Object.keys(obj), Object.values(obj), and Object.entries(obj)
      note that iterating object properties has the following quirks worth mentioning:
          if you define a variable without setting it, it will not show up here
          if you set a variable to undefined, which is technically (mostly) the same, it will show up here!
          a function will not show up here, but a lambda or function expression variable will!

  for await (const item of asyncCollection) {}
    for asynchronous items (wait for 1 at a time)
    eg. promises

try {
  throw new Error("Uh oh!");
}
catch (error) {
  // use instanceof operator to check type of exception
}
finally {}

Not Available: context management, asserts (have to use libraries)

[Functions]
types look a lot like python type annotations (but compiler actually cares)
unlike in C/C++/Java/etc., you have to put 'function' in front if not a class method
  this is similar to having to use 'def' in Python
unlike in Python, you can't arbitrarily reassign a function to a different lambda or something
  functions are not just treated as variables
  HOWEVER, in pure JS you could do that (TS compiler is the one preventing it)

function add(x: number, y: number): number {
    return x + y;
}

Optional Params
  function greet(name?: string): void {
    if (name) {
      console.log(`Hello, ${name}!`);
    } else { // name is undefined
      console.log("Hello, stranger!");
    }
  }

  greet(); // Output: Hello, stranger!
  greet("John"); // Output: Hello, John!

Default Params
  function power(base: number, exponent: number = 2): number {
    return Math.pow(base, exponent);
  }

Named Params
  not a first-class language feature, but you can do it with objects

  function greet({ name, age }: { name: string; age: number }): void {
    console.log(`Hello, ${name}! You are ${age} years old.`);
  }
  greet({ name: "John", age: 30 }); // Output: Hello, John! You are 30 years old.

Rest Params
  function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

  function processOptions(options: { [key: string]: any }): void {
    // use options as an iterable object with keys and values
    // key is not a variable - it is telling it how to interpret the options object
    // this makes use of index signatures
  }
  processOptions({a: 1, b: 2});
  // could use ...options to process multiple objects

Overloading
  doesn't work because of redefinition of symbols
  the usual way is to use type unions w/ instanceof, optional params, etc.
  there is a way to declare your intent to have overloads to the compiler, intellisense, etc.
    function f(a: number, b: number);
    function f(a: number, b: string);
    function f(a: number, b: number|string) {// implementation goes here}
    // similarly b could be optional if you had f(a: number) in the list

Generators
  function* lazyList(limit: number): IterableIterator<number> {
      let i = 0;
      while (i < limit) {
        yield i++;
      }
    }
  const l = lazyList(5);
  console.log(l.next().value);
    OR for (const item of l) {console.log(item);}
    OR const a = Array.from(l) // to make into eager array
  can send values into the .next() call just like python for two-way communication

nested functions allowed but uncommon due to multiline lambdas
    unlike Python

return type can be ommited to let it be inferred
    eg. void, esp. private method
    general rule: maybe ommit if can be easily inferred
      but include by default, except for private methods

never is a special return type that means the function never returns
  eg. if the body throws

[Functional]
"fat arrows" with all the usual combos
  multiline body, implicit return, type inference on args, etc.
  you can't usually leave out the () though
    only in the case of 1 param with inferred type

const addNumbers = (a: number, b: number): number => a + b;
let greetFunc: (name: string) => void;
let run: () => void;
const run = () => console.log('hi');  // void statements allowed on void returns
const fns: (() => void)[] = []; // list of lambdas

function expressions: like lambdas (and assignable to varaibles like lambdas)
  looks like defining a function but without the name

  const fn = function (x: number, y: number): number {
    return x + y;
  }

  completely interchangeable with lambdas and functions just like lambdas are
  subtle difference = handling of 'this'

to return an object from a lambda with {} and no body, you have to wrap it in extra ()
  because it will think the {} is a method body
  eg. (a, b) => ({x: a, y: b})

IIFE:
   (() => {
    console.log("lambda call!");
  })();

variables with function types can be assigned lambdas or normal functions
  then you can call the variable just like it was a normal function
but you cannot rebind a normal function to a different function or a lambda in TS
  in JS you can
  in TS, you can think of it like it's a "const" variable (though it's not exactly the same)
  also in JS, people like to use lambdas assigned to constants instead of using 'function'
    less popular in TS
functions (inc. top-level, lambdas, methods, and function expressions) are reference type
  they even have methods

closures usually are by reference (even for primitives)
  but loop variables are an exception (eg. for loop iteration variable)
  to make a value close by value instead of reference, you need to make it a parameter of a function
    in other words, lexically capture it
    eg. a nested function, an IIFE lambda around the lambda, etc.
  this is similar to Python except for the part about loop variables

you can use _, __, ___, etc. as "don't care" values for lambdas, destructuring, etc.
  technically those are actual names (valid identifiers)
  but by convention they are d.c. values

this
  the 'this' keyword is not as straightforward as other languages
    it has a lot of JS weirdness that TS is stuck with
    not just for use in classes (normal functions have it too)
  
  in a top-level function that is not lambda or function expression, 'this' is either:
    the global object (eg. window in a browser) by default
    undefined if in strict mode
  in a lambda (with arrow), it is captured from surrounding scope
    eg. if in a class, it is the class instance
    eg. if in a top-level function, it is whatever it is there
  in a function expression, it depends on the context
  in a method of a class, 'this' is the instance
    and you're required to use 'this' to access members (similar to 'self' in Python)
      but don't include in method signature

  you can call the bind() method on a function object to explicitly bind 'this' to something
    eg. to treat a free function as a method of a class when called
    see Partial Application for more details

Partial Application
  // just binding 'this'
  function f() { console.log(this); }
  const g = f.bind([1, 2, 3]);

  f();  // prints global object or undefined
  g();  // prints [1, 2, 3]

  // binding 'this' and some args
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  const g = f.bind(this, 10, 20);
  g(30);  // prints global object and returns 60

Applying Arguments from Iterable
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  
  f.apply(this, [10, 20, 30]); // prints global object and returns 60
  f(...arr) where arr = [10, 20, 30] would also work
    using spread operator to expand args
    when you don't need to bind 'this'

Applying Arguments Positionally
  f.call(this, 10, 20, 30);
  this is similar to bind() except it's actually calling
  a convenient way to bind 'this' without having to make a variable for the result

map, reduce, filter
  map, reduce, and filter are array methods that return new arrays
  note that reduce signature looks like arr.reduce(fn, seed) [weird order]

some, every
  boolean methods of array that takes predicate
  some = usually called any in other languages
  every = usually called all in other languages
  eg. arr.every(n => n % 2 == 0)

Method References
  a method can be assigned to variable exactly as you'd call it
    eg. const f: () => void = instance.f;
    eg. const f: () => void = MyClass.f;
  assigning the method via an instance or via the class mean the same thing here
    both are considered UNBOUND
  to make either one BOUND, call .bind() on it
    eg. const f = instance.f.bind(instance);
  because JS functions only bind via 'this' binding, any function can become a method this way
    and static vs. instance just means whether 'this' is bound to the instance
  the type of a variable holding a method reference is the same as the equivalent function or lambda
    the 'this' part of it does not factor into the type

Lazy Sequences
  use generators that yield from other generators
  the yield stops the for loop from being eager
  3rd party options include lodash and rxjs

[Classes]
looks mostly like Java with some differences noted here
also worth noting that a class is syntactic sugar for making an object (as described in collections)
  just with function variables for methods and prototype for inheritance

things in common with Java worth noting here again:
  all methods are virtual with no need to specify overriding
  inheritance works the same way (on the surface)
  use 'new' keyword to make a new instance
  default constructor w/ no args only if no construtor specified
  can only extend a class but implement multiple interfaces (no python/c++ diamond behavior)

need to use 'this' in front of all member access from methods (never implicit)
  but also not passed in as param like in python
members are 'public' by default because that's how JS works (where there is no access level)
  no such thing as package-private like Java: just public, private, protected
methods do not have 'function' keyword, which makes them look more Java-like and less JS-like
member variables are declared in the body like Java (not in the c'tor like Python)
  but there is a special construct called Parameter Properties covered below that can act that way
unlike within code statements, variable declarations in classes don't use 'const' or 'let'
  act as 'let' by default
  can be made to act as 'const' with the 'readonly' qualifier
static variables and methods allowed
  accesed by ClassName.member
no destructors/finalizers

instead of being named for the class, the constructor is called 'constructor' and there can only be one

Properties
  put 'get' in front of a method to make it a readable property
  put 'set' in front of a void method to make it a writeable property
  if a 'get' and 'set' method have the same name, they are the same property
    usually impossible since no overloading
  you can independently control access to the getter and setter
  you can access a property from an instance as if it was a variable

Parameter Properties
  a constructor parameter with an access specifier in front
  automatically makes the parameter into a member variable of the class (without having to decalre it in the body)
  eg. used to inject services in Angular
  JS implements this by doing this.x = x in the c'tor (for example)
    TS won't let you do that directly because that violates the type safety of classes

Adding Fields Dynamically to Classes at runtime
  eg. m.x = 10 when x is not a member of the class
  this is ILLEGAL in TS because if violates type safety
  but it is LEGAL in JS (just like python) and is used by parameter properties

Syntax Example
  class MyClass {
    x: number;
    private y: number;
    protected z = 20; // type inferred
    static a: number = 100;

    private readonly myConstant = "Hello";

    constructor(name: string, age: number, private readonly service: Service) {
    }

    getSpecies(): void {
    }
  }

  class MyDerivedClass extends MyClass implements SomeInterface1, SomeInterface2 {
    getSpecies(): void {
      // overrides without having to say so
    }

    // etc. etc.
  }

  const m = new MyClass("Bob", 20, myService);

Nullability of Members
  name?: string;  // shorthand for string | undefined
  name: string | null;
  name!: string;  // supposed to be populated by the end of the c'tor
    treated as non-nullable throughout the class (trusting that you will fill it before it's used)

Construction Order
  inline variable initializers run like normal code (not compile-time constants)
  they can reference each other (still have to use 'this')
  can call instance methods, etc.
  presumably should only reference variables declared higher in the list? (but fns don't matter)

  super() calls the superclass constructor
    you are required to do it explicitly if you have a c'tor in a base class
    but it doesn't have to go first
    this has some weird caveats to know about
      base fields aren't available until after super() is called beause that's when it really creates the base
      you also can't use 'this' until after super() is called for similar reasons
    the compiler enforces all this for you

Prototype Inheritance
  because inheritance is impelmented in the JS layer using prototypes, that is the basis for inheritance behavior in TS
  this has some key differences from inheritance in languages like C++ and Java (and similarities to Python):
    variable names are virtual too, not just method names
    private variables of the same name in a derived class are forbidden
      this is because when it makes the JS equivalent, it will name clash, making it not private after all
  only 1 thing of each name because it's like a dictionary (no overloading)

ABC
  can only be inherited by abstract classes unless all abstract methods are overriden
  cannot instantiate with 'new'

  abstract class MyClass {
    abstract f(): void;
  }

  abstract class MyOtherClass implements MyInterface {} // interface introduces abstract methods into the class

Interfaces
  unlike Java, can have both fields and methods
  worth noting: unlike a class, which emits JS code, interfaces don't emit any JS code and aren't a JS feature
    it just helps the compiler to keep you honest before compiling to JS
  
  interface Person {
    name: string;
    age: number;

    greet(): void;  // abstract method
  }

  can be used like a base class in polymorphism just like other languages

  private members are not allowed

  Partial<Person> gets an interface that looks like Person but all fields are optional
    like adding ? to all fields that don't have it yet

Class as Interface
  unique feature
  you can pretend a concrete class is an interface and pass it as 'implements'
  all the implementation gets sucked out and only the prototypes are used (abstract)
  classes with private members cannot be used this way

Nested Classes
  a class can't be defined in another class like in other languages
  but it can be defined in a function body, so that's a potential workaround

Structural Typing
  very idiomatic TS concept
  adds some order to the chaos of JS duck-typing
  objects that are structurally compatible with other objects can be detected by the compiler
    but they cannot be detected easily at runtime
      eg. instanceof is useless for this
    to actually do it, you'd have to manually check all the properties
  the basic idea is if the interface of the object you pass in looks like the interface expected,
    then the compiler will let it through
    eg. even if the function expects a class and you pass a custom object without using new or the real class
    the compiler enforces that the structure is right, but you are free to shoot yourself in the foot
  optional fields expected on the left side of the = can be ommited or supplied on the right side
  optional fields expected on the right side of the = must not be required on the left side
  order of members does not matter in structural typing, only names and types
  if you use structural typing with a class, it's treated like an interfaces
    you're basically making an object with the right interface but missing the prototype chain
      it will not behave properly with polymorphic constructs

Object
  all reference types implicitly inherit from Object (and not primitives)
  you can do new Object() for an opaque object

  members commonly overriden:
    toString() and toLocaleString()
    valueOf()
      return a primitive value for operations like arithmetic
      default implementation just returns the reference itself
    equals()
      not used by maps and sets (=== instead)
  
  no hashing
    objects are not hashed the way they are in other languages for use in maps and sets
    the object's reference is treated as the key, and it is unique per instance
    there is no way to treat it as a value like you could in Java
    primitives are hashed as you'd expect them to be

  other methods:
    hasOwnProperty() can tell if a property lives on this object instead of a superclass

  even when you use an interface or structural typing, it is understood all objects have Object members
    and they do not in any way interfere or participate in structural typing checks

Adding Properties to Objects
  const m = MyClass();
  m.x = 10; // ILLEGAL if x is not a member of MyClass (unless pure JS)

  function f() {}
  f.x = 10; // LEGAL (to support decorators?)

Expandable Object
  relies on index signature feature

  interface MyObject {
    [key: string]: any;
  }
  const myObject: MyObject = {};
  myObject.field1 = "hi";
  console.log(myObject.field);
  console.log(myObject['field1']);

Not supported: operator overloading, partial classes
  though index signatures appear on the surface to be operator overloading

override keyword:
  newer addition to TypeScript
  usually optional to use, but Angular turns on the compiler option to make it mandatory by default
  eg. override f(): void {}
  only for overriding base class methods (not implementing interface methods)

Index Signatures
  pure JS allows you to use m.x and m['x'] to add arbitrary variables to any reference object
    arrays are special in that a[1] and a.toString and a['toString'] internally all use the same [] operator
    maps technically have [] but it is only the one from Object (doesn't participate in the key-value pairs of the map construct)
  TS prevents m.x from working if x is not defined on the class, for type safety
    m['x'] may still work, depending on compiler settings (possible to make it fail compiler based on the string inside)
    when the check is not enabled, m['x'] would return undefined if not there
  index signatures are a way to turn some of the JS flexibility back on from within TS
    it is a pure compile-time feature that just affects what you're allowed to do with regard to the above
    an index signature is defined on an interface or class to specify what kinds of types can be keys and values for []
      implicitly understood that m.x is m['x'] in this case
      eg. [index: string]: string; // m.x = 'hi' allowed, m.x = 100 disallowed
      eg. [index: string]: string|number; // type unions allowed
      eg. [index: string|number]: string|number;
    an index signature never has "implementation" because it's just to guard uses of the object
    you could use 'any' as a type to make it fully JS-like
    you can use 'readonly' before the indexer to make it not allow assignment
    other variables defined in the class, subclasses, or superclasses, will only be checked if the key type matches
      eg. [index: number] will not complain about a member x: string
      otherwise, the variables will cause compile error if the left side matches but right side does not
    in structural typing, it is more strict
      any properties passed in must pass the indexer check regardless of whether the left type matches
    members of Object are not checked against indexers because they're fundamental to the language

Anonymous Classes
  function f() {
        return {x: 10, y: 20, z: 30, volume: function() {return this.x * this.y * this.z;}};
  }
  NOTE: anonymous classes will close over variables just like lambdas will
    useful for iterator protocol

Polymorphism
  assigning a derived class to a base class reference works as you'd expect in any language
  going the other way requires the 'as' operator to assert to TS that you're sure it's right
    unless you turn off strict checks, which is a bad idea
  you can also use type narrowing with 'instanceof' to assign it in a block without needing 'as'
  VERY IMPORTANT: if an object was assigned via structural typing, it is missing the inheritance chain
    an object not created via 'new' on the derived class will not pass 'instanceof' checks
    and lots of other things will go wrong - do not mix the concepts!
  remember that structural typing treats classes like interfaces!

Iterable Protocol
  to make an object iterable using for...of without having to use Object.keys()
    eg. to make your generic container give only the values you want when used that way
  worth noting that this is all from ES6 (pure JS), not a weird TS thing
  to make a class/object/interface iterable, it must have this method:
    [Symbol.iterator]() {}
      note the use of a computed property using a well-defined symbol
    the object returned by that method should have a next() method
      this is your iterator
      it might be an anonymous class that closes around some data
      or it could be a whole other custom class
    next() returns IteratorResult<T>
      this is a TypeScript built-in interface just there to help you structure your result properly
      the actual expected structure of the object is {value: T|null, done: boolean}
      you return values and false while you still have values, then you return null and true when you have no more
    alternatively, you could do *[Symbol.iterator]() {} and use a generator method with 'yield'
      then don't have to do the anonymous object

Generator Methods
  work same way as generator functions, but the * goes in front of the name because there is no 'function' keyword
  eg. *myfn(): IteratorResult<number> {}

Declaration Merging
  an interface with the same name as an existing interface or class adds members to that interface or class
    eg. you can use that to add properties to DOM objects like 'window' so TS will let you set them
  members are unioned together - duplicates ok if they don't conflict (eg. same name and type)
  if an interface merges with a class, it adds undefined members that you can assign
  classes can't merge with classes (otherwise, that would be partial classes)
  enums can also merge together, though they repeat ordinals if not otherwise specified
    but can add methods to an enum, for instsance
  this can be used to do extension methods
    add the method's signature via an interface of same name as target class
    then assign TheClass.prototype.theMethod to a function
    this will add the extension method on existing or new instances of the class
    since modifying prototypes like that is not recommended, you could alternatively, do it in a facotry
      wrap creation of new instances and set the function on instances instead

[Generics]
can be used with any type args, not just reference types
type arg goes to the right of name for both functions and classes
elemnents of the type must be treated as Object
  primitives will be auto-boxed as needed for you

functions can infer types or be called explicitly as f<number>()
classes can infer or give explicitly too

<T extends MyInterface> to be able to use members of MyInterface in the generic

JS has no concept of generics, and the compiled JS code just uses the raw types
  eg. const m = new Map(); // can add whatever key and value types you want

type annotations must use the generic type (eg. Map<string, string>) [which often can be inferred]
the right-side of assignment (eg. 'new' operator) can use the raw type or the specific type
  if specific, you can't conflict with what you put on the left
if you left the left side infer and use the raw type on the right side, it acts like a raw type in Java
  TS will just believe you when you assign it to type param version

a generic with void as a type arg is sort of special
  eg. Box<void> can be constructed as Box(undefined) or Box() assuming c'tor takes T arg
  this is very useful in rxjs for subjects that need to signal without emitting a specific value

[Imports/Modules]
Exporting
  'export' in front of any variable, class, etc. you want to export
    eg. export const PI = 3.141519;
    eg. export class MyClass {}
    just making them public is not enough to make them exportable
      though they still exist and can be seen by the exportd functions from within here
  you can also declare exports at the top instead of inline throughout the file
    export {MyClass, PI};
    export {MyClass as MyType}; // provide a 2nd name to use in addition to MyClass which was exported already
      you can rename variables, classes, etc.
      if you already exported them, then you are giving them two names (eg. for different kinds of clients)
Barreling
  you can export symbols from another file and have them pretend to be part of this file
    no indirection for the user
    eg. export * from './otherfile';
  in addition, you can add a layer of indirection if you want
    export * as subfile from './otherfile';
      then client sees it as subfile.MyClass, etc. after importing from you
Default Export
  export default class MyClass {}
    only 1 default allowed per module
  the difference is you can drop the {} on import for the default symbol only
    import MyClass from './mymodule';
    import {OtherClass} from './mymodule';

Importing From TS Files
  in another TS file, import by relative path from the file itself (not working directory or project)
    eg. import {PI} from './myconstants';
        console.log(PI);

    note the following:
      {} around the names to import (unless importing the default export)
      quote the path
      use ./ for relative path (necessary)
      no file extension on the TS file importing from
    
    eg. import {PI} from './subfolder/myconstants';

    NOTE: it is possible to add folders to the search path for relative imports
      via your tsconfig.json file
Importing from Node Modules
  import {SomeSymbol} from 'somepackage';
    the main difference here is the lack of ./
    instead of relative import, it's an absolute import
    somepackage is expected to be npm installed into the folder containing this TS file
      or one of its parents
Multiple Imports
  import {x, y} from './constants';
Renaming
  import {PI as myPi} from './constants';
  console.log(myPi);
  import {x as myX, y as myX} from './constants';
Import All Importable
  import * as Constants from './constants';
  console.log(Constants.PI);
Import Type
  not technically required but added in later TS and recommended for clarity
  import type {MyClass} from './types';
  import {type MyClass, PI} from './types'; // mixed classes and variables

Statefulness of Imports
  you can't directly assign a variable that was imported to change it
    eg. import {x} from './myfile'; x = 100; // ILLEGAL
  but objects referenced via imports are living stateful objects that you can change
    eg. import {m} from ../myfile'; m.x = 100; // FINE
  all the various places that import or rename that variable will see the change!
  the top-level code from the imported module is only run once on the first import
    then the state just continues to live and get returned by other modules that import it

old concepts/keywords you may see (discouraged in new code):
  namespace
  module

Ambient Declarations
  similar concept to a header in C++
  just telling the compiler how to use a JS library
    the contents of an ambient declaration go away in the emitted JS, but it helps you safely use the library
  you compile against the ambient declaration and then make sure the JS library behind it is there at runtime
    via webpack, etc.
  typically in a .d.ts file named for the JS library
    many JS libraries come bundled with .d.ts files, and many have them available as separate packages
  use the 'declare' keyword to make a declaration ambient

  Examples
    declare const someVariable: string;  // we can code against a string variable someVariable
    declare function someFunction(a: number): void; // can call this and assume it will exist
    declare class MyClass {constructor(arg: string); method(): void;} // all abstract, assume will work out

    code that makes use of someVariable, someFunction, and MyClass will have type checking according to the above
    then the emitted JS code will use those symbols in the normal JS type unsafe way
    then any JS code included into the bundled JS for the app will have those symbols defined so that the code works

  the 'declare' keyword is also used in a hack in Angular to prevent issues with minification in reactive forms
    I'm not sure the details of how it works
    you declare your @ViewChild FormGroup variable in the angular component class as 'declare' and it works out

  Definitely Typed
    a repository of community-provided .d.ts files for common JS libraries
    just do 'npm install @types/the-package' to install TS ambient declarations for JS library the-package
    eg. @types/jquery
    eg. @types/node
    and of course you need to install the real JS libraries for those types to work
    eg. jquery, node in above

    some JS libraries will already come with .d.ts files becuase they're commonly used by TS users

  Top-Level of Code
    like Python, you can put whatever you want at the top level and it will execute when imported
    the first file executed is the entry point
    however, unlike Python, TS doesn't like you redefining symbols (eg. same class, function, etc.) multiple times at same level in same file
      that is why you have to use IIFE in Jupyter notebook cells

require()
  'import' is the newer ES6 way to import code
  'require()' was the way Node did it in the past
    both TS and JS support this
  Node now supports 'import', so you don't have to use 'require'
    but you see it all over the place
  require() is basically the same thing but it gives back an object containing the imported symbols

3rd party libraries can also be included by CDN URL in the DOM of your page
  <script src="........."></script>
  this is common for things like jQuery, boostrap, etc.

[Project Configuration]
TypeScript compiler = tsc

tsconfig.json
  TypeScript compiler options for your project
  a folder containing (recursively) .ts files should have a tsconfig.json file at the root
  when you compile/run a TS file, the compiler will automatically search upward for it in the ancestry
    if it doesn't find one, it will still run (with some default options)
  you can make a new one (with helpful comments) with 'tsc --init'
    frameworks like Angular also make their own for new projects

  baseUrl = base path for imports (relative to the tsconfig.json)
  outDir = where to put the output build artifacts (eg. js files)
  strict = enable to get a bunch of strict checks like nullness
  noImplicitOverride = requiring override keyword to override a method
  target = which version of JS to emit code for
    this affects what code you can write as well (eg. which bulit-in data structures you can use)

package.json
  NPM package information for your project
    searched upward similarly to tsconfig.json
  used in conjunction with node_modules folder to find packages you import in your code
  you can  make a new one with 'npm init'

NVM = for side-by-side node versions (similar to conda for Python)
  nvm install node
    make environment with latest version and make it the default
  nvm install node [version]
  nvm use [version]
  nvm which [version]
    to see physical install location
  nvm deactivate

  npm packages from environments will go into subfolders of ~/.nvm

NPM = Node Package Manager
  comes bundled with node itself
  installing node (possibly via nvm) is first step before doing any projects
  then you can use it to install Angular, React, whatever you want

  npm install somepackage
    installs a package into the local project (based on working directory and search upward)
    manages package.json and node_modules folder
  npm install --save somepackage
    same thing (save option used to be required, so you'll see it online)
  npm install --save-dev somepackage
    install a package as a dev dependency
    available during development but not in production
    eg. chrome devtools integrations, ambient types, etc. might be here
  npm install
    based on existing package.json, install all local modules into node_modules folder
    you have to do this when you sync a package.json from GitHub, for instance
  npm install -g typescript
    install a package globally so that it's always available
    often used for ones that have command-line scripts
    local packages shadow global ones
  npx somecommand
    runs an npm package command from the latest version remotely without having to install globally
    if you have the package and it's the latest version, it will use yours for efficiency
  npm run scriptName
    run a script from local package
  npm run -g scriptName
    run a script from global package
  
  Some Useful Packages
    typescript
      the typescript compiler
      install globally
    @angular/cli
      for Angular projects
      install globally
    ts-node
      gives you a TS repl
      install globally
    prettier
      code formatter
    eslint
      linter

Node
  node
    to get JS repl
  node file.js
    execute a file at the terminal

tsc
  tsc --init
  tsc myfile.ts
    creates myfile.js

  does not do minification, optimization, or polyfills
  you need other tools like WebPackage, Babel, etc. for that
  that's why ES target in tsconfig.json is so important

ts-node
  ts-node myfile.ts
    directly execute ts file
    probably calls tsc to compile?

** see Setup notebook for more details on environment setup **

[stdlib]
unlike Java, Python, C++, etc. there are no imports needed for standard library symbols
  imports are for other TS/JS files and node packages
most standard library symbols come from JS
  TS adds generics to some of them for type safety, but the underlying raw type is from JS
  also it adds ambient declarations for type safety
  but for instance, new Date() already works in JS because object creation is from there

a lot of built-in functions, collections, primitives, etc. already discussed above in various places

Browser DOM
  these are global objects you can automatically access in both JS and TS
    though TS adds strong typing to them so that you will use them safely
  to add your own members to them JS-style in TS, you can use declaration merging on their types
    then TS will let you set the fields you want
  it's worth noting that the below types exist in JS by the same name, but TS adds ambient declarations
    this is to make you code in a type-safe way so that when it compiles down to JS, you have less bugs
  
  window: Window (default target of 'this')
    contains all global variables defined with 'var' (old-fashioned not recommended way)
    also contains document, location, etc. as properties
    properties added to window become globally available too
      eg. setTimeout() actually lives in window, and you can call setTimeout() without putting window. in front
    you can check for existence (eg. to see if script or browser) with 'typeof window === undefined' or similar
  document: Document
    the main starting point for DOM manipulation
    
    Getting Single Elements
        const element: HTMLElement|null = document.getElementById('myId');
        if (element) {
          const buttonElement: HTMLButtonElement = element as HTMLButtonElement;
          console.log(buttonElement.value);
        }

        const myDiv = document.querySelector("#myDiv") as HTMLDivElement; // if no strict null checks option
        if (myDiv) {
            // TypeScript knows `myDiv` is a div element
            myDiv.style.backgroundColor = "blue";
        }
    Getting Multiple Elements
        document.getElementsByClassName('myClass')
        document.getElementsByTagName('myTag')
        document.querySelectorAll('myTag.myClass')
        element.children

        these return array-like objects that aren't true arrays
          can make into true arrays with Array.from()
        return empty collection instead of null when not found

    Events
        myDiv.addEventListener('click', (event) => {
          event.preventDefault(); // or stopPropagation, whatever you want
          console.log('clicked!');
          console.log(e.target);
        });

        element.dispatchEvent(event) to dispatch an event yourself
          can be one of the built-in ones or your own
          an event has a name and an event object with properties (like addEventListener shows)
          eg. const myEvent = new CustomEvent('myCustomEvent', {
                  detail: { message: 'Hello from custom event!' }
              });
    
        myDiv.removeEventListener('click', fn); // fn must be same reference you added for this to work
          if an element is remove from the DOM, it is considered good practice to remove the listeners
          although modern browsers SHOULD be able to figure this out
            if they don't, it would be a memory leak
          the lambda could remove itself when it's done if it's a one-time thing
            use its own name as the reference to pass in
    
    Adding DOM Elements
      const newDiv: HTMLDivElement = document.createElement('div');
      newDiv.id = 'new-div';
      newDiv.textContent = 'This is a new div.';
      newDiv.className = 'my-class';

      document.body.appendChild(newDiv); // to append top level

      const container = document.getElementById('container');
      if (container) {
          container.appendChild(newDiv);
      }

    Removing DOM Elements
      element.parentNode.removeChild(element)
      element.remove() // more direct, but not supported in IE
        polyfill can fix that though
  location: Location
    for dealing with url and host type stuff

    href = current page url
      can also use toString()
    various properties for components of the URL, such as hostname, search, port, etc.

    reload() to refresh the page
    replace(url: string) to navigate to another page without adding a back button entry
    assign(url: string) to navigate to another page with a back button entry
      you can also change location.href and do location.reload()

Math: static math functions you can call on numbers
  abs()
  ceil(), floor(), round()
  max(), min() [variadic]
  random() [0,1)
  sqrt()
  pow(base, exp)
  sine(), cos()
  log(x), log10(x), exp(x)

Date
  const date = new Date()
  date.getMonth(), date.getYear(), date.getTime(), etc.
  date.toDateString()
  date.setMonth(), etc.

setTimeout(fn, delay = 0)
  run fn after a delay in milliseconds (minimum)
  if 0, it will just go into the queue of tasks to be dispatched by the browser's event loop (after what is already in there)
  this is useful for when you want to do something after the current event handling is completed properly
    esp. useful in things like Angular change detection
    or if your code will take a long time and you want to let the UI continue to function
  this is part of Java's simulated multithreading

Promise<T>
  const promise: Promise<string> = new Promise((resolve, reject) => {
    // do some kind of async code
    // that calls resolve() with a string
    // or reject() with an error string

    // eg. used in a lambda passed to an HTTP handler
    // eg. used in a setTimeout() lambda
    // eg. await another promise
  });

  aside from creating your own promises, you will often get them from sever calls and such

  // chainable
  promise.then((data) => transform(data))
         .then((transformedData) => transformedData.x)
         .catch((error) => handleError(error));

async/await keywords
    JS syntactic sugar for chaining promises as if they are synchronous

    async function(x: number): Promise<string> {
      const y = await someOtherAsyncFunction(x);
      return (x + y).toString();
    }

    'async' makes a function that returns a promise into an async function
      still have to explicitly return promise in signature
    in the body, you return the synchronous value instead of a promise
    in the body, you can use 'await' to have it continue when another promise resolves
      this is part of the state machine magic the 'async' keyword provides
    other 'async' functions can 'await' your function (or promise)
    functions that are not 'async' can still call your function, but they must directly deal with the promise

Ajax
  XMLHttpRequest is the built-in browser type for making calls to the server
  it is a bit ugly, and usually you will want to use libraries that wrap it better
    eg. with promises, etc.
  frameworks like Angular have their own ways to do it too
    eg. in Angular, HttpClientService helps you get JSON objects from the server
      returns an observable
  there is a proposal to add Observable (from rxjs) directly to the JS language
    it is still just a proposal and may not happen for a long time if ever

JSON
  JSON.stringify() and JSON.parse() as described in Strings above

[Decorators]
similar to Python, you can make a function that takes a decloaration and wraps it
the interface is more complicated - look it up when needed
important thing to know is there are decorators you can import (without the @) and use with @
  eg. @log f() {}
  eg. @ViewChild() formGroup: FormGroup;
    Angular people like to use () even when no args, for consistency with the ones that have args
  eg. @SomeDecorator(option1, option2) x: MyClass;
NOTE: this is a uniquely TypeScript feature
  the emitted JS defines the thing being decorated first and then redefines it by a calling the wrapper function
    even though TS won't let you do something like that yourself, it uses it when needed to implement things

[JSDoc]
** see JSDoc notebook for full working example **
similar to docstrings in other languages

/**
  * Adds two numbers.
  * @param {number} a - The first number.
  * @param {number} b - The second number.
  * @returns {number} The sum of the two numbers.
  */
function add(a, b) {
  return a + b;
}

[Testing]
Jasmine
  describe(), it(), etc.
  test files usually in 'specs' folder
Karma
  for running in browser (inc. Jasmine tests)
Angular/Protractor
  based on Jasmine and Karma plus its own stuff like TestBed
  test files usually in same folder as code
Selenium
  browser interaction and screenshots
screendiffs require 3rd party libraries

[JavaScript]
for the most part you can assume JS is like TS except for the things mentioned here
  several differences are mentioend throughout this doc and some may not have made it into this section
in general, JS is much more similar to Python when you remove the TS restrictions and additions
a few operations that are banned in TS are allowed in JS
  eg. adding members to instances at runtime, redefining symbols, etc.
  it is more dynamic and duck-typed like python
TS adds type annotations and generics, which are both swallowed by the compiler
  the JS version uses raw types and no annotations
some JS operations can be done in TS but you have to use things like 'any' to make it happen
  eg. in JS when you make an array, it doesn't care what you add to the array because no type annotations
there are no access modifiers on classes
  or any feature that relies on that, such as Parameter Properties in constructors
  that is why TS has to make everything public by default
there is no 'readonly' modifier for properties
some OOP features only exist in TS:
  interfaces
  abstract
  enums
note that a lot of features you might think are added by TS are actually JS
  eg. classes (which are newer), static, constructor, string interpolation, data structures, map(),
      get/set properties, etc.
properties insisde classes can be set either in the body (with no type, like you do in TS with type inference)
  or in constructor since JS lets you add properties at runtime (python style)
  even just saying this: x; // is a statement, though x will be undefined
non-existent variables being read from an object will not throw - they will read as undefined
  TS normally doesn't allow you to compile that
the old style syntax for doing classes, which you don't need anymore but might see people doing:
    function Person(name) {
      this.name = name;
    }
    Person.prototype.greet = function() {console.log(this.name);}
    
    // Person() calls the function called Person
    // but the new keyword in front tells JS to treat it as an object and bind 'this'
    // the prototype of the new object comes from the function itself so that it will behave virtually
    const alice = new Person('Alice');
    // because we added greet to the prototype of the class function, it is callable from the instance
    // this is presumably dynamic like Python
    alice.greet();
purely for stylstic convention reasons, for some reason JS people like to assign lambdas to variables
  rather than write 'function' declarations

[jQuery]
3rd party library for JS DOM querying
can reference it via CDN
available by default in Chrome Devtools
plural vs. singular elements are handled transparently
  the same call will apply to either 1 or all elements matching

$(document).ready(() => {})
  protect the code inside from running before the whole DOM is ready

$('#myId')
  find an element by CSS selector
$('#myId').text('new text')
  change its text
$('#myId').css('color', 'blue')
  change a CSS property

$('#myId').click(fn);
  add event handler

$('#myId').hide(500);
  hide over the course of 500 milliseconds

$('.myClass').eq(1).css('color', 'blue');
  only apply to the 2nd element instead of all

let myElement = $('myClass')
myElement.get()
  array of HTMLElement
myElement[0]
  single HTMLElement
myElement.get(0)
  single HTMLElement

$('myClass').append('<div>blabla</div>');
  and various other ways to append, prepend, etc.

$.ajax({url, type: 'GET', success: fn, error: fn});

** see jQuery notebook for more examples **

TypeScript
  if you install jquery and @types/jquery, then you can import * as $ from it
  then you use it as usual
  but in addition, there are types
  eg. the return type of $() is JQuery

[Angular]
templates + styles (encapsulated via shadow DOM and/or extra classes/selectors)
templates compiled into JS code to build DOM
TS code as well
Modules
bootstrapping
dependency injection
jasmine testing
reactive forms

** see Angular notebook for details **
  the framework is too massively huge to cheat sheet-ify it here
  has tutorial examples with commit links, etc.

[React]
React = unidirectional flow, virtual DOM (always being "rebuilt")
dynamically returning templated HTML code from functions
Redux for state management
    and built-in state management functions
virtual DOM used to diff and make less frequent updates to real DOM
TSX and JSX syntax

[CSS]
** see Angular notebook CSS section for full example **

[SCSS]
** see Angular notebook SCSS section for full example **
the main headline feature is the nesting and &

[Flexbox and Grid]
** see Angular notebook Flexbox and Grid sections for full examples **
grid is better for 2D layouts

[HTML]
** see Angular notebook HTML and HTML Forms sections for full examples **
key point is <script> tags to put JS code in

[ToDo]
recursive lambdas (in all 3 languages)
https://www.npmjs.com/package/typescript-collections
https://www.reddit.com/r/leetcode/comments/wuxw3s/how_do_you_make_a_priority_queue_in_javascript/
https://www.collectionsjs.com/sorted-map
other npm packages: heap, double-ended-queue
localStorage.setItem(key, value)
JSON.stringify() second param = key list
inheritance and prototypes
python same issue with calling methods on literals?
