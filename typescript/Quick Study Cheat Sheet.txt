** rewrite of this sheet is in progress **
** steps:
** 1. go through notebooks again in detail and merge into what's here (mostly replace, but make sure nothing missed)
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (since JS/TS has some in common with python note in common with Java)
** 4. also include: pure JS, HTML, CSS/SASS, Dom, Angular, React
** 5. any other popular libraries
** 6. include info on latest versions (and mark current version here)

[Variables]
boolean (true/false)
number (both float and integer)
  all the usual literals (inc. exponential, hex, etc.)
  built-in symbols for dealing with floating point:
    NaN
    Infinity
    -Infinity
    isNan()
    isFinite()
string (lowercase)

let x: number = 5; // mutable
const x: number = 5; // immutable
let x = 5; // type inference (the variable is typed, but it was inferred at compile-time)

let point: {x: number, y: number} = {x: 10, y: 20}; // custom object
let obj: object = {x: 10, y: 20}; // works because all objects inherit object
let point: {x: number, y: number} = {x, y}; // Shorthand Property Names
  x and y are used as both the keys and the variables to get the values from
  if the variables were called something else, you'd still have to say x: somethingElse and y: somethingElseElse

let a: any = 5;
  a could be any type
  often used for compatibility with JavaScript code where anything goes
  a could be reassigned a different type of object arbitrarily
  you can do whatever operations you want on it, like you're in JavaScript land
let a: unknown = 5;
  similar to any, but you can't do any operations on it that are type-specific
  you have to convert to a type first (eg. via type narrowing)
  otherwise, it's similar to using object directly

let n: null = null; // the type of null is null
let u: undefined = undefined; // the type of undefined is undefined

let n: never = f(); // the function is not expected to return (eg. because always throws)

let x: number | string;   // type unions
  can at any time assign a number or string (and back and forth) to the variable
let x: number | null;   // nullable type via union
let x: number | undefined;

static variables only exist as class members (no local statics)

scoped like Java, not Python
  block-scoped, not function-scoped

primitives are mutable variables (while the objects themselves are immutable)
  as in most languages
objects are mutable reference types (as in most languages)
  let obj1 = {x: 10, y: 20};
  let obj2: {x: number, y: number} = obj;
  obj2.x = 100;  // this changes obj1 (a reference, not a copy)
structural typing does not imply copying - just matching
strings are immutable references like in Java, C#, etc.
collections, including arrays, are also mutable reference types

Nullability
  let x: number;    // no value specified
    x is actually undefined, even though we didn't say it could be undefined with a type union!
  let x: number|undefined;  // same thing, but other code will be able to tell it could be undefined better
  let x: number|null = null;  // explicit nullability specification
  if (x === null || x === undefined) {...}
  note that both null and undefined are real valeus from JavaScript and === will work even if the type is wrong

Type Alias
    type Person = {
      name: string;
      age: number;
      email: string;
    };

    type BetterPerson = Person;

    const x: BetterPerson = {name: "bob", age: 20, email: "bob@bob.com"};

Enums
  regular enums and string enums
    eg. can just give values with no = to auto-assign like in other c-like languages
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
  let playerDirection: Direction = Direction.Up;

[Collections]
let a: number[] = [1, 2, 3, 4, 5];
let a: Array<number> = [1, 2, 3, 4, 5];
a.length
a.push(val)
a.pop()
const [first, second, ...rest] = a;
const a = [...firstList, ...secondList];
filter and map (returns array)
[][]

let o: {a: number, b: string} = {a: 10, b: 'hi'};

let tuple: [number, string] = [10, 'hi'];
    tuple[0] and tuple[1]
    tuples are mutable (not like python)

let s: Set<number> = new Set([1, 2, 3, 4, 5]);
    add(), has(), delete(), size()
let m: Map<string, number> = new Map([
    ["a", 10,],
    ["b", 20,],
])
    set(), get(), has(), delete(), size(), clear()
    iterate over [key, value]


let a: ReadonlyArray<number> = [1, 2, 3, 4, 5];
also ReadonlyMap, etc.
not truly readonly, just enforces the usage (like C++ const)

spread operator (see Operators)

[Strings]
s + t + 3
  concatenates two strings and a number (converted to string)

`Hello, {name}!` // should be variable in current scope
'' and "" are both for string (char is just a single character string, not special thing)

s.length
s[0], s.charAt()
s = s.toUpperCase()

console.log()
console.error()
console.warn()
console.info()

s = n.toFixed(2) // format a number as a fixed-point decimal string

/regex syntax/
regex.test(), matches(), etc.
str.replace(regex, otherText)

JSON.stringify(), JSON.parse()

[Operators]
all the usual arithmetic, arithmetic assignment, bitwise, and comparison operators from c-like language
  and ternary operator
&&, ||, ! for conditions

type narrowing (a unique feature of TS)
  if (typeof x === "string") {
    let y: string = x;  // legal because x is type string in this scope
  }
  if (x !== null) {
    // in here, you can treat x as not nullable
  }

== for a number or string will try to coerce one to match the other (eg. number to string) before comparison
  it comes from JavaScript and causes a lot of bugs
=== (also from JavaScript) does not do this coercion
  thus, it is called strict equality
  it is mostly (and often mandatorily) recommended instead of == in TypeScript
both == and === will check value equality for numbers and strings
both == and === will check reference equality (not value) for reference types like objects and arrays
=== works correctly with null or undefined (and similar) as well
  you are permitted to do the === check even if the type says it can't be null or undefined
!= and !=== correspond to == and ===
for value equality in a custom object, you have to implement .equals() for the class
arrays don't have .equals(), but you can use JSON.stringify(arr) === JSON.stringify(otherArr)

Casting/Coercion
  x as OtherType // compiler will keep you honest
    will only do things like any to a specific type or polymorhpic stuff
    wil not do things like string to number
    for things the compiler can't see are wrong, you may get unexpected behavior
      eg. let s: string = "hi";
          let o: any = s;
          let b: boolean = o as boolean;
          console.log(b);
          // you expect it to print a boolean, but it prints a string
      this is because 'as' is a pure TypeScript compiler feature
        it is removed entirely in the emitted JavaScript code
  let y: number = +s; // coercion to number via unary + operator
    eg. string to number
    will throw exception if bad format
  n.toString()
    but 10.toString() not allowed because of parsing issues
  
?? nullish coalescing
  x ?? "hi"
    will be x unless x is null or undefined, then it will be "hi"
  note a general truthiness check - just null|undefined check

! non-null assertion
  let x: number = nullableNumber!;
    TS doesn't actually do anything at runtime here (including throwing anything)
    you are just telling the compiler to trust you that the thing cannot be nullable here anymore
    you could very easily be wrong and have null at runtime when the compiler thinks you can't (be careful!)
      could end up causing other bugs and throwing other kinds of errors at runtime

? safe-navigation operator (also called optional chaining, or Elvis operator)
  a?.b?.c?.d
  if any link in the chain is nullish (null|undefined), stops and returns that

typeof x
  gets a string representing the primitive type of an object (in JS)
  note it's not a function call (no parenth)
    eg. typeof x === "string"
  because it's so primitive, it doesn't work for polymorphism in class hierachy
    all reference types except string are seen as 'object', including arrays
    even null is 'object' (but 'undefined' is 'undefined')
  number, boolean, and string work as you'd expect (it's very useful for these specific types)

x instanceof MyClass
  boolean check of whether the class is in the inheritance chain of x
  it works because JavaScript uses prototype inheritance, so JS will check the prototype chain for the class object
  but it won't detect structural typing, so be very careful relying on this!

"fn" in y
  membership check
  if y is an object, this will check if it has a method or variable called 'fn'
  may be defeated by minification

Truthiness
  !! and ! are opposites
    !! makes value into boolean based on truthiness, ! does same but negates it
  falsey: null, undefined, 0, "", NaN, false
  truthy: empty collections, empty arrays, empty objects, anything else
  boolean operators like && and || return actual values (not boolean conversion)
    they evaluate the conditions in terms of truthiness (as with !! and !)
    and then do short-circuiting based on that
    then the last value seen is the one returned (the original value, not the boolean)
  you can use || as a truthiness coalescing operator
  statements like if() do an impliict truthiness conversion too
    for instance, you can do if (myIntValue && myStringValue)
    but your linter and coding conventions may wish you to use !! to be more explicit

Spread Operator
  const a = [1, 2, 3];
  const b = [...a, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

semicolons are technically optional
  JS people don't like them
  TS people like them
  leaving it out can actually ruin the parsing of some multi-line statements

[Control Flow]
try {
}
catch (error) {
}
finally {}

for (let i = 0; i < 5; i++) {}
for (const x of arr) {} // for in is discouraged because unexpected behavior

function* lazyList(limit: number): IterableIterator<number> {
    let i = 0;
    while (i < limit) {
      yield i++;
    }
  }

[Functions]
function add(x: number, y: number): number {
    return x + y;
}

// Optional parameters
  function greet(name?: string): void {
    if (name) {
      console.log(`Hello, ${name}!`);
    } else {
      console.log("Hello, stranger!");
    }
  }

greet(); // Output: Hello, stranger!
greet("John"); // Output: Hello, John!

// Default parameters
  function power(base: number, exponent: number = 2): number {
    return Math.pow(base, exponent);
}

function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

// Named arguments via anonymous class
function greet({ name, age }: { name: string; age: number }): void {
    console.log(`Hello, ${name}! You are ${age} years old.`);
  }

greet({ name: "John", age: 30 }); // Output: Hello, John! You are 30 years old.

// Overloading
// to overload by # params, use optionals
function processData(data: string): void;
function processData(data: number): void;
function processData(data: string | number): void {
    if (typeof data === "string") {
      console.log(`Processing string data: ${data}`);
    } else if (typeof data === "number") {
      console.log(`Processing numeric data: ${data}`);
    }
  }

nested functions allowed but uncommon due to multiline lambdas
    unlike Python

return type can be ommited to let it be inferred
    eg. void, esp. private method

never is a special return type that means the function never returns
  eg. if the body throws

[Functional]
const addNumbers = (a: number, b: number): number => a + b;
let greetFunc: (name: string) => void;

fat arrows
all the usual combos

closures by reference (except loop variables)

_, __, etc.

fn.bind(thing)
    binds 'this' in the context of fn to point to the object thing
    eg. in a lambda that uses 'this' but was not returned from the target class
fn.bind(thing, a, b)
    can also bind arguments so don't have to pass them on calls

fn.apply(thing, [a, b])
    calling fn with array of args
fn.call(thing, a, b)
    calling fn with positional args

map, reduce, and filter available on arrays

use extra () to return object from lambda

[Classes]
let x! string;
    treat as not nullable in a class even though not initialized just yet
    promising to set before read (eg. in c'tor)
let x? string;
    treat as optional in class (undefined if missing
    same as doing let x: string | undefined

type Person = {
    name: string;
    age: number;
};
type BetterPerson = Person;

"public" by default because of JS behavior
need "this" to access everything (never implicit)
    but not passed into siganture like in python
fields can be declared in the body or in the c'tor by providing an access modifier
    no 'let' or 'const' for fields
    'readonly' for locking
no function keyword for methods
all methods virtual (or static)
    override keyword (newer) (configurable, on for Angular by default)
need 'new' keyword to create
nullable declarations are kind of just on faith

has interfaces, but can also "implements" a class to treat it as interface

// Instance property with getter and setter
get home(): string {
    return this.habitat;
}
set home(home: string) {
    this.setHabitat(home);
}

// breed is a 'parameter property' (declared in constructor only)
// this is often used for services and other injected things
constructor(name: string, age: number, private breed: string) {
    super(name, age, "Dog");
    // Don't need to do anything with breed here (it's assigned already)
}

[Generics]
functions are normal instead of weird like Java
can take primitives as well as reference types

[Imports]
export const message = 'hello';

// The path is relative to this TS file,
// not the working directory!
// The ./ is required in this case!
import {message} from './importable';

import {message as msg} from './importable';

import * as importable from './importable'

console.log(importable.message);

import {MyType} from './importable2';

const m = new MyType();

export * from './importable4';
export * as otherThing from './importable4';

Ambient Declarations ('declare')
  // This is only here for demonstration.
  // If you try to run the file, it will
  // fail because there are no defintions
  // for the ambient declarations here.

  // Declare an ambient variable
  declare const myVariable: string;

  // Declare an ambient function
  declare function myFunction(arg: number): void;

  // Declare an ambient class
  declare class MyClass {
    constructor(arg: string);
    method(): void;
  }

  // Use the ambient variable, function, and class
  console.log(myVariable);
  myFunction(42);
  const myInstance = new MyClass('example');
  myInstance.method();

ambient declarations (eg. in a .d.ts for a library) let you compile safely
    then the JS code produced can be patched with other JS code to call those Libraries

[stdlib]
** no imports needed **

Math
Date
Promise<T>
setTimeout(() => {})
XmlHttpRequest for ajax stuff

async/await keywords
    mark function as async and have it explicitly return a Promise<T>
    inside the function, pretend it returns T
    can await a promise inside the function
    other async functions can await your function

[Angular]
templates + styles (encapsulated via shadow DOM and/or extra classes/selectors)
templates compiled into JS code to build DOM
TS code as well
Modules
bootstrapping
dependency injection
jasmine testing

[CSS]
/* Apply to all elements */
* {
  box-sizing: border-box;
}

/* Tag selector */
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  margin: 0;
  padding: 0;
}

/* ID selector */
#myButton {
  background-color: #008cba; /* Blue background */
  color: white; /* White text */
  border: none; /* No border */
  padding: 15px 32px; /* Padding */
  text-align: center; /* Centered text */
  text-decoration: none; /* No underline */
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer; /* Pointer cursor on hover */
}

/* Class selector */
.myClass {
  color: red;
}

/* Descendant selector */
nav ul {
  list-style-type: none; /* No bullets */
  padding: 0;
}

nav ul li {
  display: inline; /* Display inline */
  margin-right: 10px; /* Margin to the right */
}

/* Child selector */
nav > ul {
  border-bottom: 1px solid #ccc;
}

/* Adjacent sibling selector */
h1 + p {
  font-size: 1.2em;
}

/* General sibling selector */
h1 ~ p {
  color: green;
}

/* Attribute selector */
input[type="text"] {
  padding: 5px;
  border-radius: 4px; /* Rounded borders */
  border: 1px solid #ccc;
}

/* Pseudo-class selector */
a:hover {
  color: orange;
}

/* Pseudo-element selector */
p::first-letter {
  font-size: 2em;
  color: red;
}

/* Media query */
@media (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

[HTML/DOM]
<form id="myForm">
        <label for="name">Name:</label><br />
        <input type="text" id="name" name="name" required /><br />
        <label for="email">Email:</label><br />
        <input type="email" id="email" name="email" required /><br />
        <label for="pwd">Password:</label><br />
        <input type="password" id="pwd" name="pwd" required /><br />
        <input type="submit" value="Submit" />
      </form>

<script>
      // Prevent form from being submitted
      document
        .getElementById("myForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();
          console.log("Form submission prevented.");
        });

      // Log a message when the button is clicked
      document
        .getElementById("myButton")
        .addEventListener("click", function (event) {
          console.log("Button clicked.");
        });
    </script>

[React]
React = unidirectional flow, virtual DOM (always being "rebuilt")
dynamically returning templated HTML code from functions
Redux for state management
    and built-in state management functions
