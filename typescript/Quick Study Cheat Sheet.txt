** rewrite of this sheet is in progress **
** steps:
** 1. go through notebooks again in detail and merge into what's here (mostly replace, but make sure nothing missed)
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (since JS/TS has some in common with python note in common with Java)
** 4. also include: pure JS, HTML, CSS/SASS, Dom, Angular, React
** 5. any other popular libraries
** 6. include info on latest versions (and mark current version here)

[Variables]
boolean (true/false)
number (both float and integer)
  all the usual literals (inc. exponential, hex, etc.)
  built-in symbols for dealing with floating point:
    NaN
    Infinity
    -Infinity
    isNan()
    isFinite()
string (lowercase)

let x: number = 5; // mutable
const x: number = 5; // immutable
let x = 5; // type inference (the variable is typed, but it was inferred at compile-time)

let point: {x: number, y: number} = {x: 10, y: 20}; // custom object
let obj: object = {x: 10, y: 20}; // works because all objects inherit object
let point: {x: number, y: number} = {x, y}; // Shorthand Property Names
  x and y are used as both the keys and the variables to get the values from
  if the variables were called something else, you'd still have to say x: somethingElse and y: somethingElseElse

let a: any = 5;
  a could be any type
  often used for compatibility with JavaScript code where anything goes
  a could be reassigned a different type of object arbitrarily
  you can do whatever operations you want on it, like you're in JavaScript land
let a: unknown = 5;
  similar to any, but you can't do any operations on it that are type-specific
  you have to convert to a type first (eg. via type narrowing)
  otherwise, it's similar to using object directly

let n: null = null; // the type of null is null
let u: undefined = undefined; // the type of undefined is undefined

let n: never = f(); // the function is not expected to return (eg. because always throws)

let x: number | string;   // type unions
  can at any time assign a number or string (and back and forth) to the variable
let x: number | null;   // nullable type via union
let x: number | undefined;

static variables only exist as class members (no local statics)

scoped like Java, not Python
  block-scoped, not function-scoped

primitives are mutable variables (while the objects themselves are immutable)
  as in most languages
objects are mutable reference types (as in most languages)
  let obj1 = {x: 10, y: 20};
  let obj2: {x: number, y: number} = obj;
  obj2.x = 100;  // this changes obj1 (a reference, not a copy)
structural typing does not imply copying - just matching
strings are immutable like in Java, C#, etc.
  but they are not reference types!
collections, including arrays, are mutable reference types

Nullability
  let x: number;    // no value specified
    x is actually undefined, even though we didn't say it could be undefined with a type union!
  let x: number|undefined;  // same thing, but other code will be able to tell it could be undefined better
  let x: number|null = null;  // explicit nullability specification
  if (x === null || x === undefined) {...}
  note that both null and undefined are real valeus from JavaScript and === will work even if the type is wrong

Type Alias
    type Person = {
      name: string;
      age: number;
      email: string;
    };

    type BetterPerson = Person;

    const x: BetterPerson = {name: "bob", age: 20, email: "bob@bob.com"};

Enums
  regular enums and string enums
    eg. can just give values with no = to auto-assign like in other c-like languages
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
  let playerDirection: Direction = Direction.Up;

Interning
  only applies to strings, not numbers or anything else
  if you create a String() instead of string(), === will do reference comparison
    and be false even for same literal string
  otherwise, === will be true because of the shared pool of strings
    you don't usually need to worry about that

[Collections]
Literals
  only array and object have literals ([] and {})

Arrays
  let a: number[] = [1, 2, 3, 4, 5];
  let a: Array<number> = [1, 2, 3, 4, 5];

  a[0] // read-write
  a.length

  a.push(val) // append to end
  val = a.pop() // remove from end [treat like stack]

  b = a.slice(start, stop); // inclusive start, exclusive stop
    b is a COPY of a range of a

  array is iterable via 'for...of' (and normal for loop w/ length) construct
  can also use a.forEach((num) => {})

  const a = [...firstList, ...secondList]; // spread operator (in-place)

  const [first, second, ...rest] = a; // destructuring
    rest is another array here
    use _, __, etc. for don't care values
      const [first, _, ...rest] = a; // ignoring 2nd value

  a.filter() and a.map()
    both return an array, not some lazy stream like Python
  
  [][] for multidimensional arrays
    nested [] just as you'd expect

Tuples
  similar to array, but fixed length and not homogeneous type
  let tuple: [number, string, boolean] = [10, 'hi', true];
      tuple[0] (read-write)
        not immutable like in Python
  tuple.length
  can destructure just like an array
    const [a, b, c] = tuple;
  can use 'for...of' like with arrays

Sets
  let s: Set<number> = new Set([1, 2, 3, 4, 5]);
      add(), has(), delete(), size()
  const s = new Set<number>();

  s.add(value);
  s.size // not a function for some reason
  s.has(value)
  s.delete(value)
  s.forEach((value) => {console.log(value);});
  s.forEach((value, index) => {}) // JS knows based on the lambda passed in
  use 'for...of' construct like with arrays

Maps
  let m: Map<string, number> = new Map([
      ["a", 10,],
      ["b", 20,],
  ])
  const m2 = new Map<string, number>();

  m.set(key, value)
  m.get(key)
    m.get(key) || defaultValue
  m.has(key)
  m.delete(key)
  m.size()  // # of keys
  m.clear()

  for (const [key, value] of m) {
    console.log(key);
    console.log(value);
  }
  also can use m.keys(), m.values(), m.entries()

Objects (as structs)
  let o: {a: number, b: string} = {a: 10, b: 'hi'};

  type Entry = { // note similarity to C struct syntax (plus =)
    a: number;
    b: string;
  };
  let o: Entry = {a: 10, b: 'hi'};

  interface Entry {
    a: number;
    b: string;
  }
  let o: Entry = {a: 10, b: 'hi'};  // equivalent to the 'type' version

  let o = {a: 1, b: 2, c: 3}; // we will ignore c
  let {a, b} = o;  // destructure into variables called a and b with those values from the object
  let {a: x, b: y} = o; // renaming the variables to x and y locally

  keys can be quoted or unquoted (or not even strings at all)
    const obj = {a: 1, "b": 2, true: false, 1: "One",};
    obj.a, obj.b, obj.true (actually a string key), no way to do obj.1
    to access an object field using a string (or other type of thing) as the key:
      obj["a"], obj["b"], obj["true"], obj[1] (not a string)
    unquoted string keys in an object may be subject to minification (and their usages as well)
      the minifier may be smart enough to not minify it (but maybe you want it to)
  
  Object.keys(o), Object.values(o), Object.entries(o)
    to iterate over fields in an object as if a map

Objects (as classes)
  'class' instead of 'interface' and can have constructor, methods, etc.
  created with 'new' instead of structurally like with structs
  covered in detail in "Classes" section below

Readonly
  let a: ReadonlyArray<number> = [1, 2, 3, 4, 5];
    also ReadonlyMap, etc.
  not truly readonly, just enforces the usage (like C++ const)

[Strings]
strings are immutable (mutation functions return new copy)
  but they are not reference types like in other languages!
there is no char type - a character in a string is a single-item string (same type)
strings are based on unicode and are not null-terminated

s + t + 3
  concatenates two strings and a number (converted to string)

'' and "" are both for string (char is just a single character string, not special thing)
`Hello, {name}!` // 'name' should be variable in current scope
  backtick quote
  variable can be a number too!
  the thing in {} can also be a TS expression instead of just a name!
`` is a multiline string (backtick quote)
  if you don't have a newline it will just be single line, but you can have newlines in it
    no need to escape the newlines
to use a normal string with an object of params, you have to do it yourself using string.replace()
  there is no built-in way, but many frameworks have it
there are no raw strings

s.length
s[0], s.charAt() // read-only
  these are single-character strings!
  there is no char type
s.substring(start, stop) and s.slice(start, stop) // equivalent, just like array slicing
s.toUpperCase(), so.toLowerCase()
s.split(delim) gets a string[]
  can convert s to string[] of single-character strings:
    s.split('') // empty-string
s.replace(old, new)
  old can be a string or a regex pattern
s.includes(substr)
s.startsWith(substr)
s.endsWith(substr)

for...of iterates over characters (single-length strings)

Conversions
  s = n.toFixed(2) // format a number as a fixed-point decimal string
  parseInt() and parseFloat() to get numbers from strings
  +s // number to string via unary plus operator
  JSON.stringify() to make object into json string
  JSON.parse() to make json string into object
  n.toString() to get string from number
  o.toString() to get string from object (as it defines for itself)
    arrays do not have this
    set and map do not implement it properly

Base64
  btoa(original)
    gives a base64 encoded string
  atob(encoded)
    gives back original string from base64 encoding

console.log()
  console.log(a, b) logs both with space in between
  eg. console.log("field:", value);
  console.log(o) works on objects (will show keys-values) and built-in types
    much better than toString() and such
  output goes into debug console (eg. Chrome Devtools)
  console.log() for empty line
    can also use \n in strings
console.error()
  like console.log() but more serious (shows up red)
console.warn()
  less series than console.error()
console.info()
  similar to console.log()
there are color escape codes available too

Regular Expressions
  const pattern = /\d+/g
    makes a regular expression object directly using perl-like syntax
    no need for raw strings because already raw (unquoted)
    the // quotes it, but global flag comes after /
  pattern.test(text)
    true if a match anywhere in text
  matches = text.match(pattern)
    if you use /g flag, gets multiple matches as array of strings
    if you don't use /g flag, gets tuple with info about 1 match
  text.replace(pattern, replacement)
    replace all occurences of pattern with replacement
    can use $1, etc. for capture groups

[Operators]
all the usual arithmetic, arithmetic assignment, bitwise, and comparison operators from c-like language
  and ternary operator
  and pre and post increment/decrement
&&, ||, ! for conditions

type narrowing (a unique feature of TS)
  if (typeof x === "string") {
    let y: string = x;  // legal because x is type string in this scope
  }
  if (x !== null) {
    // in here, you can treat x as not nullable
  }

== for a number or string will try to coerce one to match the other (eg. number to string) before comparison
  it comes from JavaScript and causes a lot of bugs
=== (also from JavaScript) does not do this coercion
  thus, it is called strict equality
  it is mostly (and often mandatorily) recommended instead of == in TypeScript
both == and === will check value equality for numbers and strings
both == and === will check reference equality (not value) for reference types like objects and arrays
=== works correctly with null or undefined (and similar) as well
  you are permitted to do the === check even if the type says it can't be null or undefined
!= and !=== correspond to == and ===
for value equality in a custom object, you have to implement .equals() for the class
arrays don't have .equals(), but you can use JSON.stringify(arr) === JSON.stringify(otherArr)

Casting/Coercion
  x as OtherType // compiler will keep you honest
    will only do things like any to a specific type or polymorhpic stuff
    wil not do things like string to number
    for things the compiler can't see are wrong, you may get unexpected behavior
      eg. let s: string = "hi";
          let o: any = s;
          let b: boolean = o as boolean;
          console.log(b);
          // you expect it to print a boolean, but it prints a string
      this is because 'as' is a pure TypeScript compiler feature
        it is removed entirely in the emitted JavaScript code
  let y: number = +s; // coercion to number via unary + operator
    eg. string to number
    will throw exception if bad format
  n.toString()
    but 10.toString() not allowed because of parsing issues
  
?? nullish coalescing
  x ?? "hi"
    will be x unless x is null or undefined, then it will be "hi"
  note a general truthiness check - just null|undefined check

! non-null assertion
  let x: number = nullableNumber!;
    TS doesn't actually do anything at runtime here (including throwing anything)
    you are just telling the compiler to trust you that the thing cannot be nullable here anymore
    you could very easily be wrong and have null at runtime when the compiler thinks you can't (be careful!)
      could end up causing other bugs and throwing other kinds of errors at runtime

? safe-navigation operator (also called optional chaining, or Elvis operator)
  a?.b?.c?.d
  if any link in the chain is nullish (null|undefined), stops and returns that

typeof x
  gets a string representing the primitive type of an object (in JS)
  note it's not a function call (no parenth)
    eg. typeof x === "string"
  because it's so primitive, it doesn't work for polymorphism in class hierachy
    all reference types are seen as 'object', including arrays
    even null is 'object' (but 'undefined' is 'undefined')
  number, boolean, and string work as you'd expect (it's very useful for these specific types)

x instanceof MyClass
  boolean check of whether the class is in the inheritance chain of x
  it works because JavaScript uses prototype inheritance, so JS will check the prototype chain for the class object
  but it won't detect structural typing, so be very careful relying on this!

"fn" in y
  membership check
  if y is an object, this will check if it has a method or variable called 'fn'
  may be defeated by minification

Truthiness
  !! and ! are opposites
    !! makes value into boolean based on truthiness, ! does same but negates it
  falsey: null, undefined, 0, "", NaN, false
  truthy: empty collections, empty arrays, empty objects, anything else
  boolean operators like && and || return actual values (not boolean conversion)
    they evaluate the conditions in terms of truthiness (as with !! and !)
    and then do short-circuiting based on that
    then the last value seen is the one returned (the original value, not the boolean)
  you can use || as a truthiness coalescing operator
  statements like if() do an impliict truthiness conversion too
    for instance, you can do if (myIntValue && myStringValue)
    but your linter and coding conventions may wish you to use !! to be more explicit

Spread Operator
  const a = [1, 2, 3];
  const b = [...a, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

semicolons are technically optional
  JS people don't like them
  TS people like them
  leaving it out can actually ruin the parsing of some multi-line statements

[Control Flow]
'if/else if/else', 'while', 'do/while', and 'switch' work exactly like other c-like languages
'break' and 'continue' as well

'for' loops have these forms
  for (let i = 0; i < 10; i++) {} // typical C-style
  for (const item of arr) {} // like Java range-for but 'of' instead of :
  for (const index in arr) {} // not recommended because unexpected behavior

  for (const [keyOrIndex, value] of collection) {}
    works for a lot of collections (eg. map, array)
    also, can call .keys(), .values(), .entries() members to iterate over those specific things
    for objects, use Object.keys(obj), Object.values(obj), and Object.entries(obj)

  for await (const item of asyncCollection) {}
    for asynchronous items (wait for 1 at a time)
    eg. promises

try {
  throw new Error("Uh oh!");
}
catch (error) {
  // use instanceof operator to check type of exception
}
finally {}

Not Available: context management, asserts (have to use libraries)

[Functions]
function add(x: number, y: number): number {
    return x + y;
}

// Optional parameters
  function greet(name?: string): void {
    if (name) {
      console.log(`Hello, ${name}!`);
    } else {
      console.log("Hello, stranger!");
    }
  }

greet(); // Output: Hello, stranger!
greet("John"); // Output: Hello, John!

// Default parameters
  function power(base: number, exponent: number = 2): number {
    return Math.pow(base, exponent);
}

function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

// Named arguments via anonymous class
function greet({ name, age }: { name: string; age: number }): void {
    console.log(`Hello, ${name}! You are ${age} years old.`);
  }

greet({ name: "John", age: 30 }); // Output: Hello, John! You are 30 years old.

// Overloading
// to overload by # params, use optionals
function processData(data: string): void;
function processData(data: number): void;
function processData(data: string | number): void {
    if (typeof data === "string") {
      console.log(`Processing string data: ${data}`);
    } else if (typeof data === "number") {
      console.log(`Processing numeric data: ${data}`);
    }
  }

nested functions allowed but uncommon due to multiline lambdas
    unlike Python

return type can be ommited to let it be inferred
    eg. void, esp. private method

never is a special return type that means the function never returns
  eg. if the body throws

Generators
  function* lazyList(limit: number): IterableIterator<number> {
      let i = 0;
      while (i < limit) {
        yield i++;
      }
    }
  const l = lazyList(5);
  console.log(l.next().value);
    OR for (const item of l) {console.log(item);}
    OR const a = Array.from(l) // to make into eager array
  can send values into the .next() call just like python for two-way communication

[Functional]
const addNumbers = (a: number, b: number): number => a + b;
let greetFunc: (name: string) => void;

fat arrows
all the usual combos

closures by reference (except loop variables)

_, __, etc.

fn.bind(thing)
    binds 'this' in the context of fn to point to the object thing
    eg. in a lambda that uses 'this' but was not returned from the target class
fn.bind(thing, a, b)
    can also bind arguments so don't have to pass them on calls

fn.apply(thing, [a, b])
    calling fn with array of args
fn.call(thing, a, b)
    calling fn with positional args

map, reduce, and filter available on arrays

use extra () to return object from lambda

[Classes]
let x! string;
    treat as not nullable in a class even though not initialized just yet
    promising to set before read (eg. in c'tor)
let x? string;
    treat as optional in class (undefined if missing
    same as doing let x: string | undefined

type Person = {
    name: string;
    age: number;
};
type BetterPerson = Person;

"public" by default because of JS behavior
need "this" to access everything (never implicit)
    but not passed into siganture like in python
fields can be declared in the body or in the c'tor by providing an access modifier
    no 'let' or 'const' for fields
    'readonly' for locking
no function keyword for methods
all methods virtual (or static)
    override keyword (newer) (configurable, on for Angular by default)
need 'new' keyword to create
nullable declarations are kind of just on faith

has interfaces, but can also "implements" a class to treat it as interface

// Instance property with getter and setter
get home(): string {
    return this.habitat;
}
set home(home: string) {
    this.setHabitat(home);
}

// breed is a 'parameter property' (declared in constructor only)
// this is often used for services and other injected things
constructor(name: string, age: number, private breed: string) {
    super(name, age, "Dog");
    // Don't need to do anything with breed here (it's assigned already)
}

no destructors/finalizers

[Generics]
functions are normal instead of weird like Java
can take primitives as well as reference types

[Imports]
export const message = 'hello';

// The path is relative to this TS file,
// not the working directory!
// The ./ is required in this case!
import {message} from './importable';

import {message as msg} from './importable';

import * as importable from './importable'

console.log(importable.message);

import {MyType} from './importable2';

const m = new MyType();

export * from './importable4';
export * as otherThing from './importable4';

Ambient Declarations ('declare')
  // This is only here for demonstration.
  // If you try to run the file, it will
  // fail because there are no defintions
  // for the ambient declarations here.

  // Declare an ambient variable
  declare const myVariable: string;

  // Declare an ambient function
  declare function myFunction(arg: number): void;

  // Declare an ambient class
  declare class MyClass {
    constructor(arg: string);
    method(): void;
  }

  // Use the ambient variable, function, and class
  console.log(myVariable);
  myFunction(42);
  const myInstance = new MyClass('example');
  myInstance.method();

ambient declarations (eg. in a .d.ts for a library) let you compile safely
    then the JS code produced can be patched with other JS code to call those Libraries

[stdlib]
** no imports needed **

Math
Date
Promise<T>
setTimeout(() => {})
XmlHttpRequest for ajax stuff

async/await keywords
    mark function as async and have it explicitly return a Promise<T>
    inside the function, pretend it returns T
    can await a promise inside the function
    other async functions can await your function

[Angular]
templates + styles (encapsulated via shadow DOM and/or extra classes/selectors)
templates compiled into JS code to build DOM
TS code as well
Modules
bootstrapping
dependency injection
jasmine testing

[CSS]
/* Apply to all elements */
* {
  box-sizing: border-box;
}

/* Tag selector */
body {
  font-family: Arial, sans-serif;
  background-color: #f0f0f0;
  margin: 0;
  padding: 0;
}

/* ID selector */
#myButton {
  background-color: #008cba; /* Blue background */
  color: white; /* White text */
  border: none; /* No border */
  padding: 15px 32px; /* Padding */
  text-align: center; /* Centered text */
  text-decoration: none; /* No underline */
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer; /* Pointer cursor on hover */
}

/* Class selector */
.myClass {
  color: red;
}

/* Descendant selector */
nav ul {
  list-style-type: none; /* No bullets */
  padding: 0;
}

nav ul li {
  display: inline; /* Display inline */
  margin-right: 10px; /* Margin to the right */
}

/* Child selector */
nav > ul {
  border-bottom: 1px solid #ccc;
}

/* Adjacent sibling selector */
h1 + p {
  font-size: 1.2em;
}

/* General sibling selector */
h1 ~ p {
  color: green;
}

/* Attribute selector */
input[type="text"] {
  padding: 5px;
  border-radius: 4px; /* Rounded borders */
  border: 1px solid #ccc;
}

/* Pseudo-class selector */
a:hover {
  color: orange;
}

/* Pseudo-element selector */
p::first-letter {
  font-size: 2em;
  color: red;
}

/* Media query */
@media (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

[HTML/DOM]
<form id="myForm">
        <label for="name">Name:</label><br />
        <input type="text" id="name" name="name" required /><br />
        <label for="email">Email:</label><br />
        <input type="email" id="email" name="email" required /><br />
        <label for="pwd">Password:</label><br />
        <input type="password" id="pwd" name="pwd" required /><br />
        <input type="submit" value="Submit" />
      </form>

<script>
      // Prevent form from being submitted
      document
        .getElementById("myForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();
          console.log("Form submission prevented.");
        });

      // Log a message when the button is clicked
      document
        .getElementById("myButton")
        .addEventListener("click", function (event) {
          console.log("Button clicked.");
        });
    </script>

[React]
React = unidirectional flow, virtual DOM (always being "rebuilt")
dynamically returning templated HTML code from functions
Redux for state management
    and built-in state management functions
