** most of these notes are summarized from notebooks, except for the interview & debugging stuff at the bottom & documentation & playgrounds at top **

[Documentation]
MDN for JavaScript
  for primitives, look at the boxed version for members
typescriptlang.org for TypeScript

[Version]
JavaScript = ECMAScript 2023
  ES6 was ECMAScript 6 in 2015
  1 per year since then 
TypeScript = 4.9 (Nov 2022)
  5.0 was released in early 2023, and as of now it's up to 5.3
  but I am not familiar with any of the new features
  interesting stuff like more sophisticatd type narrowing
  even in 4.9 there are a lot more features than I could reasonably go into in the notebooks and cheat sheet

[Playgrounds]
https://www.typescriptlang.org/play - TypeScript playground
  not just for testing TypeScript code
  can also show you the JS code emitted, which is useful for learning JS when you know TS
    or understanding better what concepts in TS actually mean
Javascript - just use Chrome Devtools, console tab
  you can enter a statement and hit Enter to run it
  will see the DOM of the current page and keep state
  even comes with jquery ready to use

[Variables]
boolean (true/false)
number (both float and integer)
  all the usual literals (inc. exponential, hex, etc.)
  built-in symbols for dealing with floating point:
    NaN
    Infinity
    -Infinity
    isNan()
    isFinite()
string (lowercase)
bigint (if need more than 54-bit integers)
  trailing n literal (eg. 'const x = 10n;`)

let x: number = 5; // mutable
const x: number = 5; // immutable
let x = 5; // type inference (the variable is typed, but it was inferred at compile-time)

let point: {x: number, y: number} = {x: 10, y: 20}; // custom object
let obj: object = {x: 10, y: 20}; // works because all objects inherit object

Shorthand Property Names
  let point: {x: number, y: number} = {x, y};
    x and y are used as both the keys and the variables to get the values from
    if the variables were called something else, you'd still have to say x: somethingElse and y: somethingElseElse
  let {x, y} = point;
  let {x: otherXVariableName, y: otherYVariableName} = point;

let a: any = 5;
  a could be any type
  often used for compatibility with JavaScript code where anything goes
  a could be reassigned a different type of object arbitrarily
  you can do whatever operations you want on it, like you're in JavaScript land
  also, you can arbitrarily set and read properties of a without compiler errors
    a way to go straight to the JS system with a particular object
let a: unknown = 5;
  similar to any, but you can't do any operations on it that are type-specific
  you have to convert to a type first (eg. via type narrowing)
  otherwise, it's similar to using object directly

let n: null = null; // the type of null is null
let u: undefined = undefined; // the type of undefined is undefined

let n: never = f(); // the function is not expected to return (eg. because always throws)

let x: number | string;   // type unions
  can at any time assign a number or string (and back and forth) to the variable
let x: number | null;   // nullable type via union
let x: number | undefined;

static variables only exist as class members (no local statics)

scoped like Java, not Python
  block-scoped, not function-scoped

primitives are mutable variables (while the objects themselves are immutable)
  as in most languages
the primitive types (from JS) are: string (!!!), boolean, number, undefined, null, symbol, bigint
  they are true value types and don't have any methods to call themselves
  when you do something like 5.toString(), that is an error because it tries to call it on the primitive
JS has boxed types String and Number, for instance, but it's a little different from boxing in Java
  if you do 'const x = 5' and then 'x.toString()', JS will autobox and call the method inline!
  in general, you should never have to use the boxed types directly (and it is very uncommon to do so)

objects are mutable reference types (as in most languages)
  let obj1 = {x: 10, y: 20};
  let obj2: {x: number, y: number} = obj;
  obj2.x = 100;  // this changes obj1 (a reference, not a copy)
structural typing does not imply copying - just matching
strings are immutable like in Java, C#, etc.
  but they are not reference types!
collections, including arrays, are mutable reference types

Nullability
  let x: number;    // no value specified
    x is actually undefined, even though we didn't say it could be undefined with a type union!
  let x: number|undefined;  // same thing, but other code will be able to tell it could be undefined better
  let x: number|null = null;  // explicit nullability specification
  if (x === null || x === undefined) {...}
  note that both null and undefined are real values from JavaScript and === will work even if the type is wrong

Type Alias
    type Person = {
      name: string;
      age: number;
      email: string;
    };

    type BetterPerson = Person;

    const x: BetterPerson = {name: "bob", age: 20, email: "bob@bob.com"};

    type NullableString = string|null;

Enums
  regular enums and string enums
    eg. can just give values with no = to auto-assign like in other c-like languages
  enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
  let playerDirection: Direction = Direction.Up;

Interning
  only applies to strings, not numbers or anything else
  if you create a String() instead of string(), === will do reference comparison
    and be false even for same literal string
  otherwise, === will be true because of the shared pool of strings
    you don't usually need to worry about that

JS vs. TS Types
  most of the types discussed here and in Collections come from JS
  but the following are added by TS:
    enums
    tuples (which is really just an array with mixed types)
    any
    unknown
    never
    void
  also, generics don't exist in JS
    Map is a container that can take objects of any type and doesn't enforce they match
      like using raw type in Java
    TS adds generics functionality to provide safety when you develop and compile your code

Symbol/symbol
  symbol is a primitive type (ES6) referring to a globally unique object
  Symbol() gives you a new symbol
    (looks like a class but it's not because you don't use 'new')
  Symbol('this is my symbol')
    can provide a string for debug output purposes
    but two Symbol() calls with the same arg will give two different unique symbols
  Symbol has members you can use that are known as "well-known symbols"
    Symbol.iterator, Symbol.search, etc.
  symbol (lowercase) is the type you would use to declare a symbol as a variable
    then call Symbol() without 'new' to create it
  a symbol can be used as a key in a map
  it can also be used as a key in an object, by using the computed property syntax
    eg. private [mySymbol]: number;
  one special behavior of symbol keys is they are ignored by Object.keys()
    so in a way it's kind of a hidden property

var
  var is the old-fashioned way of declaring variables (before let and const came along)
  you should avoid it in new code, but may see it in legacy code
  var is like let with these differences:
    function scoped like python
      eg. if you declare in a condition, you can see it outside the condition
    can read it anywhere in the function, even if not declared yet
      called "hoisting"
      value is undefined if not set yet
    window automatically gets any top-level vars (but not let or const)
    can redeclare same symbol with var again with no issue

Discriminated Unions
  you can make a property a tag on an interface by giving it a string as a type
    eg. interface MyInterface {x: number; type: "myType";}
    when that members is read, its value will also be the string
  classes must impelment the member, but the string must also match
  this tag is also known as a discriminant when used in the context of type narrowing
  a switch or if/else block that checks the discriminant will narrow the type
    eg. if have multiple interfaces, you can use the tag to narrow to the interface type
  this is a way around the problem of interfaces not existing at runtime for casting
    usually the prototype chain is all you have, but now you can use this for interfaces
  this is an advanced TS-only feature
  you can call the tag property whatever you want and have different tags for different purposes
    (eg. different types of interfaces being discriminated between)

JS Number Weirdness
  JS is unique in that it combines floating points and integers in 1 concept
  internally, a Number (number) is always a 64-bit IEEE floating point number
  it uses 52 bits for the mantissa (w/ implied leading bit depending on whether all exponenent bits clear)
    plus 1 sign bit
  so for the range -(2^53 - 1) to (2^53 - 1) [53 bit unsigned magnitude],
    integers an be bit-perfect represented for arithmetic, etc.
    that's basically equivalent to 54-bit (minus 1 negative value) integers
  outside that range, you can represent from very tiny to very large magnitudes
    but adding and subtracting 1, for instance, will have rounding errors
  an additional weirdness to watch out for is the behavior of BITWISE operators
    a bitwise operator converts a Number to a 32-bit binary integer before it does its thing
    first, if it's a fractional number, it will truncate toward zero (not negative infinity like Math.floor)
    then it will write the number as a 54-bit binary integer
    then it will truncate upper bits as if you did a downcast in C
    the result of the bitwise operator is then either passed onto the next one or converted back to floating point
    x | 0 is a way to downcast to 32-bits and back to float
    an additional weirdness is that if you bit shift more than 31 bits, it will auto-wrap for you
      but sequential shifts won't do this cooperatively
  arithmetic operators just work on floating point numbers with no conversion
  if you need more than 32-bits for bitwise operations, you have to use BigInt

BigInt
  trailing n for literals, or BigInt(n) to convert a Number
    if the Number is fractional or otherwise can't be represented, it will throw
    note that if you do Number math to make the argument to BigInt(), you may have already lost precision
  you can use all the arithmetic, bitwise, etc. operators on BigInt, but you cannot mix with Number
    eg. b ** BigInt(2), b << BigInt(2), b << 2n, etc.
  the range of a BigInt is essentially unlimited because it's a concatenated buffer
  to convert a BigInt back to Number, either use Number(b) or +b
    it will not throw if too large
    might lose precision, become infinite, etc.

[Collections]
Literals
  only array and object have literals ([] and {})
  trailing commas allowed everywhere

Arrays
  let a: number[] = [1, 2, 3, 4, 5];
  let a: Array<number> = [1, 2, 3, 4, 5];
  let a = [1, 2, 3, 4, 5];
  let a: number = []; // no type inference if empty
  let a: number[] = new Array(10).fill(5);
    new array of 10 5s

  a[0] // read-write
    no negative indices like Python
    but methods of array that take indices do allow that (eg. splice, slice, etc.)
  a.at(0)
    same thing, but as a method
    also allows negatives!
  a.length

  a.push(val) // append to end (O(1) like Java ArrayList)
  a.push(val1, val2, val3) // append multiple to end
  val = a.pop() // remove from end (O(1) like Java ArrayList)
    undefined if empty

  a.unshift(val) // append to front (O(n))
  a.unshift(val1, val2, val3) // append multiple to front, keeping this order
  val = a.shift(val) // remove from front (O(n))
    undefined if empty
  
  b = a.slice(start, stop); // inclusive start, exclusive stop
    b is a COPY of a range of a
    negative indexing allowed

  array is iterable via 'for...of' (and normal for loop w/ length) construct
  can also use a.forEach((num) => {})

  const a = [...firstList, ...secondList]; // spread operator (in-place)
  const a = firstList.concat(secondList);  // another way to do the same thing
  const a = [1, 2, ...middleList, 3, 4];   // adding in the middle
  NOTE: the spread operator will work on any iterable, not just other arrays

  const [first, second, ...rest] = a; // destructuring
    rest is another array here
    use _, __, etc. for don't care values
      const [first, _, ...rest] = a; // ignoring 2nd value

  a.filter() and a.map()
    both return an array, not some lazy stream like Python
  
  a.indexOf(item)
    for reference types, looks for reference
  a.lastIndexOf(item)
  a.includes(item)
  a.includes(item, fromIndex)

  reverse() and toReversed()
  
  [][] for multidimensional arrays
    nested [] just as you'd expect

  a.sort() for mutable, a.toSorted() for immutable copy
    either can take a comparison fn
    default sort is weird - converts to strings and does lexographic

  Array.from() can make an array-like thing into a true array
    the thing you pass in must support indexing and length like an array
    or alternatively, must be something iterable
    this is also another way to shallow-copy an array
    also can take a mapping function that can either take just a value or value and index
  Array.of() makes an array out of individual items as arguments

  a.keys() gives an iterable over the indices
    Array.from(a.keys()) is a way to get a RANGE
      eg. Array.from(new Array(10).keys())
  b = a.splice(start);
    a becomes all the elements before start
    b becomes the rest of the elements starting with start
    negative indexing is allowed
  b = a.splice(start, count);
    same thing but removing from the middle of the array instead of the end
    use 1 to remove a single item
  b = a.splice(start, count, item1, item2...)
    same thing but also adding one or more elements in-place to a
    the # of items does not need to match the # of things removed
  a.splice(start, 0, item1, item2, ...)
    inserting in the middle (empty array returned)
  aSpliced = a.toSpliced(....)
    toSpliced() returns a modified copy of a with the same args as splice()
    the usual thing returned by splice() is not returned in that case

  a.with(index, value) is the copying version of a[index] = value

  a.fill(100)
    fill whole array with 100
  a.fill(100, startingFrom)
    fill starting from an index
  a.fill(100, startingFrom, stoppingAt)
    fill a range with exclusive upper-bound
    if you try to fill beyond the end, it will just stop at the end
  aSameReference = a.fill(100)
    fill() returns the array itself which is modified in-place
    this makes it friendly to this way of making a new array:
      new Array(5).fill(100)
        NOTE: without the fill(), new Array(5) gives you a sparse array
          with all undefined values

  a.flat() returns a flattened copy of 2D array
    only works 1 level 
  to repeat an array's elements n times:
    (new Array(n)).fill(arr).flat()

  inference of mixed types
    const a = [1, 'hi', true];
      type is (number|string|boolean)[]
    const a = [new MyClass(), new MySubClass()];
      type is MyClass[]
    const a = [new MyClass(), new MySubClass(), new Object()];
      type is Object[]

  Reification
    const a = [1, 2, 3];
    a[4] = 5;
    console.log(a[3]);  // undefined
    console.log(a.length);  // 5

    const b = [1, 2, 3, , 4]; // same thing as above

    JS stores arrays like this sparsely

  const s = arr.join(',');
    joining array elements into string with delim
  
  no built-in value comparison via === or .equals()
    either do a loop or do JSON.stringify() and compare the result

  Missing:
    binary search for sorted arrays

Tuples
  similar to array, but fixed length and not homogeneous type
    this actually an illusion created by TypeScript
    there is no class called Tuple
    it is actually an array underneath
  let tuple: [number, string, boolean] = [10, 'hi', true];
      tuple[0] (read-write)
        not immutable like in Python
  tuple.length
  can destructure just like an array
    const [a, b, c] = tuple;
  can use 'for...of' like with arrays

Sets
  let s: Set<number> = new Set([1, 2, 3, 4, 5]);
      add(), has(), delete(), size()
  const s = new Set<number>();

  s.add(value);
  s.size // not a function for some reason
  s.has(value)
  s.delete(value)
  s.forEach((value) => {console.log(value);});
  s.forEach((value, index) => {}) // JS knows based on the lambda passed in
  use 'for...of' construct like with arrays

  Missing: set operations like intersection, union, etc.
    they are in the process of being added but it is still experimental
Maps
  let m: Map<string, number> = new Map([
      ["a", 10,],
      ["b", 20,],
  ])
  const m2 = new Map<string, number>();

  m.set(key, value)
  m.get(key)
    m.get(key) || defaultValue
    note that you CANNOT do m[key] (even though you can for objects)
  m.has(key)
  m.delete(key)
  m.size()  // # of keys
  m.clear()

  for (const [key, value] of m) {
    console.log(key);
    console.log(value);
  }
  also can use m.keys(), m.values(), m.entries()

  Map.groupBy(list, fn)
    gets a map of arrays
    to get a counts dictionary, you have to do it yourself
      eg. with reduce()

Objects (as structs)
  let o: {a: number, b: string} = {a: 10, b: 'hi'};

  type Entry = { // note similarity to C struct syntax (plus =)
    a: number;
    b: string;
  };
  let o: Entry = {a: 10, b: 'hi'};

  interface Entry {
    a: number;
    b: string;
  }
  let o: Entry = {a: 10, b: 'hi'};  // equivalent to the 'type' version

  let o = {a: 1, b: 2, c: 3}; // we will ignore c
  let {a, b} = o;  // destructure into variables called a and b with those values from the object
  let {a: x, b: y} = o; // renaming the variables to x and y locally

  keys can be quoted or unquoted (or not even strings at all)
    const obj = {a: 1, "b": 2, true: false, 1: "One",};
    obj.a, obj.b, obj.true (actually a string key), no way to do obj.1
    to access an object field using a string (or other type of thing) as the key:
      obj["a"], obj["b"], obj["true"], obj[1] (not a string)
    unquoted string keys in an object may be subject to minification (and their usages as well)
      the minifier may be smart enough to not minify it (but maybe you want it to)
    even class variables can have quotes around them, but that's weird
    quoted keys can have spaces in them!
  
  Object.keys(o), Object.values(o), Object.entries(o)
    to iterate over fields in an object as if a map
    does not include functions or symbol keys

  Copying Objects
    spread operator
    let m = {...n, x: 20}; // x will replace the value of n.x if present (or add as new)
    // m and n are separate, not linked together

  Computed Properties
    instead of providing a name or a quoted name for a key
    you can put [] around some TS expression to have the key computed at runtime
    the key does not become a string (unless that's what you compute)
      to get the value back later, you have to use the computed thing again
    besides the [] around the key, the rest of the syntax is the same as normal
      works for variables, functions, etc.
      works for interfaces, anonymous objects, classes, etc.
    Objects.keys() will get all the keys in their original types
      but it will purposely ignore keys that are of type symbol

    const m = {
        ['x']: 100, // retrievable as m.x or m['x']
        [20]: 200,  // retrievable as m[20]
        [30]: 300,
        [40](a: number) { return a*a; }, // callable as m[40](someNumber)
        [t + 'Bob']: 400, // retrievable as m['Hi, Bob'] or m[t + 'Bob']
        'a b c ': 500, // retrievable as m['a b c']
    };

    obj[key] || defaultValue

Objects (as classes)
  'class' instead of 'interface' and can have constructor, methods, etc.
  created with 'new' instead of structurally like with structs
  covered in detail in "Classes" section below
  a lot of the ideas about objects as structs above apply
    the end result of creating an instance is that kind of object anyway

Readonly
  let a: ReadonlyArray<number> = [1, 2, 3, 4, 5];
    also ReadonlyMap, etc.
  not truly readonly, just enforces the usage (like C++ const)

Stack, Queue, Deque
  no explicit built-in structures for these, but you can use methods of Array
    or roll your own, or install 3rd party libraries like 'deque' from npm
    for queue and deque, the efficiency will be bad if you use js Array
  Stack
    use push() and pop() [O(1)]
  Queue
    use push() and shift() [O(n)]
  Deque
    use push(), pop(), shift(), and unshift() to manage both ends [O(n)]

WeakMap and WeakSet
  like Map and Set
  but don't prevent garbage collection of their keys
  auto-updated when it happens
  no enumeration or size because of dynamic nature
WeakRef is a fairly new class that lets you hold your own weak reference
  const r = new WeakRef(someObject);
  const o = r.deref();  // wil be undefined if already garbage collected

Summary of Class-Like Objects and Their Differences
  Type Literals = TS feature, declared with 'type' or as an anonymous type on a variable declaration (left side)
  Interface = TS feature, declared with 'interface' construct

  Class = JS feature, declared with 'class' keyword
  Anonymous Object/Class = JS feature, assigned as a {} literal

  Method Signature = the normal way of defining a function (eg. f(); or f() {})
  Function Type Property = the lambda/function expression/method reference way (eg. f: () => void;)

  Function Expressions = alternative to lambda where you put the word 'function'
    only for the right side of assignments or passed into places
    the type (left side of assignment) looks the same whether it is a lambda or function expression

  the TS specific ones are type only, so you can specify either method signature or function type property
  the JS ones let you specify all 3 kinds of functions (method signature, lambda, function expression)
  class lets you specify the type (method signature or function type property) while anonymous objects do not

  the TS specific ones let you separate members with either , or ;
    ; is more typical, although inline type literals may have , to match the style of the right side of =
  classes need ; to separate, not comma
    and function bodies {} are exempt, even if they are part of lambdas
  anonymous objects always have to be separated with ,
    even if there is a function body {}

  : is usually for types and = is usually for values, with some exceptions:
    on function names, colon gives a return type instead (optional)
    TS specific ones are types only, so = is not used
    anonymous objects are special - only use : and no =
      and values but no types, except optionally on method return types

  'this' is only relevant to classes and anonymous objects because the others have no bodies
    when it comes to 'this', functions, methods defined in class bodies, and function expressions act the same
      regardless of how or where they're actually defined
      the binding of 'this' (assuming it's not explicitly bound with .bind(), etc.)
        depends on how the function is called
          eg. if called via an instance with .
            m.f()
            then `this` is m
          if the function was defined outside the class, then to call it like that:
            you just need a variable in the class that refers to that function
            eg. m.f = fn; (or define it in the anonymous object, etc.)
          eg. if called at top-level, then `this is the default value
            either the global object or undefined depending on environment and strict mode
      assigning a function expression, method, or function to a member of a new anonymous object
        will make it act as a true method of that object, if it's called via the object
    arrow functions, on the other hand, have a different behavior
      because they're meant to be passed around and keep referring to their lexical context
      'this' is bound based on the scope the arrow function came from
      if you define a lambda inside an anonymous object, it will use `this` from whatever it is when that object is defined
        not the anonymous object itself 
      it will always keep that `this` no matter what it's passed to, assigned to, or how it's called
        thus, it will act like a pure function (with some closure to some other object) instead of a method
    static methods (when called via a class) bind 'this' to the class instead
        beause that is what they're called on
    top-level functions, no matter which type, if called that way, will just bind `this` to the default/global object
    all of this goes out the window if you explicitly bind `this` via bind(), call(), or apply()

Data Structures Missing from JS/TS: (either make your own or use 3rd party library)
  efficient queue and deque
    3rd party libraries: double-ended-queue, typescript-collections, collections (js)
  priority queue/heap
    3rd party libraries: heap, typescript-collections, collections (js)
  sorted map and set
    3rd party libraries: typescript-collections, collections (js)
  linked list
    3rd party libraries: typescript-collections, collections (js)
  trie
    no major language seems to have this - just get used to making your own (it's simple)
  bitfields
  StringBuilder

Conversions
  Array.from(set)
  new Set(arr)
Min/Max
  use Math.min() and Math.max() and the spread operator

Thread Safety
  not an issue because no true multithreading in same address space

Implementing Objects for Collections
  objects are hashed and compared by reference instead of value when used as keys
  for sorting, you have to provide your own comparison function

Swap
  use tuple destructuring
  [x,y] = [y,x]
  works for array elements too

Iterables
  many operations that take an array will actually take any iterable
  you make something iterable by implementing the Iterable Protocol
    see "Classes" for details

Deep Copying
  n = JSON.parse(JSON.stringify(m));

Custom Printing of Elements
  console.log() will only print the raw objects
  but console.log(container.toString()) will use the toString() of the elements

Object.seal(o)
  makes all property creation and re-configuration silently not do anything
  but writing new values to existing properties still works

Operations Missing:
  binary search
  shuffle
  using object as a key by value (instead of reference)

[Strings]
// and /* */ for comments
\n for line endings

strings are immutable (mutation functions return new copy)
  but they are not reference types like in other languages!
there is no char type - a character in a string is a single-item string (same type)
strings are based on unicode and are not null-terminated

s + t + 3
  concatenates two strings and a number (converted to string)
concatenation is weird in JS compared to other languages
  the + operator will take any opportunity to automatically convert something to a string
    even if none of the operands are a string
  for objects it will automatically use toString() if available
  eg. const s = 3 + o; // o is an object
    s will be 3WhateverReturnedByOMethod
  eg. const s = [1, 2] + [3, 4]
    because arrays don't support +
    this will be 1, 23, 4
  TypeScript complains about a lot of these operations though
    you can still get the behavior if you use 'as any' on the objects it complains about
implicit concatenation NOT SUPPORTED
  eg. can't do "a" "b" "c" like in C++

'' and "" are both for string (char is just a single character string, not special thing)
`Hello, {name}!` // 'name' should be variable in current scope
  backtick quote
  variable can be a number too!
  the thing in {} can also be a TS expression instead of just a name!
`` is a multiline string (backtick quote)
  if you don't have a newline it will just be single line, but you can have newlines in it
    no need to escape the newlines
to use a normal string with an object of params, you have to do it yourself using string.replace()
  there is no built-in way, but many frameworks have it
there are no raw strings
there are no format specifiers

s.length
s[0], s.charAt() // read-only
  these are single-character strings!
  there is no char type
s.substring(start, stop) and s.slice(start, stop) // equivalent, just like array slicing
s.toUpperCase(), so.toLowerCase()
s.split(delim) gets a string[]
  can convert s to string[] of single-character strings:
    s.split('') // empty-string
s.replace(old, new)
  old can be a string or a regex pattern
s.includes(substr)
s.startsWith(substr)
s.endsWith(substr)
s.indexOf(), s.lastIndexOf()
  optional startIndex 2nd params
s.trim(), s.trimStart(), s.trimEnd()
s.repeat(n)
  repeat a string n times
methods that search from the start or end of a string can often take a start index
  so that you don't have to break the string apart just for that
for things like checking if letter, use regex
note that unlike other languages, support for directly checking character classes is weak
  have to rely on conversions, conditionals, and regex instead

for...of iterates over characters (single-length strings)

Conversions
  s = n.toFixed(2) // format a number as a fixed-point decimal string
  parseInt() and parseFloat() to get numbers from strings
  +s // string to number via unary plus operator
  Number(s) // boxed type as function (instead of c'tor)
    Number('Infinity') // Infinity
    Number('bob') // NaN
  String(n)
  JSON.stringify() to make object into json string
    JSON.stringify(o, null, 2) to pretty-print with 2 spaces per indent
    JSON.stringify(o, [key1, key2], 2) to only include certain set of keys
  JSON.parse() to make json string into object
  n.toString() to get string from number
  o.toString() to get string from object (as it defines for itself)
    arrays do not have this
    set and map do not implement it properly

  boxed types like Number, BigInt, String, etc. can act as either functions or c'tors
    this is only for those types - you can't do this with your classes
    the function version does a primitive conversion
    the c'tor version makes the boxed type (and doesn't autounbox back)
      you almost never want to do this
    you can't use the primitives like number (lowercase) as either functions or c'tors
      only for typeof and TS annotations

Base64
  btoa(original)
    gives a base64 encoded string
  atob(encoded)
    gives back original string from base64 encoding

console.log()
  console.log(a, b) logs both with space in between
  eg. console.log("field:", value);
  console.log(o) works on objects (will show keys-values) and built-in types
    much better than toString() and such
  output goes into debug console (eg. Chrome Devtools)
  console.log() for empty line
    can also use \n in strings

  note that console.log() prints the objects raw
    it won't call toString() for you
console.error()
  like console.log() but more serious (shows up red)
console.warn()
  less series than console.error()
console.info()
  similar to console.log()
there are color escape codes available too

Regular Expressions
  const pattern = /\d+/g
    makes a regular expression object directly using perl-like syntax
    no need for raw strings because already raw (unquoted)
    the // quotes it, but global flag comes after /
    but don't forget you can also use // inline (eg. text.match(/\d+/g))
  pattern.test(text)
    true if a match anywhere in text
  matches = text.match(pattern)
    if you use /g flag, gets multiple matches as array of strings
    if you don't use /g flag, gets tuple with info about 1 match
      null if no match
        this allows you to say if (text.match(/blabla/)) {}
  text.replace(pattern, replacement)
    replace all occurences of pattern with replacement
    can use $1, etc. for capture groups

joining is done by Array
  arr.join(',')
  arr.join() with no arg defaults to comma
  arr.join('') with empty string will join with no separator
there is no StringBuilder type object
  use arrays and join(), or template strings
to do something like sort a string, use Array.from() and then arr.join('')

Ascii values
  because characters are not a separate type, you can't do this: s[0] - 'a'
    do this instead: s.charCodeAt(0)
    the opposite: String.fromCharCode(65)

Case Insensitivity: convert both to lowercase first
  maybe also toLocaleString() and normalize() depending on requirements

Lexographical Comparison
  operators like < use lexographical comparison on strings
  therefore, you can use them for ascii comparisons without converting to ascii
    eg. c > '0' && c < '9'

Iteration
  strings can be iterated with 'for' as a sequence of characters (single char strings)
  but they do not have a .forEach() method

[Operators]
all the usual arithmetic, arithmetic assignment, bitwise, and comparison operators from c-like language
  and ternary operator
  and pre and post increment/decrement
  / will give a fractional number if applicable
    use Math.floor() if want floor division like other C-like languages
      truncates toward negative infinity (unlike / but like floor() in others)
    works ok in slice() and other things that take integers like that
      automatically floored for you
  ** for exponentiation like in Python
% behaves like C++ and Java (instead of Python)
  negative on left just negates result
  negative on right ignored
&&, ||, ! for conditions
&&=, ||=, ??= assignment operators (fairly new)
  for and, or, and coalesce assignments
  remember they don't convert to boolean (necessarily)
  eg. &&= will set to last one seen which may be truthy or not

type narrowing (a unique feature of TS)
  if (typeof x === "string") {
    let y: string = x;  // legal because x is type string in this scope
  }
  if (x !== null) {
    // in here, you can treat x as not nullable
  }
  if (x) {
    // in here, x is not undefined or null
  }
you can also define your own functions that have type narrowing behavior
  this is known as user-defined type guards
    function isString(x: any): x is string {
      return typeof x === "string";
    }
  the function actually returns boolean
  but it has a type guard expression
  then elsewhere, you can call it to narrow the type of its input parameter
    if (isString(s)) {/* do string-only stuff */}
  you can't do boolean combinations or anything like that in the type guard

== for a number or string will try to coerce one to match the other (eg. number to string) before comparison
  it comes from JavaScript and causes a lot of bugs
=== (also from JavaScript) does not do this coercion
  thus, it is called strict equality
  it is mostly (and often mandatorily) recommended instead of == in TypeScript
both == and === will check value equality for numbers and strings
both == and === will check reference equality (not value) for reference types like objects and arrays
=== works correctly with null or undefined (and similar) as well
  you are permitted to do the === check even if the type says it can't be null or undefined
!= and !=== correspond to == and ===
for value equality in a custom object, you have to implement .equals() for the class
  .equals() is not actually a member of Object but a convention you can use from Java
  primitives and built-in collections don't have it because of that fact
you can also use JSON.stringify(arr) === JSON.stringify(otherArr) for value equality
Object.is(a, b) is almost like ===
  but will consider signed zeroes different (+0 vs. -0)
    technically -0 and 0 are different values but == and === consider them the same
      even x.toString() considers them the same
  and will consider NaN equal to NaN

Casting/Coercion
  x as OtherType // compiler will keep you honest
    will only do things like any to a specific type or polymorhpic stuff
    wil not do things like string to number
    for things the compiler can't see are wrong, you may get unexpected behavior
      eg. let s: string = "hi";
          let o: any = s;
          let b: boolean = o as boolean;
          console.log(b);
          // you expect it to print a boolean, but it prints a string
      this is because 'as' is a pure TypeScript compiler feature
        it is removed entirely in the emitted JavaScript code
  let y: number = +s; // coercion to number via unary + operator
    eg. string to number
    will throw exception if bad format
  n.toString()
    but 10.toString() not allowed because of parsing issues
  
?? nullish coalescing
  x ?? "hi"
    will be x unless x is null or undefined, then it will be "hi"
  note a general truthiness check - just null|undefined check

! non-null assertion
  let x: number = nullableNumber!;
    TS doesn't actually do anything at runtime here (including throwing anything)
    you are just telling the compiler to trust you that the thing cannot be nullable here anymore
    you could very easily be wrong and have null at runtime when the compiler thinks you can't (be careful!)
      could end up causing other bugs and throwing other kinds of errors at runtime

? safe-navigation operator (also called optional chaining, or Elvis operator)
  a?.b?.c?.d
  if any link in the chain is nullish (null|undefined), stops and returns that

typeof x
  gets a string representing the primitive type of an object (in JS)
  note it's not a function call (no parenth)
    eg. typeof x === "string"
  because it's so primitive, it doesn't work for polymorphism in class hierachy
    all reference types are seen as 'object', including arrays
    even null is 'object' (but 'undefined' is 'undefined')
  number, boolean, and string work as you'd expect (it's very useful for these specific types)

x instanceof MyClass
  boolean check of whether the class is in the inheritance chain of x
  it works because JavaScript uses prototype inheritance, so JS will check the prototype chain for the class object
  but it won't detect structural typing, so be very careful relying on this!

"fn" in y
  membership check
  if y is an object, this will check if it has a method or variable called 'fn'
  may be defeated by minification

Truthiness
  !! and ! are opposites
    !! makes value into boolean based on truthiness, ! does same but negates it
  falsey: null, undefined, 0, "", NaN, false
  truthy: empty collections, empty arrays, empty objects, anything else
  boolean operators like && and || return actual values (not boolean conversion)
    they evaluate the conditions in terms of truthiness (as with !! and !)
    and then do short-circuiting based on that
    then the last value seen is the one returned (the original value, not the boolean)
  you can use || as a truthiness coalescing operator
  statements like if() do an implicit truthiness conversion too
    for instance, you can do if (myIntValue && myStringValue)
    but your linter and coding conventions may wish you to use !! to be more explicit

Spread Operator
  const a = [1, 2, 3];
  const b = [...a, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]
  works on anything iterable (eg. set, custom class, etc.)

semicolons are technically optional
  JS people don't like them
  TS people like them
  leaving it out can actually ruin the parsing of some multi-line statements

[] operator for indexing
  available on arrays and objects, but not for getting keys/values in a map

[Control Flow]
'if/else if/else', 'while', 'do/while', and 'switch' work exactly like other c-like languages
'break' and 'continue' as well

'for' loops have these forms
  for (let i = 0; i < 10; i++) {} // typical C-style
  for (const item of arr) {} // like Java range-for but 'of' instead of :
  for (const index in arr) {} // not recommended because unexpected behavior

  for (const [keyOrIndex, value] of collection) {}
    works for a lot of collections (eg. map, array)
    also, can call .keys(), .values(), .entries() members to iterate over those specific things
    for objects, use Object.keys(obj), Object.values(obj), and Object.entries(obj)
      note that iterating object properties has the following quirks worth mentioning:
          if you define a variable without setting it, it will not show up here
          if you set a variable to undefined, which is technically (mostly) the same, it will show up here!
          a function will not show up here, but a lambda or function expression variable will!

  for await (const item of asyncCollection) {}
    for asynchronous items (wait for 1 at a time)
    eg. promises

try {
  throw new Error("Uh oh!");
}
catch (error) {
  // use instanceof operator to check type of exception
}
finally {}

Built-in Exceptions
  Error
    best practice is inherit from this
    though technically you can throw anything
  ReferenceError
  TypeError
  RangeError (for index issues)
Exception Members
  typically at least 'message' and 'name'
    constructors will typically set message based on a string passed in
      eg. new Error(message)

Not Available: context management, asserts (have to use libraries)

[Functions]
types look a lot like python type annotations (but compiler actually cares)
unlike in C/C++/Java/etc., you have to put 'function' in front if not a class method
  this is similar to having to use 'def' in Python
unlike in Python, you can't arbitrarily reassign a function to a different lambda or something
  functions are not just treated as variables
  HOWEVER, in pure JS you could do that (TS compiler is the one preventing it)

function add(x: number, y: number): number {
    return x + y;
}

Optional Params
  function greet(name?: string): void {
    if (name) {
      console.log(`Hello, ${name}!`);
    } else { // name is undefined
      console.log("Hello, stranger!");
    }
  }

  greet(); // Output: Hello, stranger!
  greet("John"); // Output: Hello, John!

Default Params
  function power(base: number, exponent: number = 2): number {
    return Math.pow(base, exponent);
  }

Extra or Missing Args
  extra args passed in are ignored
  missing args become 'undefined'
  TS compiler doesn't allow you to do either of those, but JS does

Named Params
  not a first-class language feature, but you can do it with objects

  function greet({ name, age }: { name: string; age: number }): void {
    console.log(`Hello, ${name}! You are ${age} years old.`);
  }
  greet({ name: "John", age: 30 }); // Output: Hello, John! You are 30 years old.

Rest Params
  function sum(...numbers: number[]): number {
    return numbers.reduce((acc, curr) => acc + curr, 0);
  }

  function processOptions(options: { [key: string]: any }): void {
    // use options as an iterable object with keys and values
    // key is not a variable - it is telling it how to interpret the options object
    // this makes use of index signatures
  }
  processOptions({a: 1, b: 2});
  // could use ...options to process multiple objects

Overloading
  doesn't work because of redefinition of symbols
  the usual way is to use type unions w/ instanceof, optional params, etc.
  there is a way to declare your intent to have overloads to the compiler, intellisense, etc.
    function f(a: number, b: number);
    function f(a: number, b: string);
    function f(a: number, b: number|string) {// implementation goes here}
    // similarly b could be optional if you had f(a: number) in the list

Generators
  function* lazyList(limit: number): IterableIterator<number> {
      let i = 0;
      while (i < limit) {
        yield i++;
      }
    }
  const l = lazyList(5);
  console.log(l.next().value);
    OR for (const item of l) {console.log(item);}
    OR const a = Array.from(l) // to make into eager array
  can send values into the .next() call just like python for two-way communication
  yield* to yield multiple values from another generator in-place
    eg. so you can use a loop to concat

nested functions allowed but uncommon due to multiline lambdas
    unlike Python

return type can be ommited to let it be inferred
    eg. void, esp. private method
    general rule: maybe ommit if can be easily inferred
      but include by default, except for private methods

never is a special return type that means the function never returns
  eg. if the body throws

if a function returns without a 'return' statement
  it will implicitly return 'undefined'

Not available: throws, ref and out, overloading, macros, extension methods
  though you can simulate extension methods by modifying classes or instances

[Functional]
"fat arrows" with all the usual combos
  multiline body, implicit return, type inference on args, etc.
  you can't usually leave out the () though
    only in the case of 1 param with inferred type

const addNumbers = (a: number, b: number): number => a + b;
let greetFunc: (name: string) => void;
let run: () => void;
const run = () => console.log('hi');  // void statements allowed on void returns
const fns: (() => void)[] = []; // list of lambdas

function expressions: like lambdas (and assignable to variables like lambdas)
  looks like defining a function but without the name

  const fn = function (x: number, y: number): number {
    return x + y;
  }

  completely interchangeable with lambdas and functions just like lambdas are
  subtle difference = handling of 'this'

to return an object from a lambda with {} and no body, you have to wrap it in extra ()
  because it will think the {} is a method body
  eg. (a, b) => ({x: a, y: b})

IIFE:
   (() => {
    console.log("lambda call!");
  })();

variables with function types can be assigned lambdas or normal functions
  then you can call the variable just like it was a normal function
but you cannot rebind a normal function to a different function or a lambda in TS
  in JS you can
  in TS, you can think of it like it's a "const" variable (though it's not exactly the same)
  also in JS, people like to use lambdas assigned to constants instead of using 'function'
    less popular in TS
functions (inc. top-level, lambdas, methods, and function expressions) are reference type
  they even have methods

closures usually are by reference (even for primitives)
  but loop variables are an exception (eg. for loop iteration variable)
  to make a value close by value instead of reference, you need to make it a parameter of a function
    in other words, lexically capture it
    eg. a nested function, an IIFE lambda around the lambda, etc.
  this is similar to Python except for the part about loop variables

you can use _, __, ___, etc. as "don't care" values for lambdas, destructuring, etc.
  technically those are actual names (valid identifiers)
  but by convention they are d.c. values

this
  the 'this' keyword is not as straightforward as other languages
    it has a lot of JS weirdness that TS is stuck with
    not just for use in classes (normal functions have it too)
  
  in a top-level function that is not lambda or function expression, 'this' is either:
    the global object (eg. window in a browser) by default
    undefined if in strict mode
  in a lambda (with arrow), it is captured from surrounding scope
    eg. if in a class, it is the class instance
    eg. if in a top-level function, it is whatever it is there
  in a function expression, it depends on the context
  in a method of a class, 'this' is the instance
    and you're required to use 'this' to access members (similar to 'self' in Python)
      but don't include in method signature

  you can call the bind() method on a function object to explicitly bind 'this' to something
    eg. to treat a free function as a method of a class when called
    see Partial Application for more details

  ** see "Classes" for a more detailed explanation of how `this` binding works

Partial Application
  // just binding 'this'
  function f() { console.log(this); }
  const g = f.bind([1, 2, 3]);

  f();  // prints global object or undefined
  g();  // prints [1, 2, 3]

  // binding 'this' and some args
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  const g = f.bind(this, 10, 20);
  g(30);  // prints global object and returns 60

Applying Arguments from Iterable
  function f(a: number, b: number, c: number): number {
    console.log(this);
    return a + b + c;
  }
  
  f.apply(this, [10, 20, 30]); // prints global object and returns 60
  f(...arr) where arr = [10, 20, 30] would also work
    using spread operator to expand args
    when you don't need to bind 'this'

Applying Arguments Positionally
  f.call(this, 10, 20, 30);
  this is similar to bind() except it's actually calling
  a convenient way to bind 'this' without having to make a variable for the result

map, reduce, filter
  map, reduce, and filter are array methods that return new arrays
  note that reduce signature looks like arr.reduce(fn, seed) [weird order]

  NOTE: there is no sum() function unlike Python - have to use reduce() for that

some, every
  boolean methods of array that takes predicate
  some = usually called any in other languages
  every = usually called all in other languages
  eg. arr.every(n => n % 2 == 0)

Method References
  a method can be assigned to variable exactly as you'd call it
    eg. const f: () => void = instance.f;
    eg. const g: () => void = MyClass.g;
  assigning the method via an instance or via the class mean the same thing here
    both are considered UNBOUND
      calling it is allowed, but it's like calling a top-level function in terms of 'this'
  to make either one BOUND, call .bind() on it
    eg. const f = instance.f.bind(instance);
  but a key weirdness is that static and instance methods are totally separate
    you can only get instance method references from instances
    you can only get static method references from the class
    both are unbound until you bind()
    static method references want you to bind() to the class itself, rather than instance
  because JS functions only bind via 'this' binding, any function can become a method this way
    and static vs. instance just means whether 'this' is bound to the instance or class (or nothing if ignored)
  the type of a variable holding a method reference is the same as the equivalent function or lambda
    the 'this' part of it does not factor into the type

Lazy Sequences
  use generators that yield from other generators
  the yield stops the for loop from being eager
  3rd party options include lodash and rxjs

Recursion
  functions/methods call themselves by name
  no TCO
    it's actually in the spec, but browsers don't do it
  lambdas and function expressions can call themselves too
    using the current variable name being assigned
    eg. const f = () => {f();};

Callable Object
  there is nothing like a call operator in JS because no operator overloading
  but you could treat a function like an object and add properties and methods to it
  you could use a factory function return new instances of the function (eg. function expressions)
    that way, the fact that it has no constructor doesn't matter

Not available: pre-defined lambda types, pre-defined functions for common operations,
               purely lazy stream operations (have to use generator),
               a lot of functional operators (due to lack of stream operations),

[Classes]
looks mostly like Java with some differences noted here
also worth noting that a class is syntactic sugar for making an object (as described in collections)
  just with function variables for methods and prototype for inheritance

things in common with Java worth noting here again:
  all methods are virtual with no need to specify overriding
  inheritance works the same way (on the surface)
  use 'new' keyword to make a new instance
  default constructor w/ no args only if no construtor specified
  can only extend a class but implement multiple interfaces (no python/c++ diamond behavior)
  covariant return types
  increasing access level in subclasses

need to use 'this' in front of all member access from methods (never implicit)
  but also not passed in as param like in python
members are 'public' by default because that's how JS works (where there is no access level)
  no such thing as package-private like Java: just public, private, protected
methods do not have 'function' keyword, which makes them look more Java-like and less JS-like
member variables are declared in the body like Java (not in the c'tor like Python)
  but there is a special construct called Parameter Properties covered below that can act that way
unlike within code statements, variable declarations in classes don't use 'const' or 'let'
  act as 'let' by default
  can be made to act as 'const' with the 'readonly' qualifier
static variables and methods allowed
  accesed by ClassName.member
no destructors/finalizers

instead of being named for the class, the constructor is called 'constructor' and there can only be one

Static Members
  you cannot use an instance to refer to static members at all
    this is unique to JS compared to other languages
  a static method has 'this' bound to the class itself, like a python classmethod
  you can't take a method reference for an instance method from the class - it must come from the instance

Properties
  put 'get' in front of a method to make it a readable property
  put 'set' in front of a void method to make it a writeable property
  if a 'get' and 'set' method have the same name, they are the same property
    usually impossible since no overloading
  you can independently control access to the getter and setter
  you can access a property from an instance as if it was a variable

Parameter Properties
  a constructor parameter with an access specifier in front
  automatically makes the parameter into a member variable of the class (without having to decalre it in the body)
  eg. used to inject services in Angular
  JS implements this by doing this.x = x in the c'tor (for example)
    TS won't let you do that directly because that violates the type safety of classes

Adding Fields Dynamically to Classes at runtime
  eg. m.x = 10 when x is not a member of the class
  this is ILLEGAL in TS because if violates type safety
  but it is LEGAL in JS (just like python) and is used by parameter properties

Syntax Example
  class MyClass {
    x: number;
    private y: number;
    protected z = 20; // type inferred
    static a: number = 100;

    private readonly myConstant = "Hello";

    constructor(name: string, age: number, private readonly service: Service) {
    }

    getSpecies(): void {
    }
  }

  class MyDerivedClass extends MyClass implements SomeInterface1, SomeInterface2 {
    getSpecies(): void {
      // overrides without having to say so
    }

    // etc. etc.
  }

  const m = new MyClass("Bob", 20, myService);

Nullability of Members
  name?: string;  // shorthand for string | undefined
  name: string | null;
  name!: string;  // supposed to be populated by the end of the c'tor
    treated as non-nullable throughout the class (trusting that you will fill it before it's used)

Construction Order
  inline variable initializers run like normal code (not compile-time constants)
  they can reference each other (still have to use 'this')
  can call instance methods, etc.
  presumably should only reference variables declared higher in the list? (but fns don't matter)

  super() calls the superclass constructor
    you are required to do it explicitly if you have a c'tor in a base class
      in JS, a runtime error will happen if you return from derived c'tor without calling super()
        or access 'this' in derived c'tor before calling super()
    but it doesn't have to go first
    this has some weird caveats to know about
      base fields aren't available until after super() is called beause that's when it really creates the base
      you also can't use 'this' until after super() is called for similar reasons
    the compiler enforces all this for you in TS

Prototype Inheritance
  because inheritance is impelmented in the JS layer using prototypes, that is the basis for inheritance behavior in TS
  this has some key differences from inheritance in languages like C++ and Java (and similarities to Python):
    variable names are virtual too, not just method names
    private variables of the same name in a derived class are forbidden
      this is because when it makes the JS equivalent, it will name clash, making it not private after all
  only 1 thing of each name because it's like a dictionary (no overloading)

ABC
  can only be inherited by abstract classes unless all abstract methods are overriden
  cannot instantiate with 'new'

  abstract class MyClass {
    abstract f(): void;
  }

  abstract class MyOtherClass implements MyInterface {} // interface introduces abstract methods into the class

Interfaces
  unlike Java, can have both fields and methods
  worth noting: unlike a class, which emits JS code, interfaces don't emit any JS code and aren't a JS feature
    it just helps the compiler to keep you honest before compiling to JS
  name collisions = not a problem as long as compatible (all the same method)

  interface Person {
    name: string;
    age: number;

    greet(): void;  // abstract method
  }

  can be used like a base class in polymorphism just like other languages

  private members are not allowed

  Partial<Person> gets an interface that looks like Person but all fields are optional
    like adding ? to all fields that don't have it yet

Class as Interface
  unique feature
  you can pretend a concrete class is an interface and pass it as 'implements'
  all the implementation gets sucked out and only the prototypes are used (abstract)
  classes with private members cannot be used this way

Nested Classes
  a class can't be defined in another class like in other languages
  but it can be defined in a function body, so that's a potential workaround

Structural Typing
  very idiomatic TS concept
  adds some order to the chaos of JS duck-typing
  objects that are structurally compatible with other objects can be detected by the compiler
    but they cannot be detected easily at runtime
      eg. instanceof is useless for this
    to actually do it, you'd have to manually check all the properties
  the basic idea is if the interface of the object you pass in looks like the interface expected,
    then the compiler will let it through
    eg. even if the function expects a class and you pass a custom object without using new or the real class
    the compiler enforces that the structure is right, but you are free to shoot yourself in the foot
  optional fields expected on the left side of the = can be ommited or supplied on the right side
  optional fields expected on the right side of the = must not be required on the left side
  order of members does not matter in structural typing, only names and types
  if you use structural typing with a class, it's treated like an interfaces
    you're basically making an object with the right interface but missing the prototype chain
      it will not behave properly with polymorphic constructs

Object
  all reference types implicitly inherit from Object (and not primitives)
  you can do new Object() for an opaque object

  members commonly overriden:
    toString() and toLocaleString()
    valueOf()
      return a primitive value for operations like arithmetic
      default implementation just returns the reference itself
    equals()
      not used by maps and sets (=== instead)
  
  no hashing
    objects are not hashed the way they are in other languages for use in maps and sets
    the object's reference is treated as the key, and it is unique per instance
    there is no way to treat it as a value like you could in Java
    primitives are hashed as you'd expect them to be

  other methods:
    hasOwnProperty() can tell if a property lives on this object instead of a superclass

  even when you use an interface or structural typing, it is understood all objects have Object members
    and they do not in any way interfere or participate in structural typing checks

Adding Properties to Objects
  const m = MyClass();
  m.x = 10; // ILLEGAL if x is not a member of MyClass (unless pure JS)

  function f() {}
  f.x = 10; // LEGAL (to support decorators?)

Expandable Object
  relies on index signature feature

  interface MyObject {
    [key: string]: any;
  }
  const myObject: MyObject = {};
  myObject.field1 = "hi";
  console.log(myObject.field);
  console.log(myObject['field1']);

Not supported: operator overloading, partial classes
  though index signatures appear on the surface to be operator overloading

override keyword:
  newer addition to TypeScript
  usually optional to use, but Angular turns on the compiler option to make it mandatory by default
  eg. override f(): void {}
  only for overriding base class methods (not implementing interface methods)

Index Signatures
  pure JS allows you to use m.x and m['x'] to add arbitrary variables to any reference object
    arrays are special in that a[1] and a.toString and a['toString'] internally all use the same [] operator
    maps technically have [] but it is only the one from Object (doesn't participate in the key-value pairs of the map construct)
  TS prevents m.x from working if x is not defined on the class, for type safety
    m['x'] may still work, depending on compiler settings (possible to make it fail compiler based on the string inside)
    when the check is not enabled, m['x'] would return undefined if not there
  index signatures are a way to turn some of the JS flexibility back on from within TS
    it is a pure compile-time feature that just affects what you're allowed to do with regard to the above
    an index signature is defined on an interface or class to specify what kinds of types can be keys and values for []
      implicitly understood that m.x is m['x'] in this case
      eg. [index: string]: string; // m.x = 'hi' allowed, m.x = 100 disallowed
      eg. [index: string]: string|number; // type unions allowed
      eg. [index: string|number]: string|number;
    an index signature never has "implementation" because it's just to guard uses of the object
    you could use 'any' as a type to make it fully JS-like
    you can use 'readonly' before the indexer to make it not allow assignment
    other variables defined in the class, subclasses, or superclasses, will only be checked if the key type matches
      eg. [index: number] will not complain about a member x: string
      otherwise, the variables will cause compile error if the left side matches but right side does not
    in structural typing, it is more strict
      any properties passed in must pass the indexer check regardless of whether the left type matches
    members of Object are not checked against indexers because they're fundamental to the language

Anonymous Classes
  function f() {
        return {x: 10, y: 20, z: 30, volume: function() {return this.x * this.y * this.z;}};
  }
  NOTE: anonymous classes will close over variables just like lambdas will
    useful for iterator protocol

Polymorphism
  assigning a derived class to a base class reference works as you'd expect in any language
  going the other way requires the 'as' operator to assert to TS that you're sure it's right
    unless you turn off strict checks, which is a bad idea
  you can also use type narrowing with 'instanceof' to assign it in a block without needing 'as'
  VERY IMPORTANT: if an object was assigned via structural typing, it is missing the inheritance chain
    an object not created via 'new' on the derived class will not pass 'instanceof' checks
    and lots of other things will go wrong - do not mix the concepts!
  remember that structural typing treats classes like interfaces!

Iterable Protocol
  to make an object iterable using for...of without having to use Object.keys()
    eg. to make your generic container give only the values you want when used that way
  worth noting that this is all from ES6 (pure JS), not a weird TS thing
  to make a class/object/interface iterable, it must have this method:
    [Symbol.iterator]() {}
      note the use of a computed property using a well-defined symbol
    the object returned by that method should have a next() method
      this is your iterator
      it might be an anonymous class that closes around some data
      or it could be a whole other custom class
    next() returns IteratorResult<T>
      this is a TypeScript built-in interface just there to help you structure your result properly
      the actual expected structure of the object is {value: T|null, done: boolean}
      you return values and false while you still have values, then you return null and true when you have no more
    alternatively, you could do *[Symbol.iterator]() {} and use a generator method with 'yield'
      then don't have to do the anonymous object

Generator Methods
  work same way as generator functions, but the * goes in front of the name because there is no 'function' keyword
  eg. *myfn(): IteratorResult<number> {}

Declaration Merging
  an interface with the same name as an existing interface or class adds members to that interface or class
    eg. you can use that to add properties to DOM objects like 'window' so TS will let you set them
  members are unioned together - duplicates ok if they don't conflict (eg. same name and type)
  if an interface merges with a class, it adds undefined members that you can assign
  classes can't merge with classes (otherwise, that would be partial classes)
  enums can also merge together, though they repeat ordinals if not otherwise specified
    but can add methods to an enum, for instsance
  this can be used to do extension methods
    add the method's signature via an interface of same name as target class
    then assign TheClass.prototype.theMethod to a function
    this will add the extension method on existing or new instances of the class
    since modifying prototypes like that is not recommended, you could alternatively, do it in a facotry
      wrap creation of new instances and set the function on instances instead

Call Signature
  on an interface only
  a class cannot implement it, must be a function
    eg. by casting a function to the interface
  then you can use the interface to add other properties without TS complaining
  you can even have multiple call signatures to handle the default args scenarios and such

  (x: number, y: number): number;
  (x: number): number;

Construct Signature
  another interface-only thing that is not implementable in a class
  though a class acts like it implements this interface by providing the matching c'tor
    it is not allowed to explicitly say it implements it
  you will be allowed to cast the class itself and then use the interface as a constructor
    you don't even have to cast - it will just understand it's compatible when you assign
  this is a way to constrain what you can construct a JS object with, for instance
  though you can pass a class directly as a function, the type of it would be 'Function'
    so you can't control what args can be passed that way
    JS will allow it, but TS will not
  
  interface MyConstructable {
    new (name: string): MyClass;
  }

  to pass a constructor as a callable object, you have to use a construct signature
    you could do it inline with an anonymous type too
    function create(ctor: {new (): MyClass}) {
        return new ctor();
    }
  an alternative way to do it is to pass the type of the constructor like this:
    function create(ctor: typeof MyClass) {
      return new ctor();
    }
  even though typeof usually gets a string in JS, TypeScript overloads it to work differently on classes
    'typeof MyClass' tells TS to allow you to pass the class as a constructor function
    the typeof call will be gone in the emitted JS because it's only a type

Prototypes In-Depth
  an instance of a class or a subclass of a class are both more specialized than the class
  they can both be represented by a chain of prototypical objects from Object to the instanceo
  all objects in JavaScript have a hidden prototype object (accessed via Object.getPrototypeOf(obj))
    internally the property is [[prototype]] and you may see that in Chrome Devtools
      [[ ]] means internal property you can't see in code
  when you access a field (either a variable or method) via . or []
    JS will first look on the object itself
    then retreive its prototype and check on that object, and so on down the chain until null
    if not found, then returns undefined
  the prototype chain is 1-dimensional
    no diamond inheritance
    the chain is kind of parallel to the inheritance chain
      or one ahead of it depending on how you look at it
  class instances have the class as their prototype
  classes have their superclass as their prototype (all the way down to Object.prototype)
    Object.prototype's prototype is null
  anonymous objects have Object.prototype as their prototype
    meaning they are instances of Object with stuff added dynamically
  functions have Function.prototype as their prototype
  const o = Object.create(prototype);
    creates an object using a given object as its prototype
  prototypes are object references, not copies, so modifications are dynamic
    all existing instances or subclasses affected right away
    that is also what makes it dangerous to modify a well-known prototype like the one for Array or Object
  all functions, including lambdas, have a prototype property
    this is separate from the hidden prototype of the function itself
    the prototype property is initially populated with an object that has 'constructor' set to the function itself
      this is an independent new object, not a reference to something common
    by modifying the function's prototype, you can add members that will be used when an object is created via 'new'
  the 'new' operator essentially does this:
    const o = Object.create(MyClass.prototype); // where MyClass is a constructor function
    MyClass.call(o, ...other args...); // call constructor with 'this' bound to the new thing
  to make a class the old way:
    make a constructor function and add members to its prototype property
      eg. function MyClass() {}; MyClass.f = () => {}; MyClass.x = 100;
    use the 'new' operator with that constructor function
      eg. const o = new MyClass();
  to make a subclass the old way:
    the subclass constructor function should call the base class function using .call() to bind 'this' to 'this'
    the default prototype of the subclass function should be replaced with Object.create(MyBaseClass.prototype)
    MyDerivedClass.prototype.constructor should be set to MyDerivedClass (since it doesn't have one yet)
  static members are set on the function itself instead of in the prototype
  ES6 classes are syntatic sugar to wrap this mechanism
    class -> constructor function
    constructor -> args and body of that function
    members of the class -> set on the prototype (or on 'this' in the constructor body)
    statics -> properties on the constructor function
  there is some additional weirdness with enumeration of object properties
    enumerating properties of an ES6 class includes base members
    but enumerating properties of object made via Object.create() doesn't include members of the prototype
    there are additional methods on Object to configure individual properties
      such as whether they're enumerable, etc.
      ES6 classes hide that ugliness from you
  primitives can't be prototpyes - only objects
  the 'constructor' property of a function's prototype is used by 'instanceof'
  interfaces and type literals don't participate in any of this becuase they are only for the TS compiler
  TS considers function prototype properties to be 'any' but is more restrictive on MyClass.prototype

Not supported: operator overloading, partial classes, value types, method/constructor overloading,
               classes nested in other classes (but nested in body is fine),
               finalizers/destructors/disposable, friend classes (in TS),
               c'tor initializer blocks or lists,
               constants or defaults or statics on interfaces like in Java,
               method and variable with same name (due to how names work),
               sealed/final

[Generics]
can be used with any type args, not just reference types
type arg goes to the right of name for both functions and classes
elements of the type must be treated as Object
  primitives will be auto-boxed as needed for you

functions can infer types or be called explicitly as f<number>()
classes can infer or give explicitly too

<T extends MyInterface> to be able to use members of MyInterface in the generic
<T extends MyInterface & TheirInterface>

JS has no concept of generics, and the compiled JS code just uses the raw types
  eg. const m = new Map(); // can add whatever key and value types you want

type annotations must use the generic type (eg. Map<string, string>) [which often can be inferred]
the right-side of assignment (eg. 'new' operator) can use the raw type or the specific type
  if specific, you can't conflict with what you put on the left
if you left the left side infer and use the raw type on the right side, it acts like a raw type in Java
  TS will just believe you when you assign it to type param version

a generic with void as a type arg is sort of special
  eg. Box<void> can be constructed as Box(undefined) or Box() assuming c'tor takes T arg
  this is very useful in rxjs for subjects that need to signal without emitting a specific value

no need for wildcards - generics are much looser in TS and are already covariant/contravariant

you cannot do something like T() to create a new value
  TS maintains T as just a type, not a class object

[Imports/Modules]
Exporting
  'export' in front of any variable, class, etc. you want to export
    eg. export const PI = 3.141519;
    eg. export class MyClass {}
    just making them public is not enough to make them exportable
      though they still exist and can be seen by the exportd functions from within here
  you can also declare exports at the top instead of inline throughout the file
    export {MyClass, PI};
    export {MyClass as MyType}; // provide a 2nd name to use in addition to MyClass which was exported already
      you can rename variables, classes, etc.
      if you already exported them, then you are giving them two names (eg. for different kinds of clients)
Barreling
  you can export symbols from another file and have them pretend to be part of this file
    no indirection for the user
    eg. export * from './otherfile';
  in addition, you can add a layer of indirection if you want
    export * as subfile from './otherfile';
      then client sees it as subfile.MyClass, etc. after importing from you
Default Export
  export default class MyClass {}
    only 1 default allowed per module
  the difference is you can drop the {} on import for the default symbol only
    import MyClass from './mymodule';
    import {OtherClass} from './mymodule';

Importing From TS Files
  in another TS file, import by relative path from the file itself (not working directory or project)
    eg. import {PI} from './myconstants';
        console.log(PI);

    note the following:
      {} around the names to import (unless importing the default export)
      quote the path
      use ./ for relative path (necessary)
      no file extension on the TS file importing from
    
    eg. import {PI} from './subfolder/myconstants';

    NOTE: it is possible to add folders to the search path for relative imports
      via your tsconfig.json file
Importing from Node Modules
  import {SomeSymbol} from 'somepackage';
    the main difference here is the lack of ./
    instead of relative import, it's an absolute import
    somepackage is expected to be npm installed into the folder containing this TS file
      or one of its parents
Multiple Imports
  import {x, y} from './constants';
Renaming
  import {PI as myPi} from './constants';
  console.log(myPi);
  import {x as myX, y as myX} from './constants';
Import All Importable
  import * as Constants from './constants';
  console.log(Constants.PI);
Import Type
  not technically required but added in later TS and recommended for clarity
  import type {MyClass} from './types';
  import {type MyClass, PI} from './types'; // mixed classes and variables

Statefulness of Imports
  you can't directly assign a variable that was imported to change it
    eg. import {x} from './myfile'; x = 100; // ILLEGAL
  but objects referenced via imports are living stateful objects that you can change
    eg. import {m} from ../myfile'; m.x = 100; // FINE
  all the various places that import or rename that variable will see the change!
  the top-level code from the imported module is only run once on the first import
    then the state just continues to live and get returned by other modules that import it

old concepts/keywords you may see (discouraged in new code):
  namespace
  module

Ambient Declarations
  similar concept to a header in C++
  just telling the compiler how to use a JS library
    the contents of an ambient declaration go away in the emitted JS, but it helps you safely use the library
  you compile against the ambient declaration and then make sure the JS library behind it is there at runtime
    via webpack, etc.
  typically in a .d.ts file named for the JS library
    many JS libraries come bundled with .d.ts files, and many have them available as separate packages
  use the 'declare' keyword to make a declaration ambient

  Examples
    declare const someVariable: string;  // we can code against a string variable someVariable
    declare function someFunction(a: number): void; // can call this and assume it will exist
    declare class MyClass {constructor(arg: string); method(): void;} // all abstract, assume will work out

    code that makes use of someVariable, someFunction, and MyClass will have type checking according to the above
    then the emitted JS code will use those symbols in the normal JS type unsafe way
    then any JS code included into the bundled JS for the app will have those symbols defined so that the code works

  the 'declare' keyword is also used in a hack in Angular to prevent issues with minification in reactive forms
    I'm not sure the details of how it works
    you declare your @ViewChild FormGroup variable in the angular component class as 'declare' and it works out

  Definitely Typed
    a repository of community-provided .d.ts files for common JS libraries
    just do 'npm install @types/the-package' to install TS ambient declarations for JS library the-package
    eg. @types/jquery
    eg. @types/node
    and of course you need to install the real JS libraries for those types to work
    eg. jquery, node in above

    some JS libraries will already come with .d.ts files becuase they're commonly used by TS users

  Top-Level of Code
    like Python, you can put whatever you want at the top level and it will execute when imported
    the first file executed is the entry point
    however, unlike Python, TS doesn't like you redefining symbols (eg. same class, function, etc.) multiple times at same level in same file
      that is why you have to use IIFE in Jupyter notebook cells

require()
  'import' is the newer ES6 way to import code
  'require()' was the way Node did it in the past
    both TS and JS support this
  Node now supports 'import', so you don't have to use 'require'
    but you see it all over the place
  require() is basically the same thing but it gives back an object containing the imported symbols

3rd party libraries can also be included by CDN URL in the DOM of your page
  <script src="........."></script>
  this is common for things like jQuery, boostrap, etc.

regarding names in modules/files
  dash and underscore are fine
  dot is not

[Project Configuration]
TypeScript compiler = tsc

tsconfig.json
  TypeScript compiler options for your project
  a folder containing (recursively) .ts files should have a tsconfig.json file at the root
  when you compile/run a TS file, the compiler will automatically search upward for it in the ancestry
    if it doesn't find one, it will still run (with some default options)
  you can make a new one (with helpful comments) with 'tsc --init'
    frameworks like Angular also make their own for new projects

  baseUrl = base path for imports (relative to the tsconfig.json)
  outDir = where to put the output build artifacts (eg. js files)
  strict = enable to get a bunch of strict checks like nullness
  noImplicitOverride = requiring override keyword to override a method
  target = which version of JS to emit code for
    this affects what code you can write as well (eg. which bulit-in data structures you can use)

package.json
  NPM package information for your project
    searched upward similarly to tsconfig.json
  used in conjunction with node_modules folder to find packages you import in your code
  you can  make a new one with 'npm init'

NVM = for side-by-side node versions (similar to conda for Python)
  nvm install node
    make environment with latest version and make it the default
  nvm install node [version]
  nvm use [version]
  nvm which [version]
    to see physical install location
  nvm deactivate

  npm packages from environments will go into subfolders of ~/.nvm

NPM = Node Package Manager
  comes bundled with node itself
  installing node (possibly via nvm) is first step before doing any projects
  then you can use it to install Angular, React, whatever you want

  npm install somepackage
    installs a package into the local project (based on working directory and search upward)
    manages package.json and node_modules folder
  npm install --save somepackage
    same thing (save option used to be required, so you'll see it online)
  npm install --save-dev somepackage
    install a package as a dev dependency
    available during development but not in production
    eg. chrome devtools integrations, ambient types, etc. might be here
  npm install
    based on existing package.json, install all local modules into node_modules folder
    you have to do this when you sync a package.json from GitHub, for instance
  npm install -g typescript
    install a package globally so that it's always available
    often used for ones that have command-line scripts
    local packages shadow global ones
  npx somecommand
    runs an npm package command from the latest version remotely without having to install globally
    if you have the package and it's the latest version, it will use yours for efficiency
  npm run scriptName
    run a script from local package
  npm run -g scriptName
    run a script from global package
  
  Some Useful Packages
    typescript
      the typescript compiler
      install globally
    @angular/cli
      for Angular projects
      install globally
    ts-node
      gives you a TS repl
      install globally
    prettier
      code formatter
    eslint
      linter

Node
  node
    to get JS repl
  node file.js
    execute a file at the terminal
  node also gives you a framework for executing scripts
    can get commandline args like a python script
    can also run server code to retrieve web requests
    and much more!

tsc
  tsc --init
  tsc myfile.ts
    creates myfile.js

  does not do minification, optimization, or polyfills
  you need other tools like WebPackage, Babel, etc. for that
  that's why ES target in tsconfig.json is so important

ts-node
  ts-node myfile.ts
    directly execute ts file
    probably calls tsc to compile?

** see Setup notebook for more details on environment setup **

[stdlib]
unlike Java, Python, C++, etc. there are no imports needed for standard library symbols
  imports are for other TS/JS files and node packages
most standard library symbols come from JS
  TS adds generics to some of them for type safety, but the underlying raw type is from JS
  also it adds ambient declarations for type safety
  but for instance, new Date() already works in JS because object creation is from there

a lot of built-in functions, collections, primitives, etc. already discussed above in various places

Browser DOM
  these are global objects you can automatically access in both JS and TS
    though TS adds strong typing to them so that you will use them safely
  to add your own members to them JS-style in TS, you can use declaration merging on their types
    then TS will let you set the fields you want
  it's worth noting that the below types exist in JS by the same name, but TS adds ambient declarations
    this is to make you code in a type-safe way so that when it compiles down to JS, you have less bugs
  
  window: Window (default target of 'this')
    contains all global variables defined with 'var' (old-fashioned not recommended way)
    also contains document, location, etc. as properties
    properties added to window become globally available too
      eg. setTimeout() actually lives in window, and you can call setTimeout() without putting window. in front
    you can check for existence (eg. to see if script or browser) with 'typeof window === undefined' or similar
  document: Document
    the main starting point for DOM manipulation
    
    Getting Single Elements
        const element: HTMLElement|null = document.getElementById('myId');
        if (element) {
          const buttonElement: HTMLButtonElement = element as HTMLButtonElement;
          console.log(buttonElement.value);
        }

        const myDiv = document.querySelector("#myDiv") as HTMLDivElement; // if no strict null checks option
        if (myDiv) {
            // TypeScript knows `myDiv` is a div element
            myDiv.style.backgroundColor = "blue";
        }
    Getting Multiple Elements
        document.getElementsByClassName('myClass')
        document.getElementsByTagName('myTag')
        document.querySelectorAll('myTag.myClass')
        element.children

        these return array-like objects that aren't true arrays
          can make into true arrays with Array.from()
        return empty collection instead of null when not found

    Events
        myDiv.addEventListener('click', (event) => {
          event.preventDefault(); // or stopPropagation, whatever you want
          console.log('clicked!');
          console.log(e.target);
        });

        element.dispatchEvent(event) to dispatch an event yourself
          can be one of the built-in ones or your own
          an event has a name and an event object with properties (like addEventListener shows)
          eg. const myEvent = new CustomEvent('myCustomEvent', {
                  detail: { message: 'Hello from custom event!' }
              });
    
        myDiv.removeEventListener('click', fn); // fn must be same reference you added for this to work
          if an element is remove from the DOM, it is considered good practice to remove the listeners
          although modern browsers SHOULD be able to figure this out
            if they don't, it would be a memory leak
          the lambda could remove itself when it's done if it's a one-time thing
            use its own name as the reference to pass in
    Event Phases (event capturing)
      if you click a button in the browser:
        1. window capture phase click event fired
        2. document capture phase click event fired
        3. all elements in the chain down to the lowest target fired (in capture phase)
        4. at each level, all handlers are called in the order they were added
        5. then we go into the bubble phase and go back up to the window
      there is a 3rd (optional boolean) param of addEventListener() that defaults to false
        if you set it to true, you add to capture phase instead of bubble phase
      e.stopPropagation() will stop from continuing the above procedure but will still process other handlers on current target
        if capture phase, can be a global handler that doesn't want children to see the events themselves
      e.stopImmediatePropagation() is event strong and stops other handlers on same target from being called
    
    Load Events
      document 'DOMContentLoaded' fires when the DOM is in-place (but before styles, etc. and other resources)
      window 'loaded' fires when all dependencies are loaded
      to gaurantee your events don't fire until one or both of those,
        put the addEventListener call in the appropriate handler
      a click handler could fire before either of those otherwise
        eg. if browser renders part of the DOM first and the button is there

    Adding DOM Elements
      const newDiv: HTMLDivElement = document.createElement('div');
      newDiv.id = 'new-div';
      newDiv.textContent = 'This is a new div.';
      newDiv.className = 'my-class';
      newDiv.classList.add('animated');
      newDiv.classList.remove('animated');

      document.body.appendChild(newDiv); // to append top level

      const container = document.getElementById('container');
      if (container) {
          container.appendChild(newDiv);
      }

    Removing DOM Elements
      element.parentNode.removeChild(element)
      element.remove() // more direct, but not supported in IE
        polyfill can fix that though
  location: Location
    for dealing with url and host type stuff

    href = current page url
      can also use toString()
    various properties for components of the URL, such as hostname, search, port, etc.

    reload() to refresh the page
    replace(url: string) to navigate to another page without adding a back button entry
    assign(url: string) to navigate to another page with a back button entry
      you can also change location.href and do location.reload()
    
    if you change 'href', it will navigate to the new page after the current code finishes
      you can do reload() to do it right away - then no more of your code will execute
      if you do setTimeout(), your handler might run if the delay is short (or might not)
      all your code is cleared out when the new page is up

  localStorage: persistent key-value storage for your application
    per "origin" (protocol + domain inc. subdomains + port)
    no expiration, but limited to 5 MB (after which will throw when trying to add new)

    localStorage.setItem(key, value);
    const value = localStorage.getItem(key);
    localStorage.removeItem(key);
    localStorage.clear();

  Cookies
    a cookie is a string that's stored for the current "origin"
      it is sent with all future requestes, including page loads, ajax, etc.
    it can be set or retrieved as document.cookie
    the fields within the string specify expiration date, whether secure or not (HTTPS only), etc.
    you delete a cookie by setting its expiration date to the past
    ** see Standard Library notebook for examples **

Math: static math functions you can call on numbers
  abs()
  ceil(), floor(), round()
  max(), min() [variadic]
  random() [0,1) [scale and round if need integer range]
  sqrt()
  pow(base, exp)
  sine(), cos()
  log(x), log10(x), exp(x)

Date
  const date = new Date()
  date.getMonth(), date.getYear(), date.getTime(), etc.
  date.toDateString()
  date.setMonth(), etc.

setTimeout(fn, delay = 0)
  run fn after a delay in milliseconds (minimum)
  if 0, it will just go into the queue of tasks to be dispatched by the browser's event loop (after what is already in there)
  this is useful for when you want to do something after the current event handling is completed properly
    esp. useful in things like Angular change detection
    or if your code will take a long time and you want to let the UI continue to function
  this is part of Java's simulated multithreading

Promise<T>
  const promise: Promise<string> = new Promise((resolve, reject) => {
    // do some kind of async code
    // that calls resolve() with a string
    // or reject() with an error string

    // eg. used in a lambda passed to an HTTP handler
    // eg. used in a setTimeout() lambda
    // eg. await another promise
  });

  aside from creating your own promises, you will often get them from sever calls and such

  // chainable
  promise.then((data) => transform(data))
         .then((transformedData) => transformedData.x)
         .catch((error) => handleError(error));
  .then() itself returns a promise
    but the function inside can return either a single value or a promise
    it will automatically be unwrapped if a promise
      so if you didn't want that, you'd need to put in [] or {} or something
      allows you to do things like call another API based on result of this API
    but it can also just chain single values so you can do map()-like transformations

  Promise.race([promise1, promise2])
    makes a new promise that returns (or errs) when the first promise passed in returns or errs
      the rest are ignored and not cancelled in any way
    this is like doing new Promise((resolve, reject) => ...) and passing the resole and reject into all the subpromises
      because once one calls it, then the promise is done

async/await keywords
    JS syntactic sugar for chaining promises as if they are synchronous

    async function(x: number): Promise<string> {
      const y = await someOtherAsyncFunction(x);
      return (x + y).toString();
    }
    const f = async function() {};
    const l = async () => {};

    'async' makes a function that returns a promise into an async function
      still have to explicitly return promise in signature
    in the body, you return the synchronous value instead of a promise
    in the body, you can use 'await' to have it continue when another promise resolves
      this is part of the state machine magic the 'async' keyword provides
    other 'async' functions can 'await' your function (or promise)
    functions that are not 'async' can still call your function, but they must directly deal with the promise

    you can call an async function without storing the promise safely
      you won't be able to get the value, but if it has some other side effect
        then that will happen

Ajax
  XMLHttpRequest is the built-in browser type for making calls to the server
  it is a bit ugly, and usually you will want to use libraries that wrap it better
    eg. with promises, etc.
  frameworks like Angular have their own ways to do it too
    eg. in Angular, HttpClientService helps you get JSON objects from the server
      returns an observable
  there is a proposal to add Observable (from rxjs) directly to the JS language
    it is still just a proposal and may not happen for a long time if ever

  fetch() is a newer replacement for XMLHttpRequest
    fetch(url) -> gives you a promise with the data from the server
      fetch(url).then((response) => {
        if (response.ok) {
          console.log(await response.json());
        }
      }).catch((error) => console.log(error));
    fetch(url, fields) -> same thing but can merge fields in
      eg. fetch(url, {headers: {}, method: 'GET'})
      some headers are set automatically by the browser in all fetch() requests
      when you provide your own, it will MERGE with those
    Chrome DevTools has a "copy as fetch" option so you can repeat an HTTP requests
      if using it in there, use JSON.stringify() so you don't have to worry about exact JSON format
  
  for gRPC, you need a special proxy that lets you fetch() from a JS client in a browser

  response.json() and response.text() are async because HTTP is a streaming protocol (could be chunked)

JSON
  JSON.stringify() and JSON.parse() as described in Strings above
  JSON is more strict than JS
    eg. keys have to be double-quoted
    so JSON.stringify() still useful even if already have a JS object (eg. when sending via web)

Multithreading
  JS doesn't really have the typical fork/join type multithreading
  though it does have a concept called Web Workers

Web Workers
  Web Workers are a way to have multithreading in a JS application, but without a shared memory space.
  spawn workers with Worker class in JS
    construct with a JS file (separate from the main JS file)
  main thread can send/receive messages with the workers
  workers cannot see DOM or directly access main thread's memory

Progressive Web Apps (PWAs)
  web app that acts like a native app
    eg. installed as app on phone home screen
  use Service Workers to do work in between session
    eg. load data from page before page is needed
    sync local data, etc.

[Decorators]
similar to Python, you can make a function that takes a declaration and wraps it
the interface is more complicated - look it up when needed
important thing to know is there are decorators you can import (without the @) and use with @
  eg. @log f() {}
  eg. @ViewChild() formGroup: FormGroup;
    Angular people like to use () even when no args, for consistency with the ones that have args
  eg. @SomeDecorator(option1, option2) x: MyClass;
NOTE: this is a uniquely TypeScript feature
  the emitted JS defines the thing being decorated first and then redefines it by a calling the wrapper function
    even though TS won't let you do something like that yourself, it uses it when needed to implement things

[JSDoc]
** see JSDoc notebook for full working example **
similar to docstrings in other languages

/**
  * Adds two numbers.
  * @param {number} a - The first number.
  * @param {number} b - The second number.
  * @returns {number} The sum of the two numbers.
  */
function add(a, b) {
  return a + b;
}

[Testing]
Jasmine
  describe(), it(), etc.
  test files usually in 'specs' folder
Karma
  for running in browser (inc. Jasmine tests)
Angular/Protractor
  based on Jasmine and Karma plus its own stuff like TestBed
  test files usually in same folder as code
Selenium
  browser interaction and screenshots
screendiffs require 3rd party libraries

[JavaScript]
for the most part you can assume JS is like TS except for the things mentioned here
  several differences are mentioend throughout this doc and some may not have made it into this section
in general, JS is much more similar to Python when you remove the TS restrictions and additions
a few operations that are banned in TS are allowed in JS
  eg. adding members to instances at runtime, redefining symbols, etc.
  it is more dynamic and duck-typed like python
TS adds type annotations and generics, which are both swallowed by the compiler
  the JS version uses raw types and no annotations
some JS operations can be done in TS but you have to use things like 'any' to make it happen
  eg. in JS when you make an array, it doesn't care what you add to the array because no type annotations
there are no access modifiers on classes
  or any feature that relies on that, such as Parameter Properties in constructors
  that is why TS has to make everything public by default
there is no 'readonly' modifier for properties
there are no ? and ! nullable function params or class members
  nullability is the norm already
'override' keyword is TS only
some OOP features only exist in TS:
  interfaces
  abstract
  enums
note that a lot of features you might think are added by TS are actually JS
  eg. classes (which are newer), static, constructor, string interpolation, data structures, map(),
      get/set properties, etc.
properties insisde classes can be set either in the body (with no type, like you do in TS with type inference)
  or in constructor since JS lets you add properties at runtime (python style)
  even just saying this: x; // is a statement, though x will be undefined
    if x was defined on base, this will set it to undefined (as of ES2020)
non-existent variables being read from an object will not throw - they will read as undefined
  TS normally doesn't allow you to compile that
the old style syntax for doing classes, which you don't need anymore but might see people doing:
    function Person(name) {
      this.name = name;
    }
    Person.prototype.greet = function() {console.log(this.name);}
    
    // Person() calls the function called Person
    // but the new keyword in front tells JS to treat it as an object and bind 'this'
    // the prototype of the new object comes from the function itself so that it will behave virtually
    const alice = new Person('Alice');
    // because we added greet to the prototype of the class function, it is callable from the instance
    // this is presumably dynamic like Python
    alice.greet();
purely for stylstic convention reasons, for some reason JS people like to assign lambdas to variables
  rather than write 'function' declarations

[jQuery]
3rd party library for JS DOM querying
can reference it via CDN
available by default in Chrome Devtools
plural vs. singular elements are handled transparently
  the same call will apply to either 1 or all elements matching

$(document).ready(() => {})
  protect the code inside from running before the whole DOM is ready

$('#myId')
  find an element by CSS selector
$('#myId').text('new text')
  change its text
$('#myId').css('color', 'blue')
  change a CSS property

$('#myId').click(fn);
  add event handler

$('#myId').hide(500);
  hide over the course of 500 milliseconds

$('.myClass').eq(1).css('color', 'blue');
  only apply to the 2nd element instead of all

let myElement = $('myClass')
myElement.get()
  array of HTMLElement
myElement[0]
  single HTMLElement
myElement.get(0)
  single HTMLElement

$('myClass').append('<div>blabla</div>');
  and various other ways to append, prepend, etc.

$.ajax({url, type: 'GET', success: fn, error: fn});

** see jQuery notebook for more examples **

TypeScript
  if you install jquery and @types/jquery, then you can import * as $ from it
  then you use it as usual
  but in addition, there are types
  eg. the return type of $() is JQuery

[Angular]
templates + styles (encapsulated via shadow DOM and/or extra classes/selectors)
templates compiled into JS code to build DOM
TS code as well
Modules
bootstrapping
dependency injection
jasmine testing
reactive forms

** see Angular notebook for details **
  the framework is too massively huge to cheat sheet-ify it here
  has tutorial examples with commit links, etc.

[React]
React = unidirectional flow, virtual DOM (always being "rebuilt")
dynamically returning templated HTML code from functions
Redux for state management
    and built-in state management functions
virtual DOM used to diff and make less frequent updates to real DOM
TSX and JSX syntax

[CSS]
** see Angular notebook CSS section for full example **

[SCSS]
** see Angular notebook SCSS section for full example **
the main headline feature is the nesting and &

[Flexbox and Grid]
** see Angular notebook Flexbox and Grid sections for full examples **
grid is better for 2D layouts

[HTML]
** see Angular notebook HTML and HTML Forms sections for full examples **
key point is <script> tags to put JS code in

[rxjs]
reactive streams in JavaScript (w/ TypeScript typings)
** see rxjs notebook for examples **

[Interview Tips]
be able to implement stream operations like concat(), zip(), etc.
  use generators
  useful to have these in problems & interviews
be able to implement missing data structures quickly for problems
  esp. heap
  some platforms might let you use some other popular libraries
  for interviews, probably fine to just pretend the Java ones exist here
    be able to implement in case they ask
a lot less collections than other languages
  either implmeent yourself quickly or assume you have the Java ones (and call it out)
as usual, be able to do your own linked list nodes, binary search, etc.
always remember TypeScript cares more about types than JS does
  so something like pretending an object is another type of object won't matter to JS if the properties match
  it would only matter if you're relying on the prototype (the inheritence)
a.reverse() doesn't take index
  either slice it or manually reverse it in a loop
  same goes with sort()
use Infinity and -Infinity for gauranteed max and min in comparisons
  instead of max safe int or whatever like in Java
practice classes and OOP on your own since practice problems don't exercise that
  eg. remember to put 'this' everywhere
practice array and string transforms, regex, etc.
  more idiomatic and performant than in languages like C++ and Java

[Debugging]
console.log()
  use comma-separated values instead of printing line by line (logically groups things)

Chrome DevTools
  depends on sourcemap files for TS - just works for JS (but might have to work with minified if production)
    sourcemaps also can help with debugging minified pure JS
  
  Sources tab
    Cmd-P (or click Open Fiel) and search by part of filename
    click to set/clear breakpoint
    right-click to edit breakpoint (or to add specific type of breakpoint)
      conditional breakpoint

    or go to Event Listener Breakpoints
      can set to break on a listened event (browse by cateogory)
        eg. break on any click handler
  
    XHR/Fetch Breakpoints to break when url contains a substring

    DOM breakpoints
      set from Elements tab
        right-click an element and Break On -> pick what kind of activity to break on
    Data Breakpoints: not available
      could change the code to use a property getter/setter and break in there
    
    Deactivate breakpoints button to temporarily deactivate all breakpoints
    buttons to pause, resume, etc. are in the debugging area (3rd pane)
    Step into (F10) and Step Over (F11), Step Out (Shift-F11)
      remember Step Over just means don't step into, but still executes
    Scope Panel hidden inside the debugging panels (with the breakpoints, etc.)
      has the current variables values
    Watch panel is where you can add watch expressions
      any expression that is constantly evaluated during debugging
      eg. to get a variable value, or something like 'typeof x'
    Console panel at buttom of debugger
      redundant with the Console tab (linked together)
      allows you to execute JS code in the current scope WHILE PAUSED
  
    you can change a source file and cmd-s to save it
      will only affect the copy running in the browser
      will be gone on refresh
    
  you can also put 'debugger;' in the code to force a debugger breakpoint on execution in browser

VSCode
  VSCode has built-in support for Chrome and Edge debugging
  Command Palette -> Debug: Open Link
    give url
    will check default browser and then find Chrome if not Edge
  alternative is to use a Launch Configuration the old-fashioned way
    with "type" equal to "chrome" and then set "url"
    then just hit F5 to run
  the features and options are similar to DevTools
    eg. still no data breakpoints
    this part is dependent on the installed debugger, not on VSCode
      but for JS/TS, it's built-in to VSCode
  "Run" menu for debugger commands
  "Run and Debug" panel on left
