** rewrite of this sheet is in progress **
** steps:
** 1. go through notebooks again in detail and merge into what's here (mostly replace, but make sure nothing missed)
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (probably less to find from there, but some stuff like operator overloading will match)
** 4. see if any new versions since last time (and mark current version here)

** because C++ is unique in many ways, this sheet has a lot of topics the other languages don't **
** the "unique aspects of C++" portions are in this sheet and not in notebooks diretly **

[Playground]
https://cpp.sh/ - to try things out quickly to answer questions

[General]
more complex with a lot more parsing edge cases than other languages
    eg. most vexing parse
this is because of a few reasons:
    - philosophy of radical backward compatibility
    - philosophy of providing total control over memory and execution
    - long history with diverse needs serving embedded, desktop, etc.
see snippet 10 of Language-Specific Features for more details

[Code Layout]
header vs. source file
forward declarations
directives & macros (preprocessor)

[Variables]
Unique Aspects of C++
    stack vs. heap allocation of all types
        automatic variables for stack
        potential memory leaks for heap (have to use smart pointers or call delete)
    just making a variable causes automatic allocation, constructor call, etc.
    just making a global variable causes code to execute before main
        with possibly undefined order due to things like DLL loading, 
            lack of order guarantees between modules, etc.
    operators can end up calling a lot of code secretly due to operator overloading
    = can be a constructor call or assignment operator call depending on context
    pointers and references (and nothing like the concept of reference from other languages)
    direct, unamanged access to blocks of memory
    no reference vs. value type
        everything is value type and will get lots of expensive copying if not careful
    lack of garbage collection on references/pointers
    unsigned integers
        not strictly unique, but a lot of languages don't have (Java, Python, TypeScript, etc.)
    multiple ways to refer to same primitive types
    differences in type sizes on platforms
    junk-initialized variables
    inline static variables
    need ; after {} for enums, structs, unions, classes
    explicit control over things like constexpr, alignas, etc.

Primitive Data Types
    literals need suffixes if greater than int or less than double

    char, bool -> usually 8-bit
        char can be treated either as a number or a character
    short int, short -> usually 16-bit
    int, long, long int -> usually 32-bit
        literal suffix = UL for unsigned long
    long long, long long int -> usually 64-bit
        literal suffix = LL for signed, ULL for unsigned

    wchar_t - 16-bit or 32-bit depending on platform
        usually 16 on Windows, 32 on Linux
    char16_t and char32_t - utf-16 and utf-32 (approximately)
        not as fully supported by things like std::cout

    float - usually 32-bit
        literal suffix = f
    double, long double -> usually 64-bit
        literal suffix = L for long double

    UNSIGNED: add 'unsigned' before any integral type (inc. char)
    SCIENTIFIC NOTATION: -3e-4, 2e7, 0.1e-10, etc.

    pointers are also a primitive type and are covered separately below
        references are not a primitive in the same way
Declarations
    int x, int y;  // both initialized to junk
    int z = 10;
    int a = 10, b = 20, c;

    int *x, y, *&z = x; // crazy mixing (due to how * and & bind to variable)

    const int x = 10; // x can never change again
        when you take a pointer or reference to this variable
        it will look at whether you declared the pointer or reference as 'const int'
        if you did not, it won't let you do it!
        that is to stop you from going around the constness of the variable
        you could technically const_cast it to go around it but you shouldn't generally
    const int x; // ILLEGAL (must initialize it inline)
    const MyClass m; // ok if has a DEFAULT CONSTRUCTOR

    static int x;
        variable created first time code passes through this point
        then continues to live and see changes

        note that 'static' is a "storage specifier" and is not part of the type of the variable
            whereas 'const', '&", and "*" are
            this means 'static' is not seen by 'auto' or typedefs
Global Variables
    any variable declared at the global scope (not in a function, class, etc.)
    initialized before main() called
    available for whole duration of program
    they're basically the same thing as static variables
        the main difference is their visibility
        and also when exactly they get initialized
Scope & Visibility
    ordinary block-scoping like you'd expect
    none of the weird JS 'var' or Python every variable behavior
    you can also use {} to make blocks within blocks arbitrarily

References
    int &x = y;
        x always refers to y and cannot be rebound
        if y is reassigned, x sees the new value
        if x is reassigned, y sees the new value
        it is a secret pointer dereference underneath
    a reference in a class must be bound in the c'tor initialization list or inline
    MyClass &r = m;
        if r is reassigned, then assignment operator called on m itself
        it is not like references in Java where you are just changing the reference
            that is more like how a pointer behaves here
    const int &x = y;
        x = 100; is ILLEGAL
    const int x;
        int &y = x; is ILLEGAL because non-constant ref to a constant
    int &&x = 100;
        x is rvalue reference
        int &x = 100; is ILLEGAL
    MyClass &&x = std::move(y);
        converting to rvalue reference explicitly using built-in function
        y should be considered invalid/unuseable after that
    & does not chain endlessly like pointers (no &&& for instance)
    sizeof() on a referene is sizeof() the referenced variable, not the secret pointer
Pointers
    int *p = &x;
        p is a pointer to integer (* binds to p)
        & is address of operator
        p holds an address
    int y = *p;
        retrieving x via the pointer
    *p = 100;
        changing x via the pointer

    int **q = &p;
        pointer to pointer (address of variable holding address)
    int y = **q;
        retrieve via double dereference
    **q = 100;
        set via double dereference
    *q = &someVariable
        set the intermediate address instead
    
    int *&r = p;
        r is a reference to an int* (reference to p)
        thus it will act as an int*
    *r = 100;

    func(*p);

    Pointer Arithmetic
        p[n] or *(p + n)
            both add the size of the data type times n, then dereference
        p += 2
            doesn't add 2 to the address, but adds 2 * sizeof(whatever the data type is)
        if reinterpret_cast to char*, you can retrieve/modify individual bytes instead

    Member Access
        p->x
            member x of object pointed to by p
        r.x
            member x of object referenced by r
            or object that actually is r in the first place
        p[2].x
            3rd object in array
        pp[2]->x
            3rd pointer in array dereferenced to object elsewhere
    constant
        const int *p = &x;
            p cannot be used to change the value
            const binds to int, meaning the value itself can't be changed
            but p, the pointer, can be reassigned to a differnet address
            p += 2; // fine
            *p = 10; // illegal
        int * const q = &x;
            in this case, const binds to q instead of the int
            so q itself cannot be changed, but it can be used to change the target value
            *q = 10; // fine
            q = &x; // illegal
        const int * const q = &x;
            can combine by putting in the right places as needed
            count backwards from the variable to put const in between other places in the chain
    size of pointers
        usually 64-bit nowadays
    void*
        void* is a special type that means we don't know what the type is
        since all pointers just store memory addresses and are same size
        any point can implicitly cast to void*
        void* can static_cast to any other * type
        banned operations: pointer arithmetic, dereferencing

Nullability
    nullptr = special literal for pointers that are set to 0
        eg. if (p == nullptr) {}
        eg. const int *p = nullptr;  // otherwise would be junk instead of nullptr
    there is no such thing as a null reference because you are required to bind a reference
    variables that are not pointers or references have no concept of nullability at all
    always remember that both pointers and references can become DANGLING
Dynamic Allocation
    heap instead of stack
    int *p = new int;
    int *p = new int(100);
        allocate the value 100 on the heap
    int *a = new int[100];
        allocate 100 junk values on the heap
    int *a = new MyClass[100];
        only legal if MyClass has default constructor
        100 instances default constructed
    int *a = new int[100]{1, 2, 3};
        specifying the first 3 values
        the rest automatically become 0 instead of junk!
    int *a = new int[100]{0};
        100 zeroes
    int *a = new int[100]();
        100 zeroes
    int *a = new MyClass(arg1, arg2);
        can pass constructor arguments if single value
    int *p = new MyClass;
        default constructor if no args
    
    delete p;
        deallocate a single value
    delete[] a;
        deallocate an array
Automatic Variables
    local variable declarations that don't use 'new'
        stored on stack
    but otherwise look like the examples in Dynamic Allocation
        along with compact versions like this:
            MyClass m;
            OtherClass o(m);
    the automatic variable's destructor is called when it goes out of scope
    an automatic variable in a class's declaration is stored as part of the class
        could be on stack or heap depending on where the class is allocated
        a non-default constructor can be chosen in the class constructor initialization list
            or inline
Smart Pointers
    <memory>
        unique_ptr<int> p(new int);
        *p = 100;
        // no delete needed (called when p out of scope)
        p.reset()
            if want to explicitly release it instead
        
        shared_ptr<int> p = make_shared<int>(100);
        *p = 100;
        shared_ptr<int> q = p;
        *q = 1000;
        p.use_count() will be 2 in this case
        q.use_count() is also 2
        p.reset()
            explicitly release one of them
            or else destructor will do it later
        // refcounted, object deleted when count goes to zero

        neither of these are meant to be mixed with using naked pointers
            assume they have full control of the object
            at least from an ownership perspective
            eg. if you pass a naked pointer from a unique_ptr but never delete it
        one way to use them could be to have a unique_ptr owning a pointer as a class member
            then you could pass the naked pointer however you want
            the class owns the dynamic storage
Default Numeric Values
    all numeric types, including integers, floats, pointers, chars
    initialized to junk if local, instance, or heap allocation
        because just doesn't overwrite whatever was on the stack or heap before
    initialized to 0 if static or global allocation
        because static and global are same storage
        and because the program can hardcode the value in the data segment
Delayed Initialization
    local variables don't HAVE to be initialized unless const and/or reference
    class instance members follow the same rule
        except they can be initialized in constructor initialization list instead of inline
Placement New
    have to import <new>
        but no namespace needed for the operator
    
    MyStruct *ptr = new (&storage) MyStruct(42, 3.14);
        constructors an instance of MyStruct into the memory of the storage variable
        doesn't dynamically allocate anything, so never need to delete
        eg. you could dynamically allocate a block first
            then customize the constructor calls with placement new
    because delete is never called, you will have to call the destructor at some point
        if it's necessary, which it won't be for all classes
            doesn't hurt to just always call it though
        ptr->~MyStruct();
    you could use std::aligned_storage to create storage for this
        <type_traits>
            aligned_storage<sizeof(MyClass), alignof(MyClass)>::type storage;
                this example creates it on the stack and cleans it up automatically
                to do it dynamically, create this with 'new'

Type Aliases
    typedef int Integer;
        anywhere in code you can use Integer as the type
        and C++ will know it's really int
    using Integer = int;
        newer, more readable version of the same thing
    unlike with 'auto', type aliases include const, &, etc.
        eg. using cstringref = const std::string&;
            cstringref r = mystring;  // const reference to mystring
        despite the fact that & normally binds to the variable instead of type

    typedef void(*MyFunctionPtr)();
    using MyFunctionPtr = void(*)();

Examining Numeric Type Properties
    <limits>
        numeric_limits<int>::max()
        numeric_limits<int>::min()
Float Near-Equality
    <cmath> 
        fabs(): absolute value of float
            fabs(a - b) < epsilon
Float Special Values (part of IEEE standard)
    <limits>
        numeric_limits<double>::quiet_NaN()
        numeric_limits<double>::infinity()
        -numeric_limits<double>::infinity()
    <cmath>
        isnan(x)
        isinf(x)
            true for negative infinity as well

Enums
    Old-Fashioned = just int with special compile-time constants basically
        enum Color {
            RED,    // 0
            GREEN,  // 1
            BLUE    // 2
        };

        enum Color2 {
            RED = 3,
            GREEN, // 4 automatically
            BLUE = 10
        };

        Color c = RED; // unqualified compile-time constants for members
        int x = c; // implicitly castable to integer because really integer
        c = (Color)(RED + 1) // not implicitly castable the other way
            use c-style or static_cast
        c can become a value other than the ones provided
        std::cout would see it as an integer and print the number instead of the name

    Strongly-Typed Enums (enum classes)
        enum class TrafficLight {
            RED,
            YELLOW,
            GREEN
        };

        // changing the backing type (integral types only)
        enum class TrafficLight: char { // backed by char insted of int
            RED,
            YELLOW,
            GREEN
        };

        TrafficLight t = TrafficLight::RED;    // qualfied like static
        std::cout cannot print it by default because it's not an integer!
        not implicitly convertible
            static_cast<int>(t) to get the int value
        if (t == TrafficLight::RED) {}
        static_cast<TrafficLight>(2)
            but will accept an invalid number still!

Type Inference
    'auto' keyword = compile-time type inference

    auto a = 5; // int
    auto d = 0.1; // double
    auto s = "Hi!"; // const char * (a special case of inferring 'const')

    auto &x = y; // auto will not infer & because it doesn't know you want that
        if you did auto x= y, it would assign BY VALUE
    auto *p = arr;  // auto can be told there's a * there
    auto p = arr;   // it can also infer it

    const auto &x = y;
    auto &x = y; // if y is constant, then auto will know it needs to make 'const int' here too
        otherwise, auto will not infer 'const' because it has no reason to

    auto fn() { return 5; }

    decltype(a) b = 10;  // type matched to another variable (even if auto)
    decltype(a) d;
    decltype(a + b) c;  // eg. if a and b are two different types and you want the type of the result
    
    auto fn(int a, int b) -> decltype(a+b) {}

    decltype works with generic types in templates too!

Unions
    unions look like structs
        but the members OVERLAP
        effectively it is only storing one of the members at a time
        assigning to another one clobbers it

    union Data {
        int i;
        float f;
        char str[20];
    };
    Data d;
    d.str[0] = 'h';
    d.str[1] = 0;
    d.i = 10; // overwrites d.str completely (and then some)

Structs
    structs are technically as fully featured as classes but with default public members
        see "Classes" for more details
    but for the purpose of this section, they're simple wrappers of data (POD types)

    struct MyStruct {
        int x, y;

        const char *name;
        const char description[100];
    }; // semicolon required

    MyStruct s;
    MyStruct s = {10, 20, "Hello", {}};

    s.x = 100;
Bitfields
    bitfields are a feature of structs
        and probably classes too, but the typical use case is POD structs
    let you specify # of bits to use per field so that you can pack it in tigheter

    struct MyBitField {
        // Bitfield with 1 bit. Can hold values 0 or 1.
        unsigned int is_enabled : 1;
        // Bitfield with 4 bits. Can hold values from 0 to 15.
        unsigned int type : 4;
        // Bitfield with 27 bits. Can hold values from 0 to 134217727.
        unsigned int id : 27;
    };

    assigning outside of range will give compiler warning if it can detect it
        if not, then undefined behavior at runtime
            maybe clobber other fields?

volatile
    like in Java
    stops variable from being cached in registers separately on separate threads
    doesn't make it atomic or mutex-locked or anything like that though

constexpr
    specifies that a variable should be computed at compile-time
    specifies that a function that is given compile-time constants will return a compile-time constant
        making it usable in compile-time constants
    simple loops and conditions are allowed
    offloads some runtime execution to compile-time
        especially things that don't change like precomputed values and lookup tables
    implicitly makes the variable 'const' as well (no way to modify at runtime)

    constexpr int square = 10 * 10;
    constexpr int add(int a, int b) {
        return a + b;
    }
    constexpr int result = add(5, 3);

    you can declare a constexpr constructor on a class
        that will allow you to declare a constexpr variable holding an instance
constinit
    like constexpr, except doesn't make the variable 'const'
    initialized at compile-time, but can be changed at runtime

alignas()
    alignas(int) short x;
    alignas(16) int arr[100];

    see "Operators" for details
    lets you specify the word alignment of a variable in memory for performance

uniform initialization
    see "Classes" section

all the meanings of 'static'
    1. local variables
        set first time and then stick around for future calls
    2. member variables
        set first time outside class and then stick around to be referenced with ::
    3. member functions
        defined in class and called with ::
    4. internal linkage
        turn global variable or function into internal linkage
    5. static polymorphism
        templates, function overloading, etc.

Not Supported: interning/pooling

[Collections]
Unique Aspects of C++
    arrays are really pointers and aren't managed at all
        and are fixed length, requiring a special vector data structure for resixable ones
    multidimesional arrays are layed out contiguously instead of as array of references
        because array is not a reference type (no such concept here)
    immutability via const correctness
    collections don't automatically print or convert to string
    hashing provided by a template specialization instead of member function or passed in (weird!)
    swap() method by reference that works on anything
    algorithm header has a lot of very specific CS (leetcode/interview type) operations
    structured binding declarations look like tuple unpacking
        but behave fundamentally differently, such as taking by reference
    has a decent linked list structure with direct access to internal nodes for O(1) operations
        Java, Python, TS, etc. are missing this

Array
    an array variable is actually a POINTER underneath
        thus, it has no protection or length property
            and is not resizable

    int arr[] = {1, 2, 3};      // [] binds to the variable, not the type (just like a pointer)
        automatid size of 3
    int arr[10] = {1, 2, 3};    // specifying size (unspecified items become zero)
    int arr[10];                // junk values
    int arr[x];                 // can be runtime chosen size

    NOTE: you cannot skip items in the array initializer (other than truncating off the end)

    int *p = arr; // no & needed because arr is already a pointer
    int *q = new int[100];

    MyClass arr[10];    // only legal if has default constructor
        or if you do it dynamically with placement new

    int matrix[][3] = {{1, 2, 3}, {4, 5, 6}};
        you are only allowed to ommit the 1st dimension
        because it lays out contiguously and needs to know the structure
        related to the idea of array decay (see "Functions")
    int matrix[2][3];
    int matrix[][2][3];
    NOTE: a multidimensional array is not the same thing as **
        because it's not storing pointers inside

    arr[0] same as *arr
    sizeof() on an array works if locally defined (and not decayed to pointer)
        sizeof(arr)/sizeof(arr[0]) gives # of elements

trailing commas are allowed in initializers but not function calls
    eg. int arr[] = {1, 2, 3,};
        but not f(1, 2,)

std:: namespace needed in front of all symbols imported from stdlib headers below
    ommitted for brevity in these notes

Common std:: collections members
    all collections have optional std::allocator template arg
        and members like allocator_type and get_allocator()
        this is there in case you want to customize how storage is allocated
    Typedefs
        value_type
            eg. for vector<int>, vector<int>::value_type will be int
        reference, const_reference, pointer, const_pointer
            these are defined in terms of value_type

        size_type = size_t
        different_type = ptrdiff_t

        iterator
            iterating over value_type elements
        reverse_iterator
            like iterator but goes backwards
        const_iterator
            like iterator but can't be used to change elements
        const_reverse_iterator
    Methods to Get Iterators
        begin() and end() for ordinary iterators
            end() is exclusive (eg. one past end of collection)
        cbegin() and cend() for constant iterators
        rbegin() and rend() for reverse iterators (when supported)
        crbegin() and crend() for constant reverse iterators (when supported)
    
        you can do arithmetic on iterators to get # elements, indices, etc.
    Size Methods
        size(), empty()
    Modification Methods
        clear()
        insert(iterator, value)
            insert a value before an iterator
        insert(iterator, srcIterator1, srcIterator2)
            insert a range of values
        insert(iterator, initializer_list)
            insert an std::initializer_list of values (for {} syntax)
        
        emplace(iterator, arg1, arg2, ...)
            like insert(), but a new value is constructed in-place using forwarded ctor args
            some containers will have emplace_back() and similar instead of taking iterator
        
        erase(iterator)
            single value
        erase(iterator1, iterator2)
            range
    Storage Methods
        swap(other)
            cheaply swap storage with another collection of the same type
            iterators remain valid, but stay with the data they come from (not the container)
    Non-Member Helper Functions
        std::swap(container1, container2)
            specialized to cheaply swap storage
        std::erase(container)
            specialized to clear a container
        std::erase(container, value)
            specialized for some containers to erase occurences of value in container
        std::erase_if(container, predicate)
            specialized for some containers to erase elements matching a predicate

    operator<, operator==, etc.
        when available, these tends to do lexographical comparison element-wise
            forwarding the comparison operator down to elements, which may forward again internally

    methods like insert() will add allocation as necessary
        different from the <algorithm> functions which cannot do that because only have iterators

vector<T>: dynamic array
    <vector> header
    a lot of operations mentioned here are present elsewhere
        this is basically the prototypical std collection

    vector<int> v;  // new empty vector
    vector<int> v = {1, 2, 3, 4, 5}; // creating with values
    vector<int> v(10); // 10 zeroes (not junk)
    vector<int> v(10, 100); // 10 100s
    vector<int> v(beginIterator, endIterator); // copy range of another container
    vector<int> v(otherVector); // copy constructor
    vector<int> v = std::move(otherVector); // move constructor

    v = {1, 2, 3, 4, 5}; // std::initializer_list assignment
    v = otherVector; // copy assignment
    v = std::move(otherVector); // move assignment

    v.assign() overloaded similarly to the constructors
        replace contents (inc. adjusting size)

    v[0]
        access by reference (read-write, or read if const)
        no bounds checking
        v[0] = 5;
    v.at(0)
        access by reference (read-write, or read if const)
        bounds checking (throws std::out_of_range)
        v.at(0) = 5;
    v.front() and v.back()
        references to first and last element
    v.data()
        the underlying array
        which can become stale if you modify and it reallocates

    v.size()
        number of elements actually used
    v.empty()
    v.capacity()
        number of elements allocated but not necessarily in use
    v.reserve(n)
        change the capacity
    v.shrink_to_fit()
        try to reduce capacity to match size
    v.resize(n)
        truncate if shrinking
        overload to provide values if growing

    v.push_back(item);
    v.pop_back();
    v.clear();
    v.insert(iterator, count, value)
        in addition to the common insert() overloads usually present
    v.append_range(container)
        like doing push_back() on each item in the iterable container

    v.emplace_back(arg1, arg2, ...)
        like emplace() but goes straight to the back

    operator<, operator==, etc.
        lexographical comparison
        uses memberwise comparison operators on elements from left to right
    no operator+, etc.
        can't use + to concat arrays or vectors like in Python

    random access iterator operations

    specialized for bool to use single bits for compactness

list<T>: doubly-linked list
    <list> header

    basically same interface as vector<T> with these differences:
        also has l.push_front() and l.pop_front()
            equally efficient to the *_back() versions
        insertion/deletion in the middle (via iterator) is O(1)
        no indexing because not random-access
        bi-directional iteration, but not random access

forward_list<T>: single-linked list
    <forward_list> header

    like list<> but only the front operations
    keeps head internally but not tail

map<TKey, TValue>: sorted map (binary search tree)
    O(logn) lookups (no hashing)
    <map> header
    optional template arg for comparison function
        defaults to std::less (as the function, not the result of calling the function)
        you can use type inference to invoke it automatically by using c'tor that takes comparison fn

    value_type is std::pair<const TKey, TValue>
    key_type and mapped_type for TKey and TValue
    key_comparer = the compare template arg (default std::less)

    map<std::string, int> m;
    map<std::string, int> myMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
    also overloads that take comparison function (eg. less())
        default constructs the comparison template arg as Compare()
    and similar overloads to vector
    similar assignment operations to vector as well

    m["Apple"] = 10; // no bounds checking
        inserts if not there, even if you just read it
        no const overload, unlike at()
    m.at("Apple") = with bounds checking (std::out_of_range)
        m.at("Apple") = 20; // by reference

    keyValuePair = m.insert({"Apple"}, 10);
        won't do it if key already exists
        return value tells you what's in there now (either old thing or your new thing)
    m.insert_or_assign(key, value) = method version of using index or at()
        return value to tell you what's in there now (like insert() above)

    m.emplace() will only emplace if the key is not there
        like m.insert()

    m.erase("Apple"); // erase by key

    bi-directional iterable as std::pair<TKey, TValue>
        definitely will want to use 'auto' in the for loop
        and/or possibly structured binding declarations to unwrap the pairs
        this is the only way to iterate (no keys() and values() members like Java)
        the keys are immutable but the values are mutable
            so you can actually update the map in-place this way

    if (m.find("Banana") != m.end()) {
        std::cout << "Map contains key Banana." << std::endl;
    }

    m.extract() to remove and return entries
    m.merge() to merge in another map

    m.contains(key)
    m.count(key)
        0 or 1 for map, but maybe more for multimap
    
    m.upper_bound(key), m.lower_bound(key), m.equal_range(key)
        mostly makes sense for multimaps, but it's in here too
        lower bound = first matching entry
        upper bound = first non-matching entry
            they are same if empty range
        equal_range = pair of both
        entries returned are std::pair, but key is used to find them

    operator<, operator==, etc.
        lexographical comparison of keys (not values)

unordered_map<TKey, TValue>: unsorted version of map
    O(1) lookups
        relying on operator== and hash, but not operator<
    <unordered_map> header
    exposes same interface as map<> but doesn't use a tree internally
    
    instead of Comparer optional tempalate arg, has Hash and KeyEqual
        defaulting to std::Hash and std::equal_to

    constructor has overloads to specify initial bucket count
        you can interact with the buckets and load factor with methods if you really want

    iteration is forward only (no reverse)
        and order between runs is not guaranteed to be consistent

    operator== and operator!=, but not operator<, etc. since no order

set<T>: sorted set (binary search tree)
    O(logn) lookups
        operator==, no hash
    <set> header

    looks a lot like map<> except:
        value_type is T because not pairs
        iteration is over T, not pairs
        no [] or .at() because not indexed (even if ordered)

    can be bi-directional iterated because has an order to it

    you can use set operations from <algorithm> like std::set_union
        those rely on sorted sequences, which this is

    set<int> s;
    set<int> s = {1, 2, 3, 4, 5};

    s.insert(10); // ignores if duplicate
    if (s.find(10) != s.end()) {}
    s.erase(10);

unordered_set<T>: unsorted set
    O(1) lookups
        operator== and hash, but not operator<
    <unordered_set> header
    
    same interface as set<T> except:
        only forward iteration (and order not guaranteed)
        can't use set operations from <algorithm> because not sorted
        for other considerations, see difference between map<> and unordered_map<>

multiset<T>, unordered_multiset<T>
    in <set> and <unordered_set> headers (instead of their own)
    like set and unordered_set, but can add same value multiple times
    when you iterate the set, you'll see the same value multiple times
        not grouped together or anything like that (though the ordered one will put them adjacent)

multimap<T>, unordered_multimap<T>
    in <map> and <unordered_map> headers (instead of their own)
    like map and unordered_map, but can add same key multiple times
    when you iterate, you'll see the same key multiple times
        not grouped together or anything liekt hat (though the ordered one will put them adjacent)
    because of the ambiguity, you cannot use the [] operator or at()
        use m.equal_range(key), m.lower_bound(key), and/or m.upper_bound(key) instead
        these methods make more sense here than in map<> where they also exist

tuple<T1, T2, ....>: mixed type sequence of objects
    <tuple> header
    very unusual collection compared to the others
    instead of an object with methods, you use a bunch of functions
        several of which use template metaprogramming and similar constructs
    one reason it's like this is so other kinds of objects can specialize the templates to act as a tuple
        eg. for structured binding declarations
    the tuple functions are specialized for std::pair, std::array, etc. but not raw arrays

    tuple<int, std::string, double> my_tuple(10, "Hello", 3.14);
    auto my_tuple = std::make_tuple(10, "Hello", 3.14);

    std::get<0>(my_tuple);
        retrieval uses integer template arg in a function, instead of a method
    std::get<0>(my_tuple) = 20; // returns reference

    std::tie(var1, var2, var3) = my_tuple;
        tuple unpacking
        tie object takes variables by reference and sets them from assignment operator

    std::tuple_size<decltype(my_tuple)>::value
        to get # of elements
    std::tuple_elements<decltype(my_tuple)>::type
        to get type of an element
        for declaring another variable to hold the value, for instance

pair<T1, T2>: two possibly different types
    <utility> header

    pair<int, int> p = {1, 2};
    auto p = std::make_pair(1, 2);

    p.first, p.second

    p.swap(q);  // swap elements of two pairs

    operator<, operator==, etc.
        lexographical comparison of items

deque<T>: double-ended queue
    <deque> header

    like a vector with fast insertion and removal at both ends
    random access iteration

    push_front(), push_back()
    front(), back()
    pop_front(), pop_back()

stack<T>
    <stack> header

    s.push()
    s.top()
    s.pop()

queue<T>
    <queue> header

    q.push()
    q.front()
    q.pop()

priority_queue<T>: maxheap by default
    <queue> header
        this one is odd because it isn't in a header named after it
    
    q.push();
    q.top();
    q.pop();

    to make a minheap:
        priority_queue<int, std::vector<int>, std::greater<int>> q;
            the middle arg is because there is no overload with only the 2 args we want
            the middle arg says what kind of container to use for the heap structure

array<T, n>: wrapper for array
    <array> header
    adds std features like size(), etc. while maintaining the performance of the raw array
    makes its own array, rather than wrapping an existing one
    not necessary for using <algorithm> and such though

    array<int, 5> arr = {1, 2, 3, 4, 5};

valarray<T>: numeric processing library
    <valarray> header
    old-fashioned, replaced by newer, better 3rd party libraries
    so old it doesn't have iterators
    supports element-wise operations between valarrays (similar to numpy)
    also slicing and stuff like that

bitset<n>: bit mask with n bits
    <bitset> header

    bitset<8> b("01100011");
    bitset<8> b;    // all zeroes

    b.set(4);   // set a bit
    b.get(4);   // test a bit (whether set or not)

    b.reset(), b.count(). b.flip()
    b[i]

    bitset<8> c = a & b;    // bitwise AND on all the bits
        and other bitwise operators

    supports stream operations for output (as binary digits)

Iteration
    no interfaces, classes, or operators for iteration
    instead, it's a pattern of operations that would work on it (duck-typed)
        basically certain pointer-like operations
        different kinds of iterators depending on which subset of pointer-like operations

    MyClass::iterator it = m.begin();
    advance(it);
    *it to get value

    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        std::cout << *it << std::endl;
    }

    a custom iterator should implement:
        * operator
        != operator
        ++ operator

        [] operator if random access
        pointer arithmetic if random access

    a custom iterable object should implement:
        begin() method to return an iterator representing the first item
        end() method to return an iterator representing the exclusive end of the sequence
            which should properly do arithmetic with the other iterators in the sequence
        begin() and end() are same for empty sequence

    a lot of functions, such as the ones in <algorithm>, take 2 iterator for a range
        first one is inclusive, second one is exclusive
        they often return an iterator for the value, returning the end iterator if not found or whatever
        this allows the functions to generically iterate over various types of containers by static duck-typing

    note that since iterators are designed to act like pointers, real pointers work too
        which means functions in <algorithm> can be used on arrays
        don't worry about the end iterator being passed the end of the array
            it will only be used for math - not dereferenced

    Categories of Iterators
        Random Access
            support all pointer operations, including [], operator-, etc.
        Bidirectional
            no arithmetic or [], but increment and decrement fine
        Forward
            no arithmetic or [] or decrement
        Reverse
            acts like a forward iterator, but actually points to items of container in reverse
            not directly interoperable with forward iterators, but you can call it.base() to get a forward iterator
                the caveat is that this forward iterator is the element after the current element
                    so that you can use the current reverse item as exclusive endpoint of range
        Input/Output
            single pass

    std::distance
        <iterator> header
        can compute distance of any iterator type
        for random access where operator- is supported, just subtracts
        for other types, will do O(n) opeation to scan between the endpoints

size_t, size_type
    size_t is a system-dependent (but usually unsigned long long) value for sizes/addresses/indices
    it is defined in many standard library headers and used by containers
    it is also typedefed in collections as size_type

    for (vector<int>::size_type i = 0; i < v.size(); i++) {}

    ptrdiff_t is the signed type for pointer arithmetic

Immutability
    no built-in immutable collections or immutable proxies
    but if you declare a variable, reference, or pointer as 'const', you can lock it down
    when you declare it as const, you will only be cable to call 'const' methods on the collection
    this is a key feature of C++ that is much more efficient than the Java proxy way

Aggregation
    <algorithm>
        max_element(iterator1, iterator2)
            returns iterator for max element in range
        min_element(iterator1, iterator2)
            returns iterator for min element in range
        count(iterator1, iterator2, value)
            count occurences of value in range
    
    <numeric>
        accumulate(iterator1, iterator2, seed)
            essentially a reduction using + operator

Slicing
    for arrays, pass a pointer to the beginning of the slice
        have to pass length anyway, so just adjust length to end the slice
    for other containers, you have to std::copy them
        or something similar like use a constructor that takes iterators
            eg. std::vector v(oldvector.begin() + 2, oldvector.end() - 3)

Printing and String Conversion
    besides std::string, the std collections don't have this automatically
    if you try to std::cout a vector, for instance, you'll get an error

Copying/Cloning
    <algorithm>
        copy(srcIterator1, srcIterator2, dstIterator1)
            the space needs to exist (ex. resize the vector first)
        copy_if() = same but with a predicate to decide whether to include
            returns end iterator so you know how many it copied
    constructors that take iterators can also copy
        std::vector<int> v(old.begin(), old.end());

    in general, deep copying is the default in C++ because it is not referenced-based

Conversions
    constructors that take iterators can be used to convert
        because iteration doesn't care what the container type is
    std::set<int> s(vec.begin(), vec.end());
    std::vector<int> v(arr, arr+sizeof(arr)/sizeof(int));

    to get an array from a collection:
        int arr[vec.size()];
        std::copy(vec.begin(), vec.end(), arr);

Sorting 
    <algorithm>
        sort(iterator1, iterator2)
            ascending sort
        sort(iterator1, iterator2, std::greater<int>())
            descending sort
        sort(iterator1, iterator2, fn)
            fn should be an int function on two values of the type of the collection
            < 0 for a < b, == 0 for a == b, > 0 for a > b
            eg. for ints, a - b is perfect
Shuffling
    <random>
        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(numbers.begin(), numbers.end(), g);

Thread Safety
    no built-in collections are build to be thread safe
    there are no thread safe equivalents either
    it is up to you to properly protect your usages with mutexes, etc.

Searching
    most return iterator
        collection.end() if not found 
        iterator - collection.start() if need index
    use reverse iterators to search backwards 

    <algorithm>
        find(iterator1, iterator2, value)
            linear search
            returns iterator
        find_if(iterator1, iterator2, unaryPredicate)
            linear search for matching predicate
            returns iterator
        find_if_not(iterator1, iterator2, unaryPredicate)
            oposite of find_if
            returns iterator

        binary_search(iterator1, iterator2, value)
            for sorted sequence
            returns boolean
        lower_bound(iterator1, iterator2, value)
            also a binary search, but returns iterator
            1st occurence of element if found
            next highest element if not found
        upper_bound(iterator1, iterator2, value)
            binary search returning iterator
            next higher element than value, whether found or not
            the idea is that if you lower lower_bound and upper_bound as the endpoints,
                you have the range of values equal to value in the collection
                so upper_bound is made to be exclusive upper bound
                    equal to lower_bound if value not present (thus giving an empty sequence)

        search(iterator1, iterator2, subiterator1, subiterator2)
            linear search for subsequence within host sequence

Implementing Elements for Collections
    operator== for operations like find()
    specialize std::hash for unordered maps and sets
    operator< for sorting (inc. in sorted maps and sets)
        or a custom comparator function passed into appropriate places
            eg. std::greater<T> to reverse the sort
        also used for binary searching
    override operator<< with ostream& on the left to support converting to string
        compatible with both std::cout and std::stringstream
        built-in collections do not have this

Custom Hasher
    specialize the std::hash template
    std::hash instance is callable with a value to hash
    use xor to combine hashes of members of your class

    namespace std {
        template <>
        struct hash<MyClass> {
            size_t operator()(const MyClass& obj) const {
                // Combine the hashes of individual members
                return hash<int>()(obj.getId()) ^ hash<string>()(obj.getName());
            }
        };
    }

    collections will automatically use std::hash<T>, which will pick up your specialization

Swap
    <algorithm> swap(a, b) method swaps two items BY REFERENCE
    so it can be used for anything - variables, array elements, dereferenced pointers, etc.

Other Algorithms
    <algorithm>
        a lot of these have _if versions to apply a predicate to decide first
            and some also have _if_not
        also, the simplest versions are shown here, but they have a LOT of overloads
            eg. predicates to guard operations and operators to transform values
        this is a very small list compared to the amount of functions in <algorithm>
            there are a lot of interview/leetcode type operations in there

        reverse(iterator1, iterator2)
        for_each(iterator1, iterator2, voidFn)
        replace(iterator1, iterator2, oldValue, newValue)
        fill(iterator1, iterator2, value)
        remove(iterator1, iterator2, value)
            shifts elements forward toward beginning of collection
            returns iterator to 1st now invalid item
        unique(iterator1, iterator2)
            similar to remove(), but removes duplicates in sorted range
        all_of(iterator1, iterator2, predicate), any_of(), none_of()

        rotate(iterator1, newStartIterator, iterator2)
            rotates the elements so that newStartIterator becomes the new first element
            returns iterator to the new location of iterator1 element
        next_permutation(iterator1, iterator2)
            next lexographic permutation of sequence w/ wraparound
        prev_permutation(iterator1, iterator2)
            opposte of next_permutation()

        transform(iterator1, iterator2, outputIterator, unaryOperator)
            like map() in functional programming

        set_union(), set_difference(), set_intersection(), set_symetric_difference()
            all these expect two SORTED ranges
            output into a 3rd range and return end iterator (past last element) so you know how many

        iota(iterator1, iterator2, startValue)
            fills a range with increasing integer sequence starting with startValue
        partial_sum(iterator1, iterator2, outputIterator)
            computes inclusive prefix sum of each element in the sequence

        mismatch(range1Start, range1End, range2Start, range2End = range2Start + (range1End - range1Start))
            finds first mismatch between two ranges via operator==
            returns a pair of iterators, the last iterator for each of the two ranges
            if mismatch found, the iterators will point to the mismatching element from each
            if not found, at least one of the iterartors will be an end iterator
                both if equal size ranges
        adjacent_find(iterator1, iterator2)
            gets iterator to first pair of elements that match each other in a range

Predicates, Operators, etc.
    see "Functional" section
    you can use these with overloads of <algorithm> functions so you don't have to make your own lambdas, etc.

Destructuring
    the feature is called "Structured Binding Declarations" in C++
        it looks like but is not exactly equivalent to destructuring or tuple unpacking in other languages
        it is for declaring variables locally, not for doing things like magic swap from Python and TS

    auto [x, y, z] = getPointTuple();
        each type is independently inferred
    int [x, y, z] = getPointTuple();
        the non-inferred version (all types same)
    Point pt = {1, 2};
    auto [xx, yy] = pt;

    works with tuple, pair, class/struct, or array
    binding is by order (# must match), not by name

    binding is BY REFERENCE and the righthand side object is KEPT ALIVE for the scope

    overall requirements of object:
        either implement the tuple protocol via specializations OR have the right # of members

[Strings]
Unique Aspects of C++
    heavy reliance on stream operator <<
    literal string vs. stdlib string
    null termination
    strings are not immutable!
    no named capture groups
    some common string methods missing: split, trim
    various ways to split, none of which behave in the usual way with respect to empties
    line ending conversion less permissive (more manual interention needed)

// and /* */ comments

Literals
    "" -> const char *
    '' -> char
    u8"" and u8'' -> seem to mean same thing (implying utf-8)

    L'' -> wchar_t
    L"" -> const wchar_t *

    u'' -> char16_t
    u"" -> CONST CHAR16_t *

    U'' -> char32_t
    U"" -> char32_t

    \ escaping, and also '' inside "" and vice versa are fine
        eg. \n to add newlines

    R"()" -> raw string (const char * still)
        yes - it needs the () and does not include that in the string (weird!)
            the reason is so you can use " inside without escaping
        includes newlines
    LR"()" -> the wchar_t version of raw string
    uR"()", UR"()" -> et. etc.

    string literals are generally safe to pass around because stored statically

Character
    char (and wchar_t) is both a numeric type and a character type
    if you print it with std::cout, it will print as a character
        have to cast to int if want to see the number
    but you can also store a number there and do math with it

    char16_t and char32_t act more like pure numbers
        because std::cout is not designed for them
        but they still take string literals with their own syntax as above
        these are basically utf-16 and utf-32
            not literally but something like that
    
    <cctype> header (for char)
        toupper(c)
        tolower(c)
        isalpha(c), islower(c), isdigit(c), etc.

    <cwctype> header (for wchar_t)
        towupper(c)
        towlower(c)
        iswalpha(c), iswlower(c), iswdigit(c), etc.

C-Strings
    the default null-terminated type of string created by literals
    only immutable if use const char *
        regular char * is a mutable c-string
    similarly, wchar_t * for L"" strings

std::string (and std::wstring)
    <string> header (for both)
    basically acts like a vector<char>
        plus string-related functionality on top of that
        mutable
        some operations that usually only take iterators will also accept indices
            with string::npos (-1) representing the not found or end index
    actually a typedef of std::basic_string<char>
        std::wstring is a typedef of std::basic_string<wchar_t>
        so they both are the same interface with a different char element type
        below, the char version will be used for demonstration for simplicity

    string s = "Hello, world!";
    string s = "Hello, world!"s;
        this literal type with trailing s is supposed to avoid copying c-string in c'tor
        but it doesn't seem to work in any IDE I tried as of 2023 (maybe soon?)

    there are a LOT of constructors
        c-strings, copy other strings, counts, etc.
    also similar assignments and assign() method

    s.data() for access to underlying array
    s.c_str() for const c-string copy (null-terminated)
    conversion operator to std::basic_string_view

    element operations, appending, iteration, etc. exactly like vector
        not an immutable structure at all

    traits_type
        typedef for getting character traits

    length() means same thing as size() [both here]

    insert() has more overloads for ways to put strings inside the string
    append(), operator+, operator+=
        string concatenation
        different from push_back() which takes a character
        overloaded for other strings, char*, single char, etc.

    these string methods have a lot of overloads to restrict range, etc.
        compare(), starts_with(), ends_with()
        replace()
            does not modify the string, returns a new string
        substr()
            new copy
        copy()
            copies chars into target char* array (no null termination)

        find(), rfind(), find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of()
            searching for substrings or chars and returning indices
            the *_of versions are looking for one of a sequence of chars (instead of whole sequence)
    
        stoi(), stol(), stof(), etc.
            convert to number
            std::invalid_argument thrown if bad conversion

            to go the other way:
                std::to_string(number)
                std::to_wstring(number)
    
    operator<, operator==, etc.
        lexographic comparison

    non-member functions
        std::swap(), std::erase(), std::eraser_if(), std::reverse(), etc.

    Case
        you can use std::transform with std::toupper() and std::tolower() to change case
        case insensitive comparison is not built-in
            you'd have to do your own comparison or convert to lower first
std::u16string and std::u32string
    the typedfs of basic_string for char16_t and char32_t
see <codecvt> header for converting between the various encodings

Equality
    == works on std::string to compare contents
    const char * == would compare addresses intead
    same issue with operator< and such

Formatting
    <cstdio>
        printf(formatString, arg1, arg2, ...)
            %2d, %.2f, etc.
            prints to console
        sprintf(target, formatString, arg1, arg2, ...)
            print into a char[] instead of to the console
            no allocation or checking on target - you need to make sure it can hold it
                for this reason, clang considers it deprecated (but the C++ spec still does not)
            null terminates the string
        snprintf(target, n, formatString, arg1, arg2, ...)
            like sprintf() but with a maximum count n for safety
            n includes the null character (so n-1 characters max)
    <cwchar>
        wchar_t versions of <cstdio> functions
        wprintf()
        swprintf() [takes n like snprintf, no unsafe version available]
        
    <sstream>
        stringstream s;
        s << "Integer: " << 15 << ", Float: " << 3.2;
        std::cout << s.str() << std::endl;
        s.str("new str");  // reset to a new string
        s.str(""); // clear to start over again
        s.str(std::string()); // clear to start over again
        
        s >> x; // converting string to number (skipping preceding whitespace and stopping at whitespace)
            can chain together whitespace-delimitted things: s >> a >> b >> c;

        also see notes about "Printing" below
            <iomanip>, std::endl, etc. can be used here too
            manipulators do not reset when you reset to ""
            use s.clear() to reset all state including manipulators
    
    <iostream>
        see "Printing" below
        <iomanip> header to help with formatting
    
    mystring.replace() can be used to replace a template string like "{name}" too

StringBuilder
    the equivalent of StringBuilder in C++ is to just use std::string
        it can already append, concat, etc. and reallocate as needed, exactly like StringBuilder
    however, an even more idiomatic way is to std::stringstream to stream together parts of the string

Printing
    <iosstream>
        std::cout << "Hello, my name is " << name << " and I am " << x << years old. << std::endl;
        std::cout is a global variable of type std::ostream (from <ostream> header)
        std::wcout is the wchar_t version
    
        std::endl
            prints newline and flushes
            std::cout is line-buffered, but std::stringstream is not
            the buffer won't print until the next std::endl
        std::flush
            flush without printing a newline
            don't do unless you have to (if the newline will not be coming on time)

        you can stream in return values of <iomanip> functions to control formatting as well
            std::setw(10) sets width of numbers to 10
            std::boolalpha says print booleans as words
                from <iostream>
            std::setpreicion says use 3 significant digits for float
            these manipulators are persistent (continue until set again, even after newlines)

Object(s) to String
    std::stringstream and std::cout (which is an std::ostream) are both at least std::ostream
        from <ostream> header
        so if you overload operator<< (eg. as a friend function) with your type on the right
            then return the ostream&
            your object will be supported in both std::cout and std::stringtream stream operations

    several built-in types already overloaded, but not the big collections
    the wide version is std::wostream (same header)

String to Object(s)
    overload operator>> on std::istream from <istream> header

    several built-in types already overloaded, but not the big collections
        the wide version is std::wostream (same header)

    then you can create an std::istringstream (from <sstream>) for a string:
        std::istringstream iss(inputString);
    then you read from it like this:
        iss >> x >> y >> z;
    an overload for an object can read individual fields and return the istream by reference

NOTE: stringstream is an ostringstream and istringstream at same time
    you can directly use the o or i version if that's all you need in context
    they are all in <sstream> header

Regular Expressions
    <regex> header

    regex pattern(R"(\d+)");
    bool match = regex_search(s, pattern); // pattern somewhere in string
    bool match = regex_match(s, pattern); // whole string matches pattern
    string replaced = regex_replace(s, pattern, replacement);

    smatch matches;
    while (regex_search(s, matches, pattern)) {
        // capture groups in matches object
        // by index only with []

        matches.suffix().str();  // to go to next match
    }
        matches is iterable with strings that matched
        also indexable with [] (eager)

Splitting
    no method on std::string like you'd see in other languages
    there are a few different ways to do it

    std::vector<std::string> v(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>());
        std::istream_iterator (from <sstream> header) iterates through chunks in the istream
            exactly as if you used >> on the stream directly, but without having to know how many variables
        the default constructor of std::istream_iterator is the end of stream iterator
            same as the first iterator will become after you increment it enough
        so this code will construct a vector to hold all the items from doing >> repeaedly on the string
        initial and trailing whitespace will be ignored because of how std::istream works
            and things in the middle will be split by regions of whitespace
    
    std::string token;
    while (std::getline(is, token, ',')) {
        v.push_back(token);
    }
        std::getline (from <string> header) will read text until delimiter and then consume the delimiter (ignoring it)
        the default delimitter is \n
        it will include empty strings for duplicate delimitters, even at beginning or end
            one final delimitter is allowed at the end without causing an empty string

    There is also a `std::sregex_token_iterator`
        to iterate through parts of a string that don't match a pattern (such as `\\s+`).

    you can also split a string using strtok/wcstok (see "C String Functions")

Trimming
    no method on std::string like you'd see in other languages
    use methods like find_first_not_of and find_last_not_of (or find_if with forward and reverse iterator)

Line Endings
    converted to \n on file read (in text mode)
    converted to platform-dependent from \n on file write (in text mode)
    conversions depends on where program is running
        so could get mismatch if dealing with file from diferent system
    \r\n for windows, \n for everybody else

C String Functions
    old-fashioned functions that operate on c-strings
    no bounds checking
    <cstring> and <cwchar> headers for char vs. wchar_t
    for the wchar_t versions, replace 'str' in the name with 'wcs'
        eg. strlen -> wcslen

    strlen(str)
        length of string by searching for null
    strcpy(target, source)
        copy a string from one buffer to another (inc. null)
    strcat(target, source)
        concatenate source string to end of target string
        original null of target is 1st char of source after copy
    strcmp()
        compare two strings
    strtok(str, delims)
        tokenize using delimitters
        searches for first char that is in delimitter
            delims is a string but acts like array of characters
        put a null there and return str

        on future calls, strtok(nullptr, delims) to continue from last operation
            continues to return pointer to new token (while destructively changing original)
        does not include empty entries for duplicate, leading, or trailing delims

std::stringview (and std::wstringview)
    <string_view> header for both
    typedefs of std::basic_string_view

    non-owning, lightweight wrapper for pointing within a string or char[]
    points to beginning and end of a region within a string
    operations like substr() supported but just change the numbers instead of allocating anything
        and a lot of other string operations

    you can construct it with a string literal, an array, std::string iterators, etc.
    
    supports printing to std::cout (and ostream in general) directly

std::format
    <format> header
    as of writing this, still missing from VSCode and Clang (newer feature in the spec)

    std::string returning version of sprintf with some tweaks to the format specifier language
    {} instead of % (like the new Python f-strings)

[Operators]
Unique Aspects of C++
    overloading inside or outside classes
        Koenig lookup
    spaceship operator
    many different kinds of casts

all the usual arithmetic, bitwise, logical, and comparison operators
    inc. assignments, pre and post increment and decrement, ternary, etc.
    / is floor division toward zero
    don't forget <<= and >>= as well

not present:
    coalescing (can simulate with std::optional)
    safe navigation
    spread

Truthiness
    logical operators like && return bool
    use of objects inside conditional operators relies on bool() conversion
    numeric types are false if zero, true otherwise
        including pointers
    stdlib collections do not implement bool() conversion and cannot be used directly this way
        nor can arrays since they will be seen as pointers and always true unless nullptr

sizeof()
    sizeof(int)
        getting size of a data type on the current system
    sizeof(x)
        getting size of a variable
    sizeof(arr)
        for an array, it depends on whether it's local
        local array will get the actual size (in bytes)
        otherwise, it will give the size of the pointer
    sizeof(MyClass)
        get total storage size of class in memory
alignof()
    alignof(MyClass)
        gets alignment of the class on current system
        eg. 4 to align to 32-bit boundaries
alignas()
    looks like alignof(), but it's more of a specifier
    says the variable needs to be aligned to the boundaries of another type
    can align classes, arrays, single values, etc.

    eg. alignas(long long) int arr[100];
    eg. alignas(16) int x; // explicit # bytes

Reflection
    typeid(x).name()
    typeid(x) == typeid(y)
        true only if exact same type (not just compatible like base and derived)
Casting
    long y = x; // implicit widening (coercion)
        also works for taking base pointer/reference from derived object
    int y = (int)x; // c-style casting
    int y = int(x); // function-style casting (basically c-style)
    int y = static_cast<int>(x); // c++style casting
        for most simple casts
            eg. number conversions (up or down)
            eg. derived to base pointer
            eg. enum to int and vice versa
    DerivedClass *p = dynamic_cast<DerivedClass*>(x);
        polymorphic cast using RTTI (runtime type information)
            only works if enabled (the default)
        returns nullptr if the cast fails
            doesn't throw
    int *p = const_cast<int*>(q);
        removes the constness of the variable so you can change it
        try not to do this unless there's a super incredible reason
    char *p = reinterpret_cast<char*>(q);
        uses same pointer address but changes pointer arithmetic
        eg. can treat a class structure as a stream of bytes by using char
        be careful of things like padding ane endian-ness

    see "Classes" for info on overloading the cast operators!

decltype()
    decltype(x)
        represents type of a variable at compile-time
        eg. decltype(x) a;  // variable a declared with same type as x

Equality 
    == and !=
        work as you'd expect on primitives
            with coercion as needed 
        on pointers, compares the address
        on class instances, uses operator== overload
    stdlib collections, inc. std::string, overload operator==
        eg. strA == strB will do contents comparison, not check if same object
            unlike with const char * (the built-in literal type) which will probably fail
        
Move, Copy, Construction
    see "Classes" for details as all these can be overloaded in various ways
    for primitives it's simple - always copy

Spaceship Operator
    <=>
    3-way comparison
        same logic as a comparator for sorting (<0, 0, >0)
    provides a way to implement one operator as the base for all 6 comparisons (<, >, ==, <=, >=, !=)
        by using <=> and then applying logic that is always the same to derive these from it

    return types from <compare> header
        eg. std::strong_ordering indicates only <, >, ==

    defaulting for a class results in element-wise spaceship operator
        or possibl derived from comparison operators on class (ambiguous in the docs)
    default operator== and operator!= will try to generate based on spaceship
        but use == on members if no spaceship
    
    operator<, operator>, operator<=, and operator>= still have to be implemented
        can't just default them even though always the same

    don't ask ChatGPT too much about this topic
        it saw too many draft proposals or something

    typical ways to implement based on members is lexographically, like this:
        auto operator<=>(const Point& other) const {
            if (auto cmp = x <=> other.x; cmp != 0) return cmp;
            return y <=> other.y;
        }

[Control Flow]
Unique Aspects of C++
    RAII
    no 'finally' because of RAII
    class destructor predictable, allowing scope-based context management
    switches only for numbers

the usual C-like stuff: if/else if/else, switch, for, while, do/while, break, continue
    bodies with or without braces
{} (with nothing in front of it) to make blocks within blocks for scope

for loops
    don't forget you can use commas for multiple variable
        or leave parts empty between ;;
        or have no body by putting ; after the ()

range-based for loops
    newer (C++ 11) construct that follows what other modern languages do
    works on anything iterable or a built-in array type

    for (int n : nums) {}
    for (auto n: nums) {}
    for (int &n: nums) {}
    for (auto &n: nums) {}

switch
    has fallthrough and default
    braces not required around case bodies
    still only for numeric types (inc. strongly-typed enums)

variables can be declared in conditional blocks
    similar to what for loops do
    eg. if (int x = getX()) {}
        only executes if x is nonzero because that result is what is checked

if-init
    fairly new (C++ 20)
    if (int y = x * 2; y % 2 == 0) {}
    2 stages - first we initialize the variable, then we check the condition
    benefit: lets you use y in the block without it having to have been zero or nonzero w/ condition

Exceptions
    can inherit from std::exception <stdexcept>
        define char* what() {} method to get a message
    generally anything is throwable though, even an integer

    try {
        throw std::runtime_error("Uh oh!"); // throw by value on new instance
    }
    catch (int e) {
    }
    catch (std::exception &e) {
        // will be caught here by reference
    }
    catch (char) { // type with no variable
    }
    catch (...) { // default catch
    }

    there is no 'finally' keyword, but destructors can clean up
        RAII idiom

Asserts
    <cassert>
        assert(condition)
            only in debug mode
    static_assert(condition, message)
        compile-time assertion
        fails compilation with error if false
        eg. assert that an integer template parameter is in the range it was designed for
        eg. assert that an integral type (std::is_integral) is passed as template arg
        no effect on runtime performance

Context Management
    no 'with' or try-with-resources construct because of RAII behavior of C++
    but could make a context management class that manges scope
        destructor ends the context - predictable in C++ unlike others
    can control granularity within functions using anonymous {} blocks

Generators/Laziness
    nothing built-in until "ranges" feature in C++ 20 (covered in Functional Programming)
    can implement your own iterable object to have it act lazily

main() function
    int main() {}
        ignoring args
    int main(int argc, char *argv[]) {}
        argc >= 1
        argv[0] = program part of the cmdline
    void main() {}
        not standard, don't rely on it

    return value of main() is error code for OS
        0 = success

[Functions]
Unique Aspects of C++
    can get TCO under right circumstances
    const reference passing
        protecting the actual object instead of the variable
    returning a new object requires special considerations while in garbage collected languages it's simple
        eg. return by value and end up with copies (RVO might help)
        eg. return by pointer and then the caller has to manage lifetime?
        eg. return by reference and then have to worry about lifetime
    returning by reference and modifying original based on it
    because of the massive number of ways to overload functions, documentation looks crazy for even a simple method or constructor
        eg. constexpr, const, move, copy, assignment vs. c'tor, etc.
    variadic args are not type-safe or bounds checked
    macros existing at all (unusual for OOP), and being text substitution (as opposed to Lisp)
    array decay
    controlling linkage & calling conventions

Free Function
    term for a function that is not a class method

Overall Syntax
    int f(int a, int b) { return a + b; }
    void g() {}

    int x = f(10, 20);
    g();
Prototypes
    the interface of the function can be declared ahead of time
        eg. in header file
        eg. in same file, before main code, providing body after code
    then other files can compile against it, while keeping implementation hidden
    this is not required, but is very common
    for free functions, declaration order matters!

    eg. for the above "overall syntax" examples:
        int f(int a, int b);
        void g();

    technically, param names can be ommited in prototype, or even given names that don't match
        eg. void f(int, int = 10);
        the names are for the benefit of the implementation, not the compiler at the callsite
        though they also help people using the API
Unique Identity of Function
    the return type, name, and param # and types
    param names are not part of the identity
        thus, you can't overload by only param names
    return type is, but it's not overloadable by itself
    this allows lambdas, etc. to work without having to name things consistently

    in places where you would often ommit arg names, like function pointers, you can provide them
        and the names are allowed to not match

    const and & are part of the param types in method signature
        sometimes ommitting in one place or other will work, but better to specify
        can technically overload by just const or &, but creates ambiguities

Inline
    functions that are provided without separate prototypes are NOT automatically inline
    you can put the 'inline' keyword before a function to request that it becomes inline
        eg. if frequently used and small, and want to eliminate function call overhead
    the compiler still has the ability to choose whether to inline or not in either case
        think of it more as a "hint" or "request"
        takes into account size, complexity, frequency of calling, etc.
    if you have a separate prototype and implementation, and the implementation is in a separate source file
        you cannot inline it
        because inlining is done on C++, not machine code
    class methods are special in that they are automatically requested inline if in the class prototype
        no 'inline' keyword
        non-inline if body is provided outside with ::
        still up to the compiler

Default Args
    specify with = on the prototype (if separate)
    the function itself still has the parameter
        compiler will put in the default value at the callsite
    must come at end (no empty entries in middle)
Const and Ref Args
    behave just like variables
    good way to pass large objects without copying
        and specifying whether they're mutable or not
    temporary objects (rvalues) can only be passed by reference if const reference
        and then be careful of ambiguity with passing by value, which can trigger compile error
RValue References
    see discussions in "Variables" and "Classes"
    move/copy semantics at the function level
    std::move() on an lvalue, or a temporary object (rvalue) at the callsite
    just doing std::move on an object doesn't itself change it - just calls the rvalue overload if available
        it's then expected that the function would change it and make the old one invalid after
            but if you know that it doesn't, then you can ignore that
    rvalue overload or lvalue overload are ambiguous with passing by value
    but if you have both lvalue overload and rvalue overload
        rvalue has precedence over lvalue for rvalues, even if lvalue ref is const
            lvalue overload cannot even take an rvalue unless const though
        rvalue reference will never take lvalues unless std::move

Keyword Args
    not supported
    use map<> or similar to simulate it
Overloading
    by args only, not return type
        but different overloads can have different return types
    considered static polymorphism

Variadic Functions
    void f(int a, int b, ...);
        args after b in a call to f() can be any type
    <cstdarg> header helps to parse it out
        va_list args;
        va_start(args, b);
            macro to set up va_list variable based on last fixed arg in list
            parses stack frame internally
        va_arg(args, int);
            macro to get next single arg
            you have to tell it the type (not type safe)
            you have to know how many to stop at (not bounds checked)
        va_end(args)
            macro to clean up when done

Returning by Reference
    int& f(int &x) { return x; }
    int a = 100;
    f(a) = 0;
    makes a lot more sense when it's something like elements in a container
    could use const-overloading to protect read-only things in a class method

Return Type Inference
    auto f(int a, int b) { return a + b; }
Trailing Return Types
    auto f(int a, int b) -> int { return a + b; }
    auto f(int a, int b) -> decltype(a+b) { return a + b; }

Array Decay
    when you pass an array, it's really a pointer (not by value)
    the count can be specified or not - the compiler won't use it in any way
        the array has "decayed" - lost its 1st dimension
    note that for multidimensional arrays, only 1 dimension is lost
        because the other dimensions are needed for memory layout
    if you take a 2D slice inside 3D, and pass to a function that takes 2D, it will decay again

Throw Specifications
    you used to be able to specify what exceptions a function can throw
    this was deprecated in C++11 and removed entirely after that
        because it wasn't accurate and gave a false sense of security
    you are still allowed/recommended to specify as 'noexcept' to mean won't throw
        if might throw, for instance via stdlib calls, then just let it throw
    
    void f() noexcept;
    void f() noexcept {}  // probably not needed if has prototype

Recursion
    functions call themselves by name
    TCO is posssible but might require a compiler flag

Linkage
    external linkage = can be seen outside source file
        functions
        global variables
    internal linkage = cannot be seen outside source file
        static variables
        static global variables
        static functions

    normally global variables and top-level functions don't need 'static' because they already are
        but you can mark them as 'static' to change their linkage to internal

    to use a symbol with external linkage in a different source file, you need the prototype
        for functions, it works as we've already described here
        for global variables, you use the 'extern' keyword
            extern int x;  // x is a global variable that will be linked in by the linker
        ok for 'extern' to appear in the real place too, just like how function prototypes can

Calling Conventions
    specifying conventions (and specific ones avilable) is non-standard feature
        varies by compiler
    eg. in MSVC:
        void __cdecl f();
            f will use cdec convention
    common conventions include: cdec, stdcall, fastcall, thiscall
        dictate how params are passed on stack+registers, how things are cleaned up, etc.
Name Mangling
    C++ mangles names to support function overloading
        thus linking with wrong version of ABI (application binary interface) can cause issues
    C does not - so to interop with C code, you may need to turn off name mangling
        extern "C" {}
            everything in {} will be un-mangled
        NOTE: C supports overloading but just doesn't mangle to support it
    a C header that might be included in a C++ program should do this:
        #ifdef __cplusplus
        extern "C" {
        #endif

        // C function declarations

        #ifdef __cplusplus
        }
        #endif
Interop
    C++ can interop with C by using proper un-mangling and calling convention as shown above
    to interop with other languages, you usually need to pretend to be C
    different languages have different mechanisms for interfacing

Coroutines
    new C++ 20 feature not fully supported by compilers yet
    similar to async/await from JS and/or yield from Python, with keywords like co_await, co_yield, and co_return
        returning std::future
    see Coroutines snippet for more details (and check official docs for updates)

Try-Catch Body
    void f() 
        try {
            // function body
        }
        catch(...) {
        }

    NOTE: if a constructor, put initializer list before the 'try'

Macros
    simple text substitution (unlike Lisp)

    #define PI 3.14159
    double x = PI;
        a macro has no type

    #define ADD(a, b) ((a)+(b))
    int x = ADD(10, 20);
        taking parameters
        using () to lexically group

    one of the dangers of macros is they don't follow lexical rules like functions
        #define MULTIPLY(a, b) a*b
        x = MULTIPLY(a+b, c+d)
            you expect this to become x = (a+b)*(c+d)
            but instead it becomes a+b*c+d
    also note NO SEMICOLONS at end of macros
        or else that will become part of the substitution
        end of line = end of macro
    
    use \ to make multiline
        #define ADD(a, b) \
            a + b

    #undef PI
        undefine a macro at this point in the code

    #ifdef PI
    // code or macro definitions in here
    #endif

    also #ifndef, etc.
    used for old-school header de-duping
        #ifndef the whole header and define the macro inside

Not supported: nested functions

[Functional Programming]
Unique Aspects of C++
    lambdas very different
        not fat or skinny arrows, unless you count the trailing return type
        no single-line inline without {} and return
    function pointers can't hold lambdas that capture
    capturing has to be specified very explicitly
    capture by reference is dangerous because not a garbage collected language
    have to put placeholders in partial application
        but can reorder and interleave unbound with bound
    divergence of types of callable things and need for a polymmorphic wrapper
    pipe opeator for lazy stream operations

Function Pointer
    double (*fPtr)(double, double) = multiply;
        fPtr is the variable being declared
        mulitply is a function being passed to it
        note that you don't need to name the params
        note that you don't need to use & on multiply
            though you can if you want to
            you do have to have it for pointers to members though!
    double x = fPtr(10, 20);
        note that you treat it as a function, not as a pointer
        you could do (*fPtr)(10, 20) if you wanted, but it's not necessary

Callable Object
    any object that provides one or more call operator(s)
    eg. double operator(double a, double b) const {return a + b;}
    create the object, then pass/call it like it's a function

Lambda
    [](double num) { return num * 3; }
        can pass this expression directly to a function that wants something callable
    auto triple = [](double num) { return num * 3;}
        the type of a lambda is a secret for the compiler
            but you can bind it to a variable with 'auto'
        tripe(10) will return 30 just like a normal function call
    
    [x,y](){}
        the [] is for capture specification
        in this case, x and y are captured by CONSTANT VALUE (immutable, but independent)
            captured at moment the lambda is created, then independent
    [x,y]() mutable {}
        the mutable keyword says x and y are not constant
        they are still BY VALUE here, but you can treat them like normal local variables
            captured at moment the lambda is created, then independent local variables
    [x, &y](){}
        y is captured BY REFERENCE (not const)
        it can modify the value of y long after the lambda is returned (when called)
        just like any reference variable
        but it does not cause it to stay alive
            so if it's a local variable or deleted, this will cause an issue
    [](){}
        empty capture spec still required, because it tells compiler this is a lambda
    []() -> int {}
        trailing type, if needs to be specified
        usually return type is inferred
        NOTE: do not confuse this with Java arrow functions!
    [this](){}
        this is a variable you can capture like anything else
        eg. to return a lambda from a class method that continues to interact with the class instance
    [=,&y](){}
        automatically capture any variable mentioned in the body by value
        except y which is by reference
    [&,y](){}
        automatically capture any variable mentioned in the body by reference
        except y which is by value
    [=](){}
        default only without exceptions

    can use _, _1, _2, etc. as ignored param names
        no special meaning, technically real variables

    unlike other languages:
        you cannot ommit () ever
        you cannot ommit {} ever
            no single-line inline expressions without return 
        you cannot have types of arguments inferred
            except if call them 'auto', which makes a generic lambda

    auto fn = [](){}
    auto fn2 = fn;
        this is actually a copy!
        any values captured by value or duplicated and independent even if mutable
    auto &fn2 = fn;
        this is not a copy
        you can also capture by reference so that it doesn't matter if it's a copy
    
Pointer to Member (Method Reference from Java)
    Instance Methods
        the class where the method lives is part of the type

        void (MyClass::*unboundPtr)() = &MyClass::printX;
            the * and & are both required here (no leeway like normal functions)
            this is UNBOUND because we used MyClass instead of an instance on the right side
        (instance.*unboundPtr)();
            the * is required here (no leeway like normal functions)
            this calls the unbound function on an instance
        you cannot call an unbound member like a static function
            because that is not the calling convention
            'this' is treated specailly
        an unbound pointer to member must be bound to be callable

        you cannot get a BOUND member function directly from an instance
            you have to get the unbound one and bind it
        auto boundFn = std::bind(&MyClass::printX, obj); // can add other args and placeholders too
            std::bind is smart enough to be able to bind 'this' as the 2nd param
                when the 1st arg is a pointer to member
            even though you can't normally call an unbound method this way
        boundFn();  // call like a free function

        for a virtual method, binding to a more derived class will use the more derived implementation
            because pointers to members still call through the vtable
            in some contexts this is known as being "contravariant"

    Static Methods
        don't actually use pointers to members and bound/unbound concept
        void (*staticfPtr)() = MyClass::printStatic;
            exactly like normal function pointer but with scope resolution to find the function
            optional & on right side just like normal Functions
        staticPtr();
            use like any function pointer

Things You Can Pass to <algorithm> Functions
    eg. std::transform
    functions directly (implicitly as function pointers)
    function pointers (inc. static methods or free functions)
    bound pointers to members
    callable objects (instantiated)
    lambda

Traditional Functional Operations
    map() is implemented by std::transform (or std::views::transform)
    reduce() is implemented by std::accumulate
    filter() is implemented by std::copy_if (or std::views::filter)
    any(), all(), none() are implemented by std::any_of, std::all_of, std::none_of
    zip() is not implemented until C++ 20 with ranges

Type of Function Object
    there is no unifying type to capture all the callable object types
    the type of a lambda is a secret only the compiler knows
        you can use 'auto' and 'decltype' to refer to it

    a function pointer can point to a lambda only if it doesn't capture anything
        once it captures even one thing, then you can't do it
        not sure if it copies or not, and since it doesn't capture, I'm not sure it matters
    
    std::function (from <functional> header)
        polymorphic wrapper for function-like things
        not a base class of function objects, but rather just knows how to wrap them
        including functions, lambdas, function pointers, bound pointers to members, callable objects
        a way to hold all those kinds of things in a single callable interface

        std::function<void(int, int)> fn = someFunction;
            if someFunction is callable with 2 ints and returns void
                we can store it as a variable here, just like a
                function pointer, but more general
        fn(10, 20); // call it just like a function

        see "std function" snippet for example implementation

        std::function will copy rather than reference
            for function pointers, doesn't matter
            for lambdas and callable objects, it matters
                for lambdas, capture by reference if don't want that
                for callable objects, restructure the code
                    eg. pass std::function around by reference

Built-in Function Objects
    in <functional> header

    std::less<T>(), std::greater<T>(), std::equal_to<T>()
        call these functions to get a function object you can pass to do < and > operations
        they invoke operator< and operator> on type T
        you can specialize them for your type to make them do otherwise

    std::plus<T>(), std::minus<T>(), std::multiplies<T>()
        call these functions to get a function object to operate on two objects
        binary operators to do arithmetic operations
        use the arithmetic operators unless you specialize

    std::logical_and<T>(), std::logical_or<T>()
        call these functions to get a function object to operate on two objects
        returns boolean

    std::not_fn(fn)
        negates a predicate

Partial Application
    in <functional> header

    std::bind(fn, arg1, arg2, ...)
        return type is undefined - just use 'auto' for the variable
        you can use std::cref and std::href for reference and constant reference parameters
        for args that you're not binding, you have to use members of the std::placeholders namespace
            _1, _2, etc.
            even if at the end of the list
        the placeholders can appear anywhere in the list and be in any order
            the bind call should look like the whole function call
            then the placeholders are the things passed in when calling the returned function object
                with order determined by their number
    
        int count_less_than_five = std::count_if(nums.begin(), nums.end(), 
                                                 std::bind(std::less<>(), std::placeholders::_1, 5));

        if fn is a pointer to member, then arg1 should be an instance

    std::ref(val), std::cref(val)
        create ref or constant ref of a value for partial application
        basically wraps the value in a wrapper object that takes the appropriate reference internally
        the wrapper implements operators like assignment to forward to the internal value

    std::invoke(fn, arg1, arg2, ...)
        similar to std::bind, except it actually calls the fn
        if fn is a pointer to member, arg1 should be an instance
        this is a way to make a method act like a static function that takes a 'this' first like in Python

    std::apply(fn, tuple)
        apply a tuple as args to pass into fn
        you can pass an std::pair as the tuple as well
        doesn't automatically support pointers to members like std::invoke does

IIFE
    [](){}(); // no need to put () around the lambda
    not a common practice in C++, but could be a way to create a lexical capture point for the args

Generic Lambdas
    if you use 'auto' as a param type or return type in a lambda, it is generic
    once you assign it to a variable, that variable stores an instantiated concrete version
    variable types like function pointers and std::function must use the concrete version only

Mismatched Return Types on Callables
    std::function<void(...)> will ignore return values for you
        but function pointers will not
    other conversions are not done automatically - the types of variables must match exactly

Ranges
    new in C++ 20
        so expect compiler support to be a little bit spotty

    a range is anything that has a begin() and end() for iteration (or is an array)
        basically anything iterable
    <ranges> header has lazy stream operations to operate on ranges without having to pass pairs of iterators
        turn collection into a view, which is a lazy view of the sequence
        then views have | operator overloaded so you can build a pipeline to process the data
            eg. auto filteredView = std::views::all(vec) | std::views::filter(predicate) | std::views::transform(fn);
            eg. vec | std::views::filter(predicate);
                | overloaded for built-in collections like vector and string for you already!
    
    std::views namespace
        all(range)
            get view based on a collection
        iota(a, b)
            get view from a to b (exclusive) step 1
            use other views to change the step if needed
        zip_view(view1, view2, ...)
            zips together

        filter(fn)
            filter view based on predicate
        transform(fn)
            like map()
        take(n)
        drop(n)
        reverse()
            reversed view of whole sequence
        split(delim)
            can be used for string splitting
        join (no parenth)
            flat map a range of ranges
        keys (no parenth)
            getting first item out of range of pairs
        values (no parenth)
            getting second item out of range of pairs

    views are iterable if you want to see their elements
    you can also pass them to constructors that take iterables, to get back to a collection
        std::vector<int> v = oldv | std::views::filter(fn) | std::views::transform(fn2);

[Classes]
Unique Aspects of C++
    classes (and enums) require ; after the closing brace
        nothing else does (not functions, not control blocks, etc.)
    :: for scope resolution instead of just .
    methods are not virtual by default
        this makes it difficult to extend things like stdlib collections like you could in others
        also causes weird name hiding behavior for non-virtuals
    multiple/diamond inheritance
    true destructor called at predictable time
        which leads to RAII idiom
    operator overloading
    no common base class or common interfaces for things like iterables
        instead have behaviors have to conform to in a duck-typed way when using std:: stuff
    const overloading
        allowing you to protect objects the way you can't easily in other languages
    access modifiers are sections instead of individual item modifiers
    use class name over and over (no base, super, etc.)
    subclasses can arbitrarily change access levels of base members (not just increase)
    structs are just classes with different default access
    this-> instead of this.
    no root object of filesystem

Overall Syntax
    // header file (typically)
    class MyClass {
        public:
            int x;
            int y = 100;  // default value
            int z;
            static int s;

            MyClass(int val, const std::vector &vec): y(200), z(1000), m_vec(vec)
            {
                x = val;
                ++s;
            }

            void f() {} // defined inline
            static void g() {} // defined inline

            void h();  // no body - must be linked in by the linker
            static void i(); // no body - must be linked in by the linker

        protected:
            // members only subclasses can see
        private:
            // members only this or other instances of this class can see

            const std::vector &m_vec;
        public:  // can repeat modifier sections to keep adding
    };  // class prototype must have ; at end (very singular for C++)

    // cpp file (typically - if applicable)
    int MyClass::s = 0; // static values must be initizlied outside as if global

    void MyClass::h() {} // implementation for h
    void MyClass::i() {} // implementation for Static
        // note that you don't mark it as static here!

    // client file
    MyClass m(10);
    std::cout << m.x << std::endl;
    std::cout << MyClass::s << std::endl;
    std::cout << m.s << std::endl;  // same as MyClass::s
    m.f();
    m.g(); // or MyClass::g()
    m.h(); // will compile - will only link if the cpp file is properly linked in

Inheritance Syntax
    class BaseClass {
        public:
            BaseClass(int x) {} // c'tor has no return type

            virtual void f() {}
            virtual void g() = 0; // pure virtual

            void h() {} // not virtual

            ~BaseClass() {} // d'tor has no return type
    };

    class DerivedClass : public BaseClass, public OtherClass { // inheriting from 2 classes
        // members just like any other class
        // but can refer to public and protected members of base unqualified

        publc:
            DerivedClass(): BaseClass(10) {}

            void f() override {}  // overriding f
            void g() override {}  // now DerivedClass is a concrete class

            void h() {} // not virtal  (hides base version)
    };

Inline Member Initialization
    provides default values than be be overriden in c'tor init list
    does not have to be compile-time constants
        except for 'static const' variables which do
    static members can't be initialized inline unless also constant ('static const')
        in which case has to be inline, or outside class (not in init list)
    doing something like x(x) where x is a parameter and also a member
        is fine and works correctly
    note that any numeric values not set either inline or in the c'tor list (or c'tor body)
        are initialized to junk just like normal local variables
Constructor Initialization List
    optional, and only has to set the variables you want to set
    another chance to set or override default values of variables
    also the last chance to set references and constants
        compiler will complain if not set by end of this
    runs before the c'tor body, but can take args from the c'tor to help bind

    the c'tor initialization list is also where you can specify base class constructor params
        no need if using default constructor of base
        must be done here - not in the body
    you can also delegate to another c'tor of this class with different overload
        eg. DerivedClass(): DerivedClass(0) {}

    if you provide the c'tor body via a cpp file, but the c'tor init list with the body

Access Modifiers
    only public, private, protected
    default in class is private
    default in struct is public
    default inheritance is private (almost always pick public)
        protected inheritance means public members become protected
        private inheritance means all members become private

    you can arbitrarily change access level of a virtual member in a subclass
        not just increase access like in Java
        the interface you call through determines the access level it has at that moment

    you can change access level without overriding a member like this:
        using BaseClass::f;  // if BaseClass has a private method f() for instance

Interfaces and ABCs
    no special keyword to define an interface or an abstract class
    you make a method abstract (pure virutual) with = 0
    then nobody can instantiate that class, but subclasses can implement it to become concrete
    an interface can be made just by making a class with all pure virtual members

Name Hiding/Virtual Methods
    methods are not virtual by default
    they will exhibit name hiding (which one you get depends on which interface you use)
    if you mark them virtual, then they will behave virtually
    only methods can be virtual (not variables like in scripting languages)
    once a method is virtual in the chain, it is always virtual
        a subclass that defines it as not virtual still gets a virtual one implicitly

    in the past, you would mark derived methods as virtual
    now there's an 'override' keyword you can put between the params and the body
        instead of putting 'virtual'
        do it for overriding pure virtual as well
    helps clarify intent - and gives compiler something to verify
        eg. before if you think you're overriding but you're not, it couldn't tell
Multiple Inheritance
    true multiple inheritance, not just 1 class and interfaces
    good for mixins
Calling Base Method from Derived Override
    within the class:
        BaseClass::f();
            looks static but it's not
    outside the class:
        x.BaseClass::f();
Accessing Hidden Base Member
    in the case of name hiding of variables or methods that aren't virtual
    same syntax as calling base virtual method from derived
    m.BaseClass::x
    or BaseClass::x inside the class
    static members get hidden this way too, and the same syntax bails you out
Diamond Problem
    when you inherit from two classes that both have the same base
    by default, C++ has 2 separate copies of the base
    you have to access them through scope resolution of the two bases with the conflict
        you cannot resolve it with 'using' like you might think
        eg. m.Base1::x
    this can also lead to multiple paths through the inheritance tree depending on which node you cast up/down from

    another way to solve it is virtual inheritance
        class MyClass : virtual public BaseClass {}
    usually you specify virtual inheritence on each of the bases that has the common base
        you don't need to specify it on the derived class that inherits from them both
    basically it means any subclass of these classes must specify its own common base constructor in c'tor list
        thus collapsing to 1 copy of the common base, breaking the ambiguity
    it breaks encapsulation a bit because you are specifying a base multiple levels down instead of immediate

'this'
    this is implicit inside the class when applicable
    if you do use it, remember it's a pointer, not a reference
'new'
    only for dynamic allocation (this is not Java)

Static Members
    mark a variable or method as static
    static variables have an additional requirement
        their "storage" must be specified outside the class declaration (eg. in the .cpp file)
        eg.
            int MyClass::staticVar = 10;
        interesting to note: no 'static' specifier here
            inferred by the compiler because of the class declaration
            you could also interpret this as a global variable that happens to be scoped in the class
        but if 'static const', there is a 'const' specifier here
        eg.
            const int MyClass::staticConstVar = 10;
    static members can be referred to inside the class unqualified just like instance members
    outside the class, either via MyClass::staticthing or via m.staticthing
        only 1 shared thing either way (not a copy like Python)
        first version is better style, more readable
Static Classes
    no such concept as a static-only class like C#
    but you can make a class with all static members, like the Java stdlib does a lot
    give it a private constructor so nobody can instantiate it

Reference Members
    must be bound in c'tor initialization list or inline
Constant Members
    must be bound in c'tor initialization list or inline
    numbers cannot be allowed to stay junk
    'static const' members can't be set in initialization list
        either inline or outside the class like other statics

Nullable Members
    in C++, the only way to have nullable members is via pointers
        because references have to be bound right away
    if you want the class to own the storage, make it a smart pointer

Const Overloading
    any method marked 'const' promises not to change the state of the object
        the compiler won't let it do so
        it also won't allow it to call other non-const methods of the class
        doesn't care what you do with static members though

    eg. void f() const;
    eg. void f() const {}

    when you have a constant variable (by value, reference, or pointer),
        it will only be allowed to call const methods
        this ensures that it remains immutable

    you can overload a method purely by whether it's const or not
        then the const one will be used for constants
        and the non-const one will be used otherwise

    "const correctness" is the technique of applying const wherever you can
        for readability and safety

    to allow a variable to be changed by a const method
        mutable int x;
    an even more dangerous way to get around it is with const_cast (don't do it!)

Memory Layout
    the variables needed + padding to align for the CPU + vtable if virtual members
    automatic variables declared in the class prototype are part of the class storage
    references stored as pointers, secretly

Methods
    anything mentioned in "Functions" section goes for methods too
    inc. all the crazy stuff like trailing return types, etc. etc.

Constructors
    named after the class
    overloadable

    default = the one with no args
        can have body and init list
        can make it protected or private to control who can create object
        all members use default (or init list) values
    parameterized = any other ones that take parameters
    copy = taking const reference to another object of same type
    move = taking rvalue reference (&&) (not const) to object of same type
        rvalues will prefer move c'tor but use copy c'tor if no move c'tor present
Assignment Operators
    look like constructors but named operator= intead of after the class
        also return the class type itself (usually by reference)
    
    copy = taking const reference to another object of same type
    move = taking rvalue reference (&&) (not const) to object of same type
        rvalues wll prefer move assignment but use copy assignment if none present

Default Operations Included in Class
    default c'tor
        all members defaulted
    copy c'tor
        memberwise copy construction, if all available
    move c'tor
        memberwise move construction, falling back on member copy constructor if not

    copy assignment
        similar memberwise logic to copy c'tor
        does not reuse or rely on copy c'tor
    move assignment
        similar memberwise logic to move c'tor
        does not reuse or rely on move c'tor

    destructor
        does nothing

    if you provide a parameterized constructor (or custom default constructor)
        you lose the automatic default c'tor and move c'tor + assignment
        but you keep the 4 copy/move things
    if you provide a move c'tor or move assignment
        you lose the copy c'tor and assignment
    if you provide a copy assignment
        you lose the move c'tor + assignment
    if you provide a destructor
        you lose the move c'tor + assignment
    any of the above can be put back using 'default' (see below)

    you can provide your own implementation of any of the above
        including changing the access level

    you can explicitly remove one of the automatic methods above:
        MyClass() = delete;
            removing default constructor
    you can explicitly add one of the automatic methods above:
        MyClass() = default;
            reasons to do this:
                change access level
                restore default c'tor when have parameterized
                be more explicit for readability
                signal using base virtual destructor on purpose

    remember that whether c'tor or assignment is called has to do with variable binding
        instead of whether using = or not

Construction Order
    1. if init list delegates to another c'tor in same class, that whole c'tor runs first
        then the init list and body of this one
    2. base class(es) constructed (possibly taking override from c'tor init list)
    3. inline member initializations (possibly taking overrides from c'tor init list)
        happens instead of the default given with =, not on top of it
    4. init list (whatever didn't override earlier steps)
    5. c'tor body

    WARNING: the vTable is constructed incrementally
        calling virtual method during base construction will call base implementation
Destruction Order
    derived, then base, and so on
Virtual Destructor
    if a class might be used as a base pointer for a more derived type
    and if the base pointer might be used to destroy the derived one (eg. due to placement new or whatever)
    mark the destructor as 'virtual'

Move/Copy Semantics
    whether constructor or assignment is called does not depend on whether () or = used
        depends on whether the variable has already been initialized or not
        sometimes = will call a constructor (if it's the first initialization)

    MyClass m;  // default constructor called
    MyClass m(10); // parameterized constructor called
    MyClass n = m; // copy constructor called
    MyClass n = std::move(m);  // move constructor called
    Myclass n(std::move(m)); // move constructor called

    n = m;  // copy assignment called
    n = std::move(m); // move assignment called

    a move assignment/constructor is expected to steal data from the source
        for instance, if source has a vector, use std::move again to invoke on the vector to steal it

'this'
    this is a pointer of type MyClass* (for instance)
    thus, you have to use -> intead of .

Hashing & toString()
    no methods for these like in Java and Python
    see "Collections" for how to do it
        "Implementing Elements for Collections" and "Custom Hasher"

Nested Classes
    classes inside other classes act like static classes in Java
    visibility subject to the section they're in
    but the nested class and enclosing class don't automatically see each others' private members

    classes can also be declared inside function bodies, unlike Functions
Anonymous Class
    not a 1st class language feature, but you could declare a class in the function and instantiate it
    if it implements some interface, then nobody outside would ever know what it is really
        same could be true of a private class, though at least that's in the header
    note that it does not close around local variables like in other languages

Friend Classes
    inside the class prototype:
        friend class TheOtherClass;
    now TheOtherClass can see all the private members of instances of this class
Friend Functions
    inside the class prototype:
        friend void f();
    now f() can see all the private members of instances of this class
    very useful for operator overloading where the overload has to live outside

    alternatively, define the friend function inside the class
        friend void f() {}
    since it's declared friend, it is not a true member of the class
        can't even be called through the class like a static method
    to call it from outside, you have to define a prototype for it outside
        do not include the class or scope resolution in the name
        not needed if it's an operator
    this is a way to keep the overloaded operator code all physically inside your class

Operator Overloading
    some operators done as members, some done as friend functions
        usually if something else on left side (or could be on either side), it's friend function
        some operators can be overloaded either way
    have some flexibility about whether to use value, ref, const ref params and returns
        but there are some standards that are usually always about the same
    you can overload your own operator overloads too (eg. const overloading)
    prototypes of operators can be formatted flexibly:
        eg. operator+()
        eg. operator + ()
    operators don't get auto-implemented in terms of each other
        eg. implementing = does not implement +=
        eg. implementing == does not implement !=
    
    some syntax examples:
        MyClass& operator=(const MyClass& rhs);

        ReturnType operator()(ArgType1 arg1, ArgType2 arg2, ...);
            // call operator can be overloaded to provide different ways to call too

        ValueType& operator[](KeyType key);
        PointerType* operator->();

        friend std::ostream& operator << (std::ostream& out, const Complex& c);

        explicit MyClass(const std::string& str);
        operator int() const;
    the list of operators you can overload is huge
        math, logic, assignment, indexing, conversions, streams, etc.
    conversions
        from other to this = constructors
            used by static_cast<> automatically
        from this to other = operator
        either one can be marked as 'explicit' to prevent implicit conversion
            then it will require static_cast<> to be used
        
        implicit conversion will widen numbers if needed and then convert 1 level
            to make args match a prototype

        conversion operators don't have return types because the operator is the return type
            also since they're words instead of symbols, format like this: operator int()
    
    overloads are found via ADL (Argument Dependent Lookup)
        namespaces of all the arguments checked if not found in current namespace
Defaulted Comparisons (C++ 20)
    operators like operator== are not automatically created for a class
    but there are defaults you can implement by specifying = default
        only if the members are compatible

    operator==
        memberwise ==
    operator<=>
        memberwise <=>

    depending what you read and how you ask the question,
        just defaulting == and <=> might default the other 5 comparison operators

Forward Declarations
    in order for classes to use each other, they need to know enough info to do what they're doing at that moment
    for instance, in order to take a reference or pointer to another class, you only need to know that it's a class
    but to access its members, you need the whole prototype

    eg. if ClassA and ClassB both have methods that take references to each other
        then you can forward declare B so that A knows how to store a reference
        then A comes before B, so B already knows what A is
        then put the bodies of the methods in the cpp file so that the whole structure is known in the implementation

    class ClassB;  // forward declares that ClassB is a class, so ClassA can take references/pointers to it in prototype

    this is a special case where you're allowed to "redefine" a symbol (because it's really defining it in phases)
        also an extension of the idea of how function prototypes work

References Types vs. Value Types
    this concept doesn't exist in C++ because it's not a reference-based language
    all types are value types, in that they prefer to copy when they can
    but you make them references and const references to make it more efficient or share data

struct vs. class
    struct and class are almost the same thing now
        though struct is usually used for POD types
    a struct is just a class with these differences:
        default public instead of private members
        default public inheritence instead of private
    these things make it nicer to add members and bases with more compact syntax

    padding is not different between classes and structs
        to use a struct to access a structure in a file, in either case, you need to tell it not to pad
            via compiler-specific pragmas, etc.
                eg. #pragma pack

'final' classes/methods
    class MyClass final : public MyBase {}
    void f() final {}

    prevent overriding a method or inheriting from whole class
    note that unlike in Java, 'final' and 'const' are both keywords meaning differnet things

Covariant Return Types
    yes

Uniform Initialization
    when you use {} instead of () or nothing
        eg. MyClass m{1, 2, 3};
        eg. MyClass m = {1, 2, 3};
        eg. Myclass m = MyClass{1, 2, 3};  // this is actually not a copy
        eg. f({1, 2, 3}) // f(MyClass m)
        eg. MyClass *m = new MyClass{1, 2, 3};

    C++ has this order of precedence for what the values inside will mean:
        1. if the class has a c'tor that takes std::initializer_list, {} will populate that list
            std::initializer_list is a lightweight wrapper around a temporary array
            raw arrays also act this way
        2. if at least one user-defined c'tor is prsesent:
            {} will be used for args
            c'tor matched based on args passed in
                eg. {} for default c'tor
        3. otherwise, if all members public (like in a struct by default):
            {} specifies the fields in order
            just like it always did prior to the introduction of uniform initialization

    can also be used to explicitly convert:
        eg. int n{o}; // same as int n(o);
    when used with numeric types, makes it default to zero instead of junk
        eg. int x{};  // instead of int x;
        // same as int x();
    can also use it to specific specific numeric value
        eg. int x{100};

    arrays always supported this:
        int arr[] = {1, 2, 3, 4, 5};
    but this syntax means you can also do this:
        int arr[]{1, 2, 3, 4, 5};

What To Ommit From Function Body in Source File
    'static'
    access specifier
    'virtual', 'override', 'final'
    you need the rest of it, including 'const', reference, etc.

Object Suicide
    delete this; // from within a class method
        after that point, do not access any members!
    
    the caller may still have a pointer/reference, but it's invalid now!

    this is a very niche pattern
    where you know the object is on the heap
    and other things like smart pointers, etc. won't do

vtable 
    dynamic dispatch of virtual functions
    if no virtual functions, no vtable
    array of function pointers, pointing to most derived version of each method
        built incrementally during construction through the inheritance chain
    casting between base and derived pointers safe because vtable is structured properly for that
    for diamond inheritance, it's less straightforward
        compiler has to "thunk" the 'this' pointer to point to right vtable
        thus, the memory address of the pointer differs between casts, instead of being the same
    exact placement is not part of the spec
        but commonly, it's pointed to by vptr at beginning of class layout

Typedefs Inside Class
    accessible from inside unqualified
    accessible from outside via scope resolution from class (if public)
        not from instance
        though you could do decltype(instance)::iterator for instance
            in many cases just using 'auto' will do the trick though
    syntactically, it works just like normal typedefs (or using), but just inside the class
        class MyClass {
            public:
                typedef int Integer;
                using Int = int;
        };
        MyClass::Integer x = 5;
    very important feature for standard library containers

Not available:
    extension methods (opreator overloading often achives similar results)
    partial classes (impossible because c++ needs memory layout of class)
    root object
    boxing/unboxing
    auto-implemented properties (get; set;)

[Templates]
Unique Aspects of C++
    compile-time templating instead of runtime generics
    duck-typed like Python instead of dynamically polymorphic
        eg. by having a begin() and end() that returns something that implements -> and *
            you have an iterable container
            if you violate the contract, you'll get errors from the template calling things
    static polymorphism
        can "virtually" call a derived method via template without that method by virtual
        also, wrappers like std::function act polymorphic
            but don't do any inheritence or virtual
    metaprogramming
    arguments that aren't types
    default arguments
    template specializations
    variadic Templates
    no raw type
        even static members live on the specific type

you cannot directly cast between collections of different element types

when a type arg represents the type of a callable object:
    MyClass<void(int, int)>
        MyClass gets 1 type, which is a callable that takes two ints and returns void
    since tempalates are duck-typed, this matches anything callable like that
        function pointer, lambda, etc.
    MyClass<int(void)>
        this is what it looks like with no args
    MyClass<int()>
        this is also fine

[Imports/Modules]
Header vs. Source File Conventions
    usually these go in the header:
        class prototype
        function prototype
        extern variables
    usually these go in the source file:
        non-inline class methods
        class static variables
        non-inline function bodies
        global variable initialization

[stdlib]
Unique Aspects of C++
    relies very heavily on templates, static polymorphism, and duck typing
        no common bases/interfaces like other languages
    things that you would normally use an interface for in other languages
        you would specialize a template for, or else just add members/operators to make it fit

stdlib headers put stuff in std namespace
headers that start with c (from the C standard library) do as well
    but some things also available in global namespace
    std:: versions are more typesafe in many cases

<optional>
    optional<T>
        can set to a T or to std::nullopt
        can coalesce with o.value_or(default)

[Annotations]
none in the traditional sense
attributes with [[]] but only certain built-in ones and only the c++ compiler uses them

[ToDo]
unique_ptr delete [] vs. delete
casting between arrays covariantly
vector of base class scenario
std::accumulate more details
even more <algorithm> functions
even more <functional> functions
even more <iterator> functions
add printing without newline to OOP template
failbit
not c++ related: my notes elsewhere say corecursion is alternative to queue for BFS (corecursion uses queue)
data members 
std::any
templates and decltype
