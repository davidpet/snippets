** rewrite of this sheet is in progress **
** steps:
** 1. go through notebooks again in detail and merge into what's here (mostly replace, but make sure nothing missed)
** 2. sync with Java quick notes to see if any topics missed (from here and notebooks)
** 3. sync with python quick notes for the same reason (probably less to find from there, but some stuff like operator overloading will match)
** 4. see if any new versions since last time (and mark current version here)

** because C++ is unique in many ways, this sheet has a lot of topics the other languages don't **
** the "unique aspects of C++" portions are in this sheet and not in notebooks diretly **

[Playground]
https://cpp.sh/ - to try things out quickly to answer questions

[General]
more complex with a lot more parsing edge cases than other languages
    eg. most vexing parse
this is because of a few reasons:
    - philosophy of radical backward compatibility
    - philosophy of providing total control over memory and execution
    - long history with diverse needs serving embedded, desktop, etc.
see snippet 10 of Language-Specific Features for more details

[Code Layout]
header vs. source file
forward declarations
directives & macros (preprocessor)

[Variables]
Unique Aspects of C++
    stack vs. heap allocation of all types
        automatic variables for stack
        potential memory leaks for heap (have to use smart pointers or call delete)
    just making a variable causes automatic allocation, constructor call, etc.
    just making a global variable causes code to execute before main
        with possibly undefined order due to things like DLL loading, 
            lack of order guarantees between modules, etc.
    operators can end up calling a lot of code secretly due to operator overloading
    = can be a constructor call or assignment operator call depending on context
    pointers and references (and nothing like the concept of reference from other languages)
    direct, unamanged access to blocks of memory
    no reference vs. value type
        everything is value type and will get lots of expensive copying if not careful
    lack of garbage collection on references/pointers
    unsigned integers
        not strictly unique, but a lot of languages don't have (Java, Python, TypeScript, etc.)
    multiple ways to refer to same primitive types
    differences in type sizes on platforms
    junk-initialized variables
    inline static variables
    need ; after {} for enums, structs, unions, classes
    explicit control over things like constexpr, alignas, etc.

Primitive Data Types
    literals need suffixes if greater than int or less than double

    char, bool -> usually 8-bit
        char can be treated either as a number or a character
    short int, short -> usually 16-bit
    int, long, long int -> usually 32-bit
        literal suffix = UL for unsigned long
    long long, long long int -> usually 64-bit
        literal suffix = LL for signed, ULL for unsigned

    wchar_t - 16-bit or 32-bit depending on platform
        usually 16 on Windows, 32 on Linux
    char16_t and char32_t - utf-16 and utf-32 (approximately)
        not as fully supported by things like std::cout

    float - usually 32-bit
        literal suffix = f
    double, long double -> usually 64-bit
        literal suffix = L for long double

    UNSIGNED: add 'unsigned' before any integral type (inc. char)
    SCIENTIFIC NOTATION: -3e-4, 2e7, 0.1e-10, etc.

    pointers are also a primitive type and are covered separately below
        references are not a primitive in the same way
Declarations
    int x, int y;  // both initialized to junk
    int z = 10;
    int a = 10, b = 20, c;

    int *x, y, *&z = x; // crazy mixing (due to how * and & bind to variable)

    const int x = 10; // x can never change again
        when you take a pointer or reference to this variable
        it will look at whether you declared the pointer or reference as 'const int'
        if you did not, it won't let you do it!
        that is to stop you from going around the constness of the variable
        you could technically const_cast it to go around it but you shouldn't generally
    const int x; // ILLEGAL (must initialize it inline)
    const MyClass m; // ok if has a DEFAULT CONSTRUCTOR

    static int x;
        variable created first time code passes through this point
        then continues to live and see changes

        note that 'static' is a "storage specifier" and is not part of the type of the variable
            whereas 'const', '&", and "*" are
            this means 'static' is not seen by 'auto' or typedefs
Global Variables
    any variable declared at the global scope (not in a function, class, etc.)
    initialized before main() called
    available for whole duration of program
    they're basically the same thing as static variables
        the main difference is their visibility
        and also when exactly they get initialized
Scope & Visibility
    ordinary block-scoping like you'd expect
    none of the weird JS 'var' or Python every variable behavior
    you can also use {} to make blocks within blocks arbitrarily

References
    int &x = y;
        x always refers to y and cannot be rebound
        if y is reassigned, x sees the new value
        if x is reassigned, y sees the new value
        it is a secret pointer dereference underneath
    a reference in a class must be bound in the c'tor initialization list or inline
    MyClass &r = m;
        if r is reassigned, then assignment operator called on m itself
        it is not like references in Java where you are just changing the reference
            that is more like how a pointer behaves here
    const int &x = y;
        x = 100; is ILLEGAL
    const int x;
        int &y = x; is ILLEGAL because non-constant ref to a constant
    int &&x = 100;
        x is rvalue reference
        int &x = 100; is ILLEGAL
    MyClass &&x = std::move(y);
        converting to rvalue reference explicitly using built-in function
        y should be considered invalid/unuseable after that
    & does not chain endlessly like pointers (no &&& for instance)
    sizeof() on a referene is sizeof() the referenced variable, not the secret pointer
Pointers
    int *p = &x;
        p is a pointer to integer (* binds to p)
        & is address of operator
        p holds an address
    int y = *p;
        retrieving x via the pointer
    *p = 100;
        changing x via the pointer

    int **q = &p;
        pointer to pointer (address of variable holding address)
    int y = **q;
        retrieve via double dereference
    **q = 100;
        set via double dereference
    *q = &someVariable
        set the intermediate address instead
    
    int *&r = p;
        r is a reference to an int* (reference to p)
        thus it will act as an int*
    *r = 100;

    func(*p);

    Pointer Arithmetic
        p[n] or *(p + n)
            both add the size of the data type times n, then dereference
        p += 2
            doesn't add 2 to the address, but adds 2 * sizeof(whatever the data type is)
        if reinterpret_cast to char*, you can retrieve/modify individual bytes instead

    Member Access
        p->x
            member x of object pointed to by p
        r.x
            member x of object referenced by r
            or object that actually is r in the first place
        p[2].x
            3rd object in array
        pp[2]->x
            3rd pointer in array dereferenced to object elsewhere
    constant
        const int *p = &x;
            p cannot be used to change the value
            const binds to int, meaning the value itself can't be changed
            but p, the pointer, can be reassigned to a differnet address
            p += 2; // fine
            *p = 10; // illegal
        int * const q = &x;
            in this case, const binds to q instead of the int
            so q itself cannot be changed, but it can be used to change the target value
            *q = 10; // fine
            q = &x; // illegal
        const int * const q = &x;
            can combine by putting in the right places as needed
            count backwards from the variable to put const in between other places in the chain
    size of pointers
        usually 64-bit nowadays
    void*
        void* is a special type that means we don't know what the type is
        since all pointers just store memory addresses and are same size
        any point can implicitly cast to void*
        void* can static_cast to any other * type
        banned operations: pointer arithmetic, dereferencing

Nullability
    nullptr = special literal for pointers that are set to 0
        eg. if (p == nullptr) {}
        eg. const int *p = nullptr;  // otherwise would be junk instead of nullptr
    there is no such thing as a null reference because you are required to bind a reference
    variables that are not pointers or references have no concept of nullability at all
    always remember that both pointers and references can become DANGLING
Dynamic Allocation
    heap instead of stack
    int *p = new int;
    int *p = new int(100);
        allocate the value 100 on the heap
    int *a = new int[100];
        allocate 100 junk values on the heap
    int *a = new MyClass[100];
        only legal if MyClass has default constructor
        100 instances default constructed
    int *a = new int[100]{1, 2, 3};
        specifying the first 3 values
        the rest automatically become 0 instead of junk!
    int *a = new int[100]{0};
        100 zeroes
    int *a = new int[100]();
        100 zeroes
    int *a = new MyClass(arg1, arg2);
        can pass constructor arguments if single value
    int *p = new MyClass;
        default constructor if no args
    
    delete p;
        deallocate a single value
    delete[] a;
        deallocate an array
Automatic Variables
    local variable declarations that don't use 'new'
        stored on stack
    but otherwise look like the examples in Dynamic Allocation
        along with compact versions like this:
            MyClass m;
            OtherClass o(m);
    the automatic variable's destructor is called when it goes out of scope
    an automatic variable in a class's declaration is stored as part of the class
        could be on stack or heap depending on where the class is allocated
        a non-default constructor can be chosen in the class constructor initialization list
            or inline
Smart Pointers
    <memory>
        unique_ptr<int> p(new int);
        *p = 100;
        // no delete needed (called when p out of scope)
        p.reset()
            if want to explicitly release it instead
        
        shared_ptr<int> p = make_shared<int>(100);
        *p = 100;
        shared_ptr<int> q = p;
        *q = 1000;
        p.use_count() will be 2 in this case
        q.use_count() is also 2
        p.reset()
            explicitly release one of them
            or else destructor will do it later
        // refcounted, object deleted when count goes to zero

        neither of these are meant to be mixed with using naked pointers
            assume they have full control of the object
            at least from an ownership perspective
            eg. if you pass a naked pointer from a unique_ptr but never delete it
        one way to use them could be to have a unique_ptr owning a pointer as a class member
            then you could pass the naked pointer however you want
            the class owns the dynamic storage
Default Numeric Values
    all numeric types, including integers, floats, pointers, chars
    initialized to junk if local, instance, or heap allocation
        because just doesn't overwrite whatever was on the stack or heap before
    initialized to 0 if static or global allocation
        because static and global are same storage
        and because the program can hardcode the value in the data segment
Delayed Initialization
    local variables don't HAVE to be initialized unless const and/or reference
    class instance members follow the same rule
        except they can be initialized in constructor initialization list instead of inline
Placement New
    have to import <new>
        but no namespace needed for the operator
    
    MyStruct *ptr = new (&storage) MyStruct(42, 3.14);
        constructors an instance of MyStruct into the memory of the storage variable
        doesn't dynamically allocate anything, so never need to delete
        eg. you could dynamically allocate a block first
            then customize the constructor calls with placement new
    because delete is never called, you will have to call the destructor at some point
        if it's necessary, which it won't be for all classes
            doesn't hurt to just always call it though
        ptr->~MyStruct();
    you could use std::aligned_storage to create storage for this
        <type_traits>
            aligned_storage<sizeof(MyClass), alignof(MyClass)>::type storage;
                this example creates it on the stack and cleans it up automatically
                to do it dynamically, create this with 'new'

Type Aliases
    typedef int Integer;
        anywhere in code you can use Integer as the type
        and C++ will know it's really int
    using Integer = int;
        newer, more readable version of the same thing
    unlike with 'auto', type aliases include const, &, etc.
        eg. using cstringref = const std::string&;
            cstringref r = mystring;  // const reference to mystring
        despite the fact that & normally binds to the variable instead of type

    typedef void(*MyFunctionPtr)();
    using MyFunctionPtr = void(*)();

Examining Numeric Type Properties
    <limits>
        numeric_limits<int>::max()
        numeric_limits<int>::min()
Float Near-Equality
    <cmath> 
        fabs(): absolute value of float
            fabs(a - b) < epsilon
Float Special Values (part of IEEE standard)
    <limits>
        numeric_limits<double>::quiet_NaN()
        numeric_limits<double>::infinity()
        -numeric_limits<double>::infinity()
    <cmath>
        isnan(x)
        isinf(x)
            true for negative infinity as well

Enums
    Old-Fashioned = just int with special compile-time constants basically
        enum Color {
            RED,    // 0
            GREEN,  // 1
            BLUE    // 2
        };

        enum Color2 {
            RED = 3,
            GREEN, // 4 automatically
            BLUE = 10
        };

        Color c = RED; // unqualified compile-time constants for members
        int x = c; // implicitly castable to integer because really integer
        c = (Color)(RED + 1) // not implicitly castable the other way
            use c-style or static_cast
        c can become a value other than the ones provided
        std::cout would see it as an integer and print the number instead of the name

    Strongly-Typed Enums (enum classes)
        enum class TrafficLight {
            RED,
            YELLOW,
            GREEN
        };

        // changing the backing type (integral types only)
        enum class TrafficLight: char { // backed by char insted of int
            RED,
            YELLOW,
            GREEN
        };

        TrafficLight t = TrafficLight::RED;    // qualfied like static
        std::cout cannot print it by default because it's not an integer!
        not implicitly convertible
            static_cast<int>(t) to get the int value
        if (t == TrafficLight::RED) {}
        static_cast<TrafficLight>(2)
            but will accept an invalid number still!

Type Inference
    'auto' keyword = compile-time type inference

    auto a = 5; // int
    auto d = 0.1; // double
    auto s = "Hi!"; // const char * (a special case of inferring 'const')

    auto &x = y; // auto will not infer & because it doesn't know you want that
        if you did auto x= y, it would assign BY VALUE
    auto *p = arr;  // auto can be told there's a * there
    auto p = arr;   // it can also infer it

    const auto &x = y;
    auto &x = y; // if y is constant, then auto will know it needs to make 'const int' here too
        otherwise, auto will not infer 'const' because it has no reason to

    auto fn() { return 5; }

    decltype(a) b = 10;  // type matched to another variable (even if auto)
    decltype(a) d;
    decltype(a + b) c;  // eg. if a and b are two different types and you want the type of the result
    
    auto fn(int a, int b) -> decltype(a+b) {}

    decltype works with generic types in templates too!

Unions
    unions look like structs
        but the members OVERLAP
        effectively it is only storing one of the members at a time
        assigning to another one clobbers it

    union Data {
        int i;
        float f;
        char str[20];
    };
    Data d;
    d.str[0] = 'h';
    d.str[1] = 0;
    d.i = 10; // overwrites d.str completely (and then some)

Structs
    structs are technically as fully featured as classes but with default public members
        see "Classes" for more details
    but for the purpose of this section, they're simple wrappers of data (POD types)

    struct MyStruct {
        int x, y;

        const char *name;
        const char description[100];
    }; // semicolon required

    MyStruct s;
    MyStruct s = {10, 20, "Hello", {}};

    s.x = 100;
Bitfields
    bitfields are a feature of structs
        and probably classes too, but the typical use case is POD structs
    let you specify # of bits to use per field so that you can pack it in tigheter

    struct MyBitField {
        // Bitfield with 1 bit. Can hold values 0 or 1.
        unsigned int is_enabled : 1;
        // Bitfield with 4 bits. Can hold values from 0 to 15.
        unsigned int type : 4;
        // Bitfield with 27 bits. Can hold values from 0 to 134217727.
        unsigned int id : 27;
    };

    assigning outside of range will give compiler warning if it can detect it
        if not, then undefined behavior at runtime
            maybe clobber other fields?

volatile
    like in Java
    stops variable from being cached in registers separately on separate threads
    doesn't make it atomic or mutex-locked or anything like that though

constexpr
    specifies that a variable should be computed at compile-time
    specifies that a function that is given compile-time constants will return a compile-time constant
        making it usable in compile-time constants
    simple loops and conditions are allowed
    offloads some runtime execution to compile-time
        especially things that don't change like precomputed values and lookup tables
    implicitly makes the variable 'const' as well (no way to modify at runtime)

    constexpr int square = 10 * 10;
    constexpr int add(int a, int b) {
        return a + b;
    }
    constexpr int result = add(5, 3);

    you can declare a constexpr constructor on a class
        that will allow you to declare a constexpr variable holding an instance
constinit
    like constexpr, except doesn't make the variable 'const'
    initialized at compile-time, but can be changed at runtime

alignas()
    alignas(int) short x;
    alignas(16) int arr[100];

    see "Operators" for details
    lets you specify the word alignment of a variable in memory for performance

Not Supported: interning/pooling

[Collections]
Unique Aspects of C++
    arrays are really pointers and aren't managed at all
        and are fixed length, requiring a special vector data structure for resixable ones
    multidimesional arrays are layed out contiguously instead of as array of references
        because array is not a reference type (no such concept here)
    immutability via const correctness
    collections don't automatically print or convert to string
    hashing provided by a template specialization instead of member function or passed in (weird!)
    swap() method by reference that works on anything
    algorithm header has a lot of very specific CS (leetcode/interview type) operations
    structured binding declarations look like tuple unpacking
        but behave fundamentally differently, such as taking by reference
    has a decent linked list structure with direct access to internal nodes for O(1) operations
        Java, Python, TS, etc. are missing this

Array
    an array variable is actually a POINTER underneath
        thus, it has no protection or length property
            and is not resizable

    int arr[] = {1, 2, 3};      // [] binds to the variable, not the type (just like a pointer)
        automatid size of 3
    int arr[10] = {1, 2, 3};    // specifying size (unspecified items become zero)
    int arr[10];                // junk values
    int arr[x];                 // can be runtime chosen size

    NOTE: you cannot skip items in the array initializer (other than truncating off the end)

    int *p = arr; // no & needed because arr is already a pointer
    int *q = new int[100];

    MyClass arr[10];    // only legal if has default constructor
        or if you do it dynamically with placement new

    int matrix[][3] = {{1, 2, 3}, {4, 5, 6}};
        you are only allowed to ommit the 1st dimension
        because it lays out contiguously and needs to know the structure
        related to the idea of array decay (see "Functions")
    int matrix[2][3];
    int matrix[][2][3];
    NOTE: a multidimensional array is not the same thing as **
        because it's not storing pointers inside

    arr[0] same as *arr
    sizeof() on an array works if locally defined (and not decayed to pointer)
        sizeof(arr)/sizeof(arr[0]) gives # of elements

trailing commas are allowed in initializers but not function calls
    eg. int arr[] = {1, 2, 3,};
        but not f(1, 2,)

std:: namespace needed in front of all symbols imported from stdlib headers below
    ommitted for brevity in these notes

Common std:: collections members
    all collections have optional std::allocator template arg
        and members like allocator_type and get_allocator()
        this is there in case you want to customize how storage is allocated
    Typedefs
        value_type
            eg. for vector<int>, vector<int>::value_type will be int
        reference, const_reference, pointer, const_pointer
            these are defined in terms of value_type

        size_type = size_t
        different_type = ptrdiff_t

        iterator
            iterating over value_type elements
        reverse_iterator
            like iterator but goes backwards
        const_iterator
            like iterator but can't be used to change elements
        const_reverse_iterator
    Methods to Get Iterators
        begin() and end() for ordinary iterators
            end() is exclusive (eg. one past end of collection)
        cbegin() and cend() for constant iterators
        rbegin() and rend() for reverse iterators (when supported)
        crbegin() and crend() for constant reverse iterators (when supported)
    
        you can do arithmetic on iterators to get # elements, indices, etc.
    Size Methods
        size(), empty()
    Modification Methods
        clear()
        insert(iterator, value)
            insert a value before an iterator
        insert(iterator, srcIterator1, srcIterator2)
            insert a range of values
        insert(iterator, initializer_list)
            insert an std::initializer_list of values (for {} syntax)
        
        emplace(iterator, arg1, arg2, ...)
            like insert(), but a new value is constructed in-place using forwarded ctor args
            some containers will have emplace_back() and similar instead of taking iterator
        
        erase(iterator)
            single value
        erase(iterator1, iterator2)
            range
    Storage Methods
        swap(other)
            cheaply swap storage with another collection of the same type
            iterators remain valid, but stay with the data they come from (not the container)
    Non-Member Helper Functions
        std::swap(container1, container2)
            specialized to cheaply swap storage
        std::erase(container)
            specialized to clear a container
        std::erase(container, value)
            specialized for some containers to erase occurences of value in container
        std::erase_if(container, predicate)
            specialized for some containers to erase elements matching a predicate

    operator<, operator==, etc.
        when available, these tends to do lexographical comparison element-wise
            forwarding the comparison operator down to elements, which may forward again internally

    methods like insert() will add allocation as necessary
        different from the <algorithm> functions which cannot do that because only have iterators

vector<T>: dynamic array
    <vector> header
    a lot of operations mentioned here are present elsewhere
        this is basically the prototypical std collection

    vector<int> v;  // new empty vector
    vector<int> v = {1, 2, 3, 4, 5}; // creating with values
    vector<int> v(10); // 10 zeroes (not junk)
    vector<int> v(10, 100); // 10 100s
    vector<int> v(beginIterator, endIterator); // copy range of another container
    vector<int> v(otherVector); // copy constructor
    vector<int> v = std::move(otherVector); // move constructor

    v = {1, 2, 3, 4, 5}; // std::initializer_list assignment
    v = otherVector; // copy assignment
    v = std::move(otherVector); // move assignment

    v.assign() overloaded similarly to the constructors
        replace contents (inc. adjusting size)

    v[0]
        access by reference (read-write, or read if const)
        no bounds checking
        v[0] = 5;
    v.at(0)
        access by reference (read-write, or read if const)
        bounds checking (throws std::out_of_range)
        v.at(0) = 5;
    v.front() and v.back()
        references to first and last element
    v.data()
        the underlying array
        which can become stale if you modify and it reallocates

    v.size()
        number of elements actually used
    v.empty()
    v.capacity()
        number of elements allocated but not necessarily in use
    v.reserve(n)
        change the capacity
    v.shrink_to_fit()
        try to reduce capacity to match size
    v.resize(n)
        truncate if shrinking
        overload to provide values if growing

    v.push_back(item);
    v.pop_back();
    v.clear();
    v.insert(iterator, count, value)
        in addition to the common insert() overloads usually present
    v.append_range(container)
        like doing push_back() on each item in the iterable container

    v.emplace_back(arg1, arg2, ...)
        like emplace() but goes straight to the back

    operator<, operator==, etc.
        lexographical comparison
        uses memberwise comparison operators on elements from left to right
    no operator+, etc.
        can't use + to concat arrays or vectors like in Python

    random access iterator operations

    specialized for bool to use single bits for compactness

list<T>: doubly-linked list
    <list> header

    basically same interface as vector<T> with these differences:
        also has l.push_front() and l.pop_front()
            equally efficient to the *_back() versions
        insertion/deletion in the middle (via iterator) is O(1)
        no indexing because not random-access
        bi-directional iteration, but not random access

forward_list<T>: single-linked list
    <forward_list> header

    like list<> but only the front operations
    keeps head internally but not tail

map<TKey, TValue>: sorted map (binary search tree)
    O(logn) lookups (no hashing)
    <map> header
    optional template arg for comparison function
        defaults to std::less (as the function, not the result of calling the function)
        you can use type inference to invoke it automatically by using c'tor that takes comparison fn

    value_type is std::pair<const TKey, TValue>
    key_type and mapped_type for TKey and TValue
    key_comparer = the compare template arg (default std::less)

    map<std::string, int> m;
    map<std::string, int> myMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
    also overloads that take comparison function (eg. less())
        default constructs the comparison template arg as Compare()
    and similar overloads to vector
    similar assignment operations to vector as well

    m["Apple"] = 10; // no bounds checking
        inserts if not there, even if you just read it
        no const overload, unlike at()
    m.at("Apple") = with bounds checking (std::out_of_range)
        m.at("Apple") = 20; // by reference

    keyValuePair = m.insert({"Apple"}, 10);
        won't do it if key already exists
        return value tells you what's in there now (either old thing or your new thing)
    m.insert_or_assign(key, value) = method version of using index or at()
        return value to tell you what's in there now (like insert() above)

    m.emplace() will only emplace if the key is not there
        like m.insert()

    m.erase("Apple"); // erase by key

    bi-directional iterable as std::pair<TKey, TValue>
        definitely will want to use 'auto' in the for loop
        and/or possibly structured binding declarations to unwrap the pairs
        this is the only way to iterate (no keys() and values() members like Java)
        the keys are immutable but the values are mutable
            so you can actually update the map in-place this way

    if (m.find("Banana") != m.end()) {
        std::cout << "Map contains key Banana." << std::endl;
    }

    m.extract() to remove and return entries
    m.merge() to merge in another map

    m.contains(key)
    m.count(key)
        0 or 1 for map, but maybe more for multimap
    
    m.upper_bound(key), m.lower_bound(key), m.equal_range(key)
        mostly makes sense for multimaps, but it's in here too
        lower bound = first matching entry
        upper bound = first non-matching entry
            they are same if empty range
        equal_range = pair of both
        entries returned are std::pair, but key is used to find them

    operator<, operator==, etc.
        lexographical comparison of keys (not values)

unordered_map<TKey, TValue>: unsorted version of map
    O(1) lookups
        relying on operator== and hash, but not operator<
    <unordered_map> header
    exposes same interface as map<> but doesn't use a tree internally
    
    instead of Comparer optional tempalate arg, has Hash and KeyEqual
        defaulting to std::Hash and std::equal_to

    constructor has overloads to specify initial bucket count
        you can interact with the buckets and load factor with methods if you really want

    iteration is forward only (no reverse)
        and order between runs is not guaranteed to be consistent

    operator== and operator!=, but not operator<, etc. since no order

set<T>: sorted set (binary search tree)
    O(logn) lookups
        operator==, no hash
    <set> header

    looks a lot like map<> except:
        value_type is T because not pairs
        iteration is over T, not pairs
        no [] or .at() because not indexed (even if ordered)

    can be bi-directional iterated because has an order to it

    you can use set operations from <algorithm> like std::set_union
        those rely on sorted sequences, which this is

    set<int> s;
    set<int> s = {1, 2, 3, 4, 5};

    s.insert(10); // ignores if duplicate
    if (s.find(10) != s.end()) {}
    s.erase(10);

unordered_set<T>: unsorted set
    O(1) lookups
        operator== and hash, but not operator<
    <unordered_set> header
    
    same interface as set<T> except:
        only forward iteration (and order not guaranteed)
        can't use set operations from <algorithm> because not sorted
        for other considerations, see difference between map<> and unordered_map<>

multiset<T>, unordered_multiset<T>
    in <set> and <unordered_set> headers (instead of their own)
    like set and unordered_set, but can add same value multiple times
    when you iterate the set, you'll see the same value multiple times
        not grouped together or anything like that (though the ordered one will put them adjacent)

multimap<T>, unordered_multimap<T>
    in <map> and <unordered_map> headers (instead of their own)
    like map and unordered_map, but can add same key multiple times
    when you iterate, you'll see the same key multiple times
        not grouped together or anything liekt hat (though the ordered one will put them adjacent)
    because of the ambiguity, you cannot use the [] operator or at()
        use m.equal_range(key), m.lower_bound(key), and/or m.upper_bound(key) instead
        these methods make more sense here than in map<> where they also exist

tuple<T1, T2, ....>: mixed type sequence of objects
    <tuple> header
    very unusual collection compared to the others
    instead of an object with methods, you use a bunch of functions
        several of which use template metaprogramming and similar constructs
    one reason it's like this is so other kinds of objects can specialize the templates to act as a tuple
        eg. for structured binding declarations
    the tuple functions are specialized for std::pair, std::array, etc. but not raw arrays

    tuple<int, std::string, double> my_tuple(10, "Hello", 3.14);
    auto my_tuple = std::make_tuple(10, "Hello", 3.14);

    std::get<0>(my_tuple);
        retrieval uses integer template arg in a function, instead of a method
    std::get<0>(my_tuple) = 20; // returns reference

    std::tie(var1, var2, var3) = my_tuple;
        tuple unpacking
        tie object takes variables by reference and sets them from assignment operator

    std::tuple_size<decltype(my_tuple)>::value
        to get # of elements
    std::tuple_elements<decltype(my_tuple)>::type
        to get type of an element
        for declaring another variable to hold the value, for instance

pair<T1, T2>: two possibly different types
    <utility> header

    pair<int, int> p = {1, 2};
    auto p = std::make_pair(1, 2);

    p.first, p.second

    p.swap(q);  // swap elements of two pairs

    operator<, operator==, etc.
        lexographical comparison of items

deque<T>: double-ended queue
    <deque> header

    like a vector with fast insertion and removal at both ends
    random access iteration

    push_front(), push_back()
    front(), back()
    pop_front(), pop_back()

stack<T>
    <stack> header

    s.push()
    s.top()
    s.pop()

queue<T>
    <queue> header

    q.push()
    q.front()
    q.pop()

priority_queue<T>: maxheap by default
    <queue> header
        this one is odd because it isn't in a header named after it
    
    q.push();
    q.top();
    q.pop();

    to make a minheap:
        priority_queue<int, std::vector<int>, std::greater<int>> q;
            the middle arg is because there is no overload with only the 2 args we want
            the middle arg says what kind of container to use for the heap structure

array<T, n>: wrapper for array
    <array> header
    adds std features like size(), etc. while maintaining the performance of the raw array
    makes its own array, rather than wrapping an existing one
    not necessary for using <algorithm> and such though

    array<int, 5> arr = {1, 2, 3, 4, 5};

valarray<T>: numeric processing library
    <valarray> header
    old-fashioned, replaced by newer, better 3rd party libraries
    so old it doesn't have iterators
    supports element-wise operations between valarrays (similar to numpy)
    also slicing and stuff like that

bitset<n>: bit mask with n bits
    <bitset> header

    bitset<8> b("01100011");
    bitset<8> b;    // all zeroes

    b.set(4);   // set a bit
    b.get(4);   // test a bit (whether set or not)

    b.reset(), b.count(). b.flip()
    b[i]

    bitset<8> c = a & b;    // bitwise AND on all the bits
        and other bitwise operators

    supports stream operations for output (as binary digits)

Iteration
    no interfaces, classes, or operators for iteration
    instead, it's a pattern of operations that would work on it (duck-typed)
        basically certain pointer-like operations
        different kinds of iterators depending on which subset of pointer-like operations

    MyClass::iterator it = m.begin();
    advance(it);
    *it to get value

    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        std::cout << *it << std::endl;
    }

    a custom iterator should implement:
        * operator
        != operator
        ++ operator

        [] operator if random access
        pointer arithmetic if random access

    a custom iterable object should implement:
        begin() method to return an iterator representing the first item
        end() method to return an iterator representing the exclusive end of the sequence
            which should properly do arithmetic with the other iterators in the sequence
        begin() and end() are same for empty sequence

    a lot of functions, such as the ones in <algorithm>, take 2 iterator for a range
        first one is inclusive, second one is exclusive
        they often return an iterator for the value, returning the end iterator if not found or whatever
        this allows the functions to generically iterate over various types of containers by static duck-typing

    note that since iterators are designed to act like pointers, real pointers work too
        which means functions in <algorithm> can be used on arrays
        don't worry about the end iterator being passed the end of the array
            it will only be used for math - not dereferenced

    Categories of Iterators
        Random Access
            support all pointer operations, including [], operator-, etc.
        Bidirectional
            no arithmetic or [], but increment and decrement fine
        Forward
            no arithmetic or [] or decrement
        Reverse
            acts like a forward iterator, but actually points to items of container in reverse
            not directly interoperable with forward iterators, but you can call it.base() to get a forward iterator
                the caveat is that this forward iterator is the element after the current element
                    so that you can use the current reverse item as exclusive endpoint of range
        Input/Output
            single pass

    std::distance
        <iterator> header
        can compute distance of any iterator type
        for random access where operator- is supported, just subtracts
        for other types, will do O(n) opeation to scan between the endpoints

size_t, size_type
    size_t is a system-dependent (but usually unsigned long long) value for sizes/addresses/indices
    it is defined in many standard library headers and used by containers
    it is also typedefed in collections as size_type

    for (vector<int>::size_type i = 0; i < v.size(); i++) {}

    ptrdiff_t is the signed type for pointer arithmetic

Immutability
    no built-in immutable collections or immutable proxies
    but if you declare a variable, reference, or pointer as 'const', you can lock it down
    when you declare it as const, you will only be cable to call 'const' methods on the collection
    this is a key feature of C++ that is much more efficient than the Java proxy way

Aggregation
    <algorithm>
        max_element(iterator1, iterator2)
            returns iterator for max element in range
        min_element(iterator1, iterator2)
            returns iterator for min element in range
        count(iterator1, iterator2, value)
            count occurences of value in range
    
    <numeric>
        accumulate(iterator1, iterator2, seed)
            essentially a reduction using + operator

Slicing
    for arrays, pass a pointer to the beginning of the slice
        have to pass length anyway, so just adjust length to end the slice
    for other containers, you have to std::copy them
        or something similar like use a constructor that takes iterators
            eg. std::vector v(oldvector.begin() + 2, oldvector.end() - 3)

Printing and String Conversion
    besides std::string, the std collections don't have this automatically
    if you try to std::cout a vector, for instance, you'll get an error

Copying/Cloning
    <algorithm>
        copy(srcIterator1, srcIterator2, dstIterator1)
            the space needs to exist (ex. resize the vector first)
        copy_if() = same but with a predicate to decide whether to include
            returns end iterator so you know how many it copied
    constructors that take iterators can also copy
        std::vector<int> v(old.begin(), old.end());

    in general, deep copying is the default in C++ because it is not referenced-based

Conversions
    constructors that take iterators can be used to convert
        because iteration doesn't care what the container type is
    std::set<int> s(vec.begin(), vec.end());
    std::vector<int> v(arr, arr+sizeof(arr)/sizeof(int));

    to get an array from a collection:
        int arr[vec.size()];
        std::copy(vec.begin(), vec.end(), arr);

Sorting 
    <algorithm>
        sort(iterator1, iterator2)
            ascending sort
        sort(iterator1, iterator2, std::greater<int>())
            descending sort
        sort(iterator1, iterator2, fn)
            fn should be an int function on two values of the type of the collection
            < 0 for a < b, == 0 for a == b, > 0 for a > b
            eg. for ints, a - b is perfect
Shuffling
    <random>
        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(numbers.begin(), numbers.end(), g);

Thread Safety
    no built-in collections are build to be thread safe
    there are no thread safe equivalents either
    it is up to you to properly protect your usages with mutexes, etc.

Searching
    most return iterator
        collection.end() if not found 
        iterator - collection.start() if need index
    use reverse iterators to search backwards 

    <algorithm>
        find(iterator1, iterator2, value)
            linear search
            returns iterator
        find_if(iterator1, iterator2, unaryPredicate)
            linear search for matching predicate
            returns iterator
        find_if_not(iterator1, iterator2, unaryPredicate)
            oposite of find_if
            returns iterator

        binary_search(iterator1, iterator2, value)
            for sorted sequence
            returns boolean
        lower_bound(iterator1, iterator2, value)
            also a binary search, but returns iterator
            1st occurence of element if found
            next highest element if not found
        upper_bound(iterator1, iterator2, value)
            binary search returning iterator
            next higher element than value, whether found or not
            the idea is that if you lower lower_bound and upper_bound as the endpoints,
                you have the range of values equal to value in the collection
                so upper_bound is made to be exclusive upper bound
                    equal to lower_bound if value not present (thus giving an empty sequence)

        search(iterator1, iterator2, subiterator1, subiterator2)
            linear search for subsequence within host sequence

Implementing Elements for Collections
    operator== for operations like find()
    specialize std::hash for unordered maps and sets
    operator< for sorting (inc. in sorted maps and sets)
        or a custom comparator function passed into appropriate places
            eg. std::greater<T> to reverse the sort
        also used for binary searching
    override operator<< with ostream& on the left to support converting to string
        compatible with both std::cout and std::stringstream
        built-in collections do not have this

Custom Hasher
    specialize the std::hash template
    std::hash instance is callable with a value to hash
    use xor to combine hashes of members of your class

    namespace std {
        template <>
        struct hash<MyClass> {
            size_t operator()(const MyClass& obj) const {
                // Combine the hashes of individual members
                return hash<int>()(obj.getId()) ^ hash<string>()(obj.getName());
            }
        };
    }

    collections will automatically use std::hash<T>, which will pick up your specialization

Swap
    <algorithm> swap(a, b) method swaps two items BY REFERENCE
    so it can be used for anything - variables, array elements, dereferenced pointers, etc.

Other Algorithms
    <algorithm>
        a lot of these have _if versions to apply a predicate to decide first
            and some also have _if_not
        also, the simplest versions are shown here, but they have a LOT of overloads
            eg. predicates to guard operations and operators to transform values
        this is a very small list compared to the amount of functions in <algorithm>
            there are a lot of interview/leetcode type operations in there

        reverse(iterator1, iterator2)
        for_each(iterator1, iterator2, voidFn)
        replace(iterator1, iterator2, oldValue, newValue)
        fill(iterator1, iterator2, value)
        remove(iterator1, iterator2, value)
            shifts elements forward toward beginning of collection
            returns iterator to 1st now invalid item
        unique(iterator1, iterator2)
            similar to remove(), but removes duplicates in sorted range
        all_of(iterator1, iterator2, predicate), any_of(), none_of()

        rotate(iterator1, newStartIterator, iterator2)
            rotates the elements so that newStartIterator becomes the new first element
            returns iterator to the new location of iterator1 element
        next_permutation(iterator1, iterator2)
            next lexographic permutation of sequence w/ wraparound
        prev_permutation(iterator1, iterator2)
            opposte of next_permutation()

        transform(iterator1, iterator2, outputIterator, unaryOperator)
            like map() in functional programming

        set_union(), set_difference(), set_intersection(), set_symetric_difference()
            all these expect two SORTED ranges
            output into a 3rd range and return end iterator (past last element) so you know how many

        iota(iterator1, iterator2, startValue)
            fills a range with increasing integer sequence starting with startValue
        partial_sum(iterator1, iterator2, outputIterator)
            computes inclusive prefix sum of each element in the sequence

        mismatch(range1Start, range1End, range2Start, range2End = range2Start + (range1End - range1Start))
            finds first mismatch between two ranges via operator==
            returns a pair of iterators, the last iterator for each of the two ranges
            if mismatch found, the iterators will point to the mismatching element from each
            if not found, at least one of the iterartors will be an end iterator
                both if equal size ranges
        adjacent_find(iterator1, iterator2)
            gets iterator to first pair of elements that match each other in a range

Predicates, Operators, etc.
    see "Functional" section
    you can use these with overloads of <algorithm> functions so you don't have to make your own lambdas, etc.

Destructuring
    the feature is called "Structured Binding Declarations" in C++
        it looks like but is not exactly equivalent to destructuring or tuple unpacking in other languages
        it is for declaring variables locally, not for doing things like magic swap from Python and TS

    auto [x, y, z] = getPointTuple();
        each type is independently inferred
    int [x, y, z] = getPointTuple();
        the non-inferred version (all types same)
    Point pt = {1, 2};
    auto [xx, yy] = pt;

    works with tuple, pair, class/struct, or array
    binding is by order (# must match), not by name

    binding is BY REFERENCE and the righthand side object is KEPT ALIVE for the scope

    overall requirements of object:
        either implement the tuple protocol via specializations OR have the right # of members

[Strings]
Unique Aspects of C++
    heavy reliance on stream operator <<
    literal string vs. stdlib string
    null termination
    strings are not immutable!
    no named capture groups
    some common string methods missing: split, trim
    various ways to split, none of which behave in the usual way with respect to empties
    line ending conversion less permissive (more manual interention needed)

// and /* */ comments

Literals
    "" -> const char *
    '' -> char
    u8"" and u8'' -> seem to mean same thing (implying utf-8)

    L'' -> wchar_t
    L"" -> const wchar_t *

    u'' -> char16_t
    u"" -> CONST CHAR16_t *

    U'' -> char32_t
    U"" -> char32_t

    \ escaping, and also '' inside "" and vice versa are fine
        eg. \n to add newlines

    R"()" -> raw string (const char * still)
        yes - it needs the () and does not include that in the string (weird!)
            the reason is so you can use " inside without escaping
        includes newlines
    LR"()" -> the wchar_t version of raw string
    uR"()", UR"()" -> et. etc.

    string literals are generally safe to pass around because stored statically

Character
    char (and wchar_t) is both a numeric type and a character type
    if you print it with std::cout, it will print as a character
        have to cast to int if want to see the number
    but you can also store a number there and do math with it

    char16_t and char32_t act more like pure numbers
        because std::cout is not designed for them
        but they still take string literals with their own syntax as above
        these are basically utf-16 and utf-32
            not literally but something like that
    
    <cctype> header (for char)
        toupper(c)
        tolower(c)
        isalpha(c), islower(c), isdigit(c), etc.

    <cwctype> header (for wchar_t)
        towupper(c)
        towlower(c)
        iswalpha(c), iswlower(c), iswdigit(c), etc.

C-Strings
    the default null-terminated type of string created by literals
    only immutable if use const char *
        regular char * is a mutable c-string
    similarly, wchar_t * for L"" strings

std::string (and std::wstring)
    <string> header (for both)
    basically acts like a vector<char>
        plus string-related functionality on top of that
        mutable
        some operations that usually only take iterators will also accept indices
            with string::npos (-1) representing the not found or end index
    actually a typedef of std::basic_string<char>
        std::wstring is a typedef of std::basic_string<wchar_t>
        so they both are the same interface with a different char element type
        below, the char version will be used for demonstration for simplicity

    string s = "Hello, world!";
    string s = "Hello, world!"s;
        this literal type with trailing s is supposed to avoid copying c-string in c'tor
        but it doesn't seem to work in any IDE I tried as of 2023 (maybe soon?)

    there are a LOT of constructors
        c-strings, copy other strings, counts, etc.
    also similar assignments and assign() method

    s.data() for access to underlying array
    s.c_str() for const c-string copy (null-terminated)
    conversion operator to std::basic_string_view

    element operations, appending, iteration, etc. exactly like vector
        not an immutable structure at all

    traits_type
        typedef for getting character traits

    length() means same thing as size() [both here]

    insert() has more overloads for ways to put strings inside the string
    append(), operator+, operator+=
        string concatenation
        different from push_back() which takes a character
        overloaded for other strings, char*, single char, etc.

    these string methods have a lot of overloads to restrict range, etc.
        compare(), starts_with(), ends_with()
        replace()
            does not modify the string, returns a new string
        substr()
            new copy
        copy()
            copies chars into target char* array (no null termination)

        find(), rfind(), find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of()
            searching for substrings or chars and returning indices
            the *_of versions are looking for one of a sequence of chars (instead of whole sequence)
    
        stoi(), stol(), stof(), etc.
            convert to number
            std::invalid_argument thrown if bad conversion

            to go the other way:
                std::to_string(number)
                std::to_wstring(number)
    
    operator<, operator==, etc.
        lexographic comparison

    non-member functions
        std::swap(), std::erase(), std::eraser_if(), std::reverse(), etc.

    Case
        you can use std::transform with std::toupper() and std::tolower() to change case
        case insensitive comparison is not built-in
            you'd have to do your own comparison or convert to lower first
std::u16string and std::u32string
    the typedfs of basic_string for char16_t and char32_t
see <codecvt> header for converting between the various encodings

Equality
    == works on std::string to compare contents
    const char * == would compare addresses intead
    same issue with operator< and such

Formatting
    <cstdio>
        printf(formatString, arg1, arg2, ...)
            %2d, %.2f, etc.
            prints to console
        sprintf(target, formatString, arg1, arg2, ...)
            print into a char[] instead of to the console
            no allocation or checking on target - you need to make sure it can hold it
                for this reason, clang considers it deprecated (but the C++ spec still does not)
            null terminates the string
        snprintf(target, n, formatString, arg1, arg2, ...)
            like sprintf() but with a maximum count n for safety
            n includes the null character (so n-1 characters max)
    <cwchar>
        wchar_t versions of <cstdio> functions
        wprintf()
        swprintf() [takes n like snprintf, no unsafe version available]
        
    <sstream>
        stringstream s;
        s << "Integer: " << 15 << ", Float: " << 3.2;
        std::cout << s.str() << std::endl;
        s.str("new str");  // reset to a new string
        s.str(""); // clear to start over again
        s.str(std::string()); // clear to start over again
        
        s >> x; // converting string to number (skipping preceding whitespace and stopping at whitespace)
            can chain together whitespace-delimitted things: s >> a >> b >> c;

        also see notes about "Printing" below
            <iomanip>, std::endl, etc. can be used here too
            manipulators do not reset when you reset to ""
            use s.clear() to reset all state including manipulators
    
    <iostream>
        see "Printing" below
        <iomanip> header to help with formatting
    
    mystring.replace() can be used to replace a template string like "{name}" too

StringBuilder
    the equivalent of StringBuilder in C++ is to just use std::string
        it can already append, concat, etc. and reallocate as needed, exactly like StringBuilder
    however, an even more idiomatic way is to std::stringstream to stream together parts of the string

Printing
    <iosstream>
        std::cout << "Hello, my name is " << name << " and I am " << x << years old. << std::endl;
        std::cout is a global variable of type std::ostream (from <ostream> header)
        std::wcout is the wchar_t version
    
        std::endl
            prints newline and flushes
            std::cout is line-buffered, but std::stringstream is not
            the buffer won't print until the next std::endl
        std::flush
            flush without printing a newline
            don't do unless you have to (if the newline will not be coming on time)

        you can stream in return values of <iomanip> functions to control formatting as well
            std::setw(10) sets width of numbers to 10
            std::boolalpha says print booleans as words
                from <iostream>
            std::setpreicion says use 3 significant digits for float
            these manipulators are persistent (continue until set again, even after newlines)

Object(s) to String
    std::stringstream and std::cout (which is an std::ostream) are both at least std::ostream
        from <ostream> header
        so if you overload operator<< (eg. as a friend function) with your type on the right
            then return the ostream&
            your object will be supported in both std::cout and std::stringtream stream operations

    several built-in types already overloaded, but not the big collections
    the wide version is std::wostream (same header)

String to Object(s)
    overload operator>> on std::istream from <istream> header

    several built-in types already overloaded, but not the big collections
        the wide version is std::wostream (same header)

    then you can create an std::istringstream (from <sstream>) for a string:
        std::istringstream iss(inputString);
    then you read from it like this:
        iss >> x >> y >> z;
    an overload for an object can read individual fields and return the istream by reference

NOTE: stringstream is an ostringstream and istringstream at same time
    you can directly use the o or i version if that's all you need in context
    they are all in <sstream> header

Regular Expressions
    <regex> header

    regex pattern(R"(\d+)");
    bool match = regex_search(s, pattern); // pattern somewhere in string
    bool match = regex_match(s, pattern); // whole string matches pattern
    string replaced = regex_replace(s, pattern, replacement);

    smatch matches;
    while (regex_search(s, matches, pattern)) {
        // capture groups in matches object
        // by index only with []

        matches.suffix().str();  // to go to next match
    }
        matches is iterable with strings that matched
        also indexable with [] (eager)

Splitting
    no method on std::string like you'd see in other languages
    there are a few different ways to do it

    std::vector<std::string> v(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>());
        std::istream_iterator (from <sstream> header) iterates through chunks in the istream
            exactly as if you used >> on the stream directly, but without having to know how many variables
        the default constructor of std::istream_iterator is the end of stream iterator
            same as the first iterator will become after you increment it enough
        so this code will construct a vector to hold all the items from doing >> repeaedly on the string
        initial and trailing whitespace will be ignored because of how std::istream works
            and things in the middle will be split by regions of whitespace
    
    std::string token;
    while (std::getline(is, token, ',')) {
        v.push_back(token);
    }
        std::getline (from <string> header) will read text until delimiter and then consume the delimiter (ignoring it)
        the default delimitter is \n
        it will include empty strings for duplicate delimitters, even at beginning or end
            one final delimitter is allowed at the end without causing an empty string

    There is also a `std::sregex_token_iterator`
        to iterate through parts of a string that don't match a pattern (such as `\\s+`).

    you can also split a string using strtok/wcstok (see "C String Functions")

Trimming
    no method on std::string like you'd see in other languages
    use methods like find_first_not_of and find_last_not_of (or find_if with forward and reverse iterator)

Line Endings
    converted to \n on file read (in text mode)
    converted to platform-dependent from \n on file write (in text mode)
    conversions depends on where program is running
        so could get mismatch if dealing with file from diferent system
    \r\n for windows, \n for everybody else

C String Functions
    old-fashioned functions that operate on c-strings
    no bounds checking
    <cstring> and <cwchar> headers for char vs. wchar_t
    for the wchar_t versions, replace 'str' in the name with 'wcs'
        eg. strlen -> wcslen

    strlen(str)
        length of string by searching for null
    strcpy(target, source)
        copy a string from one buffer to another (inc. null)
    strcat(target, source)
        concatenate source string to end of target string
        original null of target is 1st char of source after copy
    strcmp()
        compare two strings
    strtok(str, delims)
        tokenize using delimitters
        searches for first char that is in delimitter
            delims is a string but acts like array of characters
        put a null there and return str

        on future calls, strtok(nullptr, delims) to continue from last operation
            continues to return pointer to new token (while destructively changing original)
        does not include empty entries for duplicate, leading, or trailing delims

std::stringview (and std::wstringview)
    <string_view> header for both
    typedefs of std::basic_string_view

    non-owning, lightweight wrapper for pointing within a string or char[]
    points to beginning and end of a region within a string
    operations like substr() supported but just change the numbers instead of allocating anything
        and a lot of other string operations

    you can construct it with a string literal, an array, std::string iterators, etc.
    
    supports printing to std::cout (and ostream in general) directly

std::format
    <format> header
    as of writing this, still missing from VSCode and Clang (newer feature in the spec)

    std::string returning version of sprintf with some tweaks to the format specifier language
    {} instead of % (like the new Python f-strings)

[Operators]
Unique Aspects of C++
    overloading inside or outside classes
        Koenig lookup
    spaceship operator
    many different kinds of casts

all the usual arithmetic, bitwise, logical, and comparison operators
    inc. assignments, pre and post increment and decrement, ternary, etc.
    / is floor division toward zero
    don't forget <<= and >>= as well

not present:
    coalescing (can simulate with std::optional)
    safe navigation
    spread

Truthiness
    logical operators like && return bool
    use of objects inside conditional operators relies on bool() conversion
    numeric types are false if zero, true otherwise
        including pointers
    stdlib collections do not implement bool() conversion and cannot be used directly this way
        nor can arrays since they will be seen as pointers and always true unless nullptr

sizeof()
    sizeof(int)
        getting size of a data type on the current system
    sizeof(x)
        getting size of a variable
    sizeof(arr)
        for an array, it depends on whether it's local
        local array will get the actual size (in bytes)
        otherwise, it will give the size of the pointer
    sizeof(MyClass)
        get total storage size of class in memory
alignof()
    alignof(MyClass)
        gets alignment of the class on current system
        eg. 4 to align to 32-bit boundaries
alignas()
    looks like alignof(), but it's more of a specifier
    says the variable needs to be aligned to the boundaries of another type
    can align classes, arrays, single values, etc.

    eg. alignas(long long) int arr[100];
    eg. alignas(16) int x; // explicit # bytes

Reflection
    typeid(x).name()
    typeid(x) == typeid(y)
        true only if exact same type (not just compatible like base and derived)
Casting
    long y = x; // implicit widening (coercion)
        also works for taking base pointer/reference from derived object
    int y = (int)x; // c-style casting
    int y = int(x); // function-style casting (basically c-style)
    int y = static_cast<int>(x); // c++style casting
        for most simple casts
            eg. number conversions (up or down)
            eg. derived to base pointer
            eg. enum to int and vice versa
    DerivedClass *p = dynamic_cast<DerivedClass*>(x);
        polymorphic cast using RTTI (runtime type information)
            only works if enabled (the default)
        returns nullptr if the cast fails
            doesn't throw
    int *p = const_cast<int*>(q);
        removes the constness of the variable so you can change it
        try not to do this unless there's a super incredible reason
    char *p = reinterpret_cast<char*>(q);
        uses same pointer address but changes pointer arithmetic
        eg. can treat a class structure as a stream of bytes by using char
        be careful of things like padding ane endian-ness

    see "Classes" for info on overloading the cast operators!

decltype()
    decltype(x)
        represents type of a variable at compile-time
        eg. decltype(x) a;  // variable a declared with same type as x

Equality 
    == and !=
        work as you'd expect on primitives
            with coercion as needed 
        on pointers, compares the address
        on class instances, uses operator== overload
    stdlib collections, inc. std::string, overload operator==
        eg. strA == strB will do contents comparison, not check if same object
            unlike with const char * (the built-in literal type) which will probably fail
        
Move, Copy, Construction
    see "Classes" for details as all these can be overloaded in various ways
    for primitives it's simple - always copy

Spaceship Operator
    <=>
    3-way comparison
        same logic as a comparator for sorting (<0, 0, >0)
    provides a way to implement one operator as the base for all 6 comparisons (<, >, ==, <=, >=, !=)
        by using <=> and then applying logic that is always the same to derive these from it

    return types from <compare> header
        eg. std::strong_ordering indicates only <, >, ==

    defaulting for a class results in element-wise spaceship operator
        or possibl derived from comparison operators on class (ambiguous in the docs)
    default operator== and operator!= will try to generate based on spaceship
        but use == on members if no spaceship
    
    operator<, operator>, operator<=, and operator>= still have to be implemented
        can't just default them even though always the same

    don't ask ChatGPT too much about this topic
        it saw too many draft proposals or something

    typical ways to implement based on members is lexographically, like this:
        auto operator<=>(const Point& other) const {
            if (auto cmp = x <=> other.x; cmp != 0) return cmp;
            return y <=> other.y;
        }

[Control Flow]
Unique Aspects of C++
    RAII
    no 'finally' because of RAII
    class destructor predictable, allowing scope-based context management
    switches only for numbers

the usual C-like stuff: if/else if/else, switch, for, while, do/while, break, continue
    bodies with or without braces
{} (with nothing in front of it) to make blocks within blocks for scope

for loops
    don't forget you can use commas for multiple variable
        or leave parts empty between ;;
        or have no body by putting ; after the ()

range-based for loops
    newer (C++ 11) construct that follows what other modern languages do
    works on anything iterable or a built-in array type

    for (int n : nums) {}
    for (auto n: nums) {}
    for (int &n: nums) {}
    for (auto &n: nums) {}

switch
    has fallthrough and default
    braces not required around case bodies
    still only for numeric types (inc. strongly-typed enums)

variables can be declared in conditional blocks
    similar to what for loops do
    eg. if (int x = getX()) {}
        only executes if x is nonzero because that result is what is checked

if-init
    fairly new (C++ 20)
    if (int y = x * 2; y % 2 == 0) {}
    2 stages - first we initialize the variable, then we check the condition
    benefit: lets you use y in the block without it having to have been zero or nonzero w/ condition

Exceptions
    can inherit from std::exception <stdexcept>
        define char* what() {} method to get a message
    generally anything is throwable though, even an integer

    try {
        throw std::runtime_error("Uh oh!"); // throw by value on new instance
    }
    catch (int e) {
    }
    catch (std::exception &e) {
        // will be caught here by reference
    }
    catch (char) { // type with no variable
    }
    catch (...) { // default catch
    }

    there is no 'finally' keyword, but destructors can clean up
        RAII idiom

Asserts
    <cassert>
        assert(condition)
            only in debug mode
    static_assert(condition, message)
        compile-time assertion
        fails compilation with error if false
        eg. assert that an integer template parameter is in the range it was designed for
        eg. assert that an integral type (std::is_integral) is passed as template arg
        no effect on runtime performance

Context Management
    no 'with' or try-with-resources construct because of RAII behavior of C++
    but could make a context management class that manges scope
        destructor ends the context - predictable in C++ unlike others
    can control granularity within functions using anonymous {} blocks

Generators/Laziness
    nothing built-in
    can implement your own iterable object to have it act lazily

main() function
    int main() {}
        ignoring args
    int main(int argc, char *argv[]) {}
        argc >= 1
        argv[0] = program part of the cmdline
    void main() {}
        not standard, don't rely on it

    return value of main() is error code for OS
        0 = success

[Functions]
Unique Aspects of C++
    can get TCO under right circumstances
    const reference passing
        protecting the actual object instead of the variable
    returning a new object requires special considerations while in garbage collected languages it's simple
        eg. return by value and end up with copies (RVO might help)
        eg. return by pointer and then the caller has to manage lifetime?
        eg. return by reference and then have to worry about lifetime
    returning by reference and modifying original based on it
    because of the massive number of ways to overload functions, documentation looks crazy for even a simple method or constructor
        eg. constexpr, const, move, copy, assignment vs. c'tor, etc.
    variadic args are not type-safe or bounds checked
    macros existing at all (unusual for OOP), and being text substitution (as opposed to Lisp)
    array decay
    controlling linkage & calling conventions

Free Function
    term for a function that is not a class method

Overall Syntax
    int f(int a, int b) { return a + b; }
    void g() {}

    int x = f(10, 20);
    g();
Prototypes
    the interface of the function can be declared ahead of time
        eg. in header file
        eg. in same file, before main code, providing body after code
    then other files can compile against it, while keeping implementation hidden
    this is not required, but is very common
    for free functions, declaration order matters!

    eg. for the above "overall syntax" examples:
        int f(int a, int b);
        void g();

    technically, param names can be ommited in prototype, or even given names that don't match
        eg. void f(int, int = 10);
        the names are for the benefit of the implementation, not the compiler at the callsite
        though they also help people using the API
Unique Identity of Function
    the return type, name, and param # and types
    param names are not part of the identity
        thus, you can't overload by only param names
    return type is, but it's not overloadable by itself
    this allows lambdas, etc. to work without having to name things consistently

    in places where you would often ommit arg names, like function pointers, you can provide them
        and the names are allowed to not match

    const and & are part of the param types in method signature
        sometimes ommitting in one place or other will work, but better to specify
        can technically overload by just const or &, but creates ambiguities

Inline
    functions that are provided without separate prototypes are NOT automatically inline
    you can put the 'inline' keyword before a function to request that it becomes inline
        eg. if frequently used and small, and want to eliminate function call overhead
    the compiler still has the ability to choose whether to inline or not in either case
        think of it more as a "hint" or "request"
        takes into account size, complexity, frequency of calling, etc.
    if you have a separate prototype and implementation, and the implementation is in a separate source file
        you cannot inline it
        because inlining is done on C++, not machine code
    class methods are special in that they are automatically requested inline if in the class prototype
        no 'inline' keyword
        non-inline if body is provided outside with ::
        still up to the compiler

Default Args
    specify with = on the prototype (if separate)
    the function itself still has the parameter
        compiler will put in the default value at the callsite
    must come at end (no empty entries in middle)
Const and Ref Args
    behave just like variables
    good way to pass large objects without copying
        and specifying whether they're mutable or not
RValue References
    see discussions in "Variables" and "Classes"
    move/copy semantics at the function level
    std::move() or a temporary object at the callsite
Keyword Args
    not supported
    use map<> or similar to simulate it
Overloading
    by args only, not return type
        but different overloads can have different return types
    considered static polymorphism

Variadic Functions
    void f(int a, int b, ...);
        args after b in a call to f() can be any type
    <cstdarg> header helps to parse it out
        va_list args;
        va_start(args, b);
            macro to set up va_list variable based on last fixed arg in list
            parses stack frame internally
        va_arg(args, int);
            macro to get next single arg
            you have to tell it the type (not type safe)
            you have to know how many to stop at (not bounds checked)
        va_end(args)
            macro to clean up when done

Returning by Reference
    int& f(int &x) { return x; }
    int a = 100;
    f(a) = 0;
    makes a lot more sense when it's something like elements in a container
    could use const-overloading to protect read-only things in a class method

Return Type Inference
    auto f(int a, int b) { return a + b; }
Trailing Return Types
    auto f(int a, int b) -> int { return a + b; }
    auto f(int a, int b) -> decltype(a+b) { return a + b; }

Array Decay
    when you pass an array, it's really a pointer (not by value)
    the count can be specified or not - the compiler won't use it in any way
        the array has "decayed" - lost its 1st dimension
    note that for multidimensional arrays, only 1 dimension is lost
        because the other dimensions are needed for memory layout
    if you take a 2D slice inside 3D, and pass to a function that takes 2D, it will decay again

Throw Specifications
    you used to be able to specify what exceptions a function can throw
    this was deprecated in C++11 and removed entirely after that
        because it wasn't accurate and gave a false sense of security
    you are still allowed/recommended to specify as 'noexcept' to mean won't throw
        if might throw, for instance via stdlib calls, then just let it throw
    
    void f() noexcept;
    void f() noexcept {}  // probably not needed if has prototype

Recursion
    functions call themselves by name
    TCO is posssible but might require a compiler flag

Linkage
    external linkage = can be seen outside source file
        functions
        global variables
    internal linkage = cannot be seen outside source file
        static variables
        static global variables
        static functions

    normally global variables and top-level functions don't need 'static' because they already are
        but you can mark them as 'static' to change their linkage to internal

    to use a symbol with external linkage in a different source file, you need the prototype
        for functions, it works as we've already described here
        for global variables, you use the 'extern' keyword
            extern int x;  // x is a global variable that will be linked in by the linker
        ok for 'extern' to appear in the real place too, just like how function prototypes can

Calling Conventions
    specifying conventions (and specific ones avilable) is non-standard feature
        varies by compiler
    eg. in MSVC:
        void __cdecl f();
            f will use cdec convention
    common conventions include: cdec, stdcall, fastcall, thiscall
        dictate how params are passed on stack+registers, how things are cleaned up, etc.
Name Mangling
    C++ mangles names to support function overloading
        thus linking with wrong version of ABI (application binary interface) can cause issues
    C does not - so to interop with C code, you may need to turn off name mangling
        extern "C" {}
            everything in {} will be un-mangled
        NOTE: C supports overloading but just doesn't mangle to support it
    a C header that might be included in a C++ program should do this:
        #ifdef __cplusplus
        extern "C" {
        #endif

        // C function declarations

        #ifdef __cplusplus
        }
        #endif
Interop
    C++ can interop with C by using proper un-mangling and calling convention as shown above
    to interop with other languages, you usually need to pretend to be C
    different languages have different mechanisms for interfacing

Coroutines
    new C++ 20 feature not fully supported by compilers yet
    similar to async/await from JS and/or yield from Python, with keywords like co_await, co_yield, and co_return
        returning std::future
    see Coroutines snippet for more details (and check official docs for updates)

Try-Catch Body
    void f() 
        try {
            // function body
        }
        catch(...) {
        }

    NOTE: if a constructor, put initializer list before the 'try'

Macros
    simple text substitution (unlike Lisp)

    #define PI 3.14159
    double x = PI;
        a macro has no type

    #define ADD(a, b) ((a)+(b))
    int x = ADD(10, 20);
        taking parameters
        using () to lexically group

    one of the dangers of macros is they don't follow lexical rules like functions
        #define MULTIPLY(a, b) a*b
        x = MULTIPLY(a+b, c+d)
            you expect this to become x = (a+b)*(c+d)
            but instead it becomes a+b*c+d
    also note NO SEMICOLONS at end of macros
        or else that will become part of the substitution
        end of line = end of macro
    
    use \ to make multiline
        #define ADD(a, b) \
            a + b

    #undef PI
        undefine a macro at this point in the code

    #ifdef PI
    // code or macro definitions in here
    #endif

    also #ifndef, etc.
    used for old-school header de-duping
        #ifndef the whole header and define the macro inside

Not supported: nested functions

[Functional Programming]
Unique Aspects of C++
    lambdas very different
        not fat or skinny arrows, unless you count the trailing return type
    function pointers can't hold lambdas that capture
    capturing has to be specified very explicitly
    capture by reference is dangerous because not a garbage collected language
    have to put placeholders in partial application
        but can reorder and interleave unbound with bound

Function Pointer
    double (*fPtr)(double, double) = multiply;
        fPtr is the variable being declared
        mulitply is a function being passed to it
        note that you don't need to name the params
        note that you don't need to use & on multiply
            though you can if you want to
            you do have to have it for pointers to members though!
    double x = fPtr(10, 20);
        note that you treat it as a function, not as a pointer
        you could do (*fPtr)(10, 20) if you wanted, but it's not necessary

Callable Object
    any object that provides one or more call operator(s)
    eg. double operator(double a, double b) const {return a + b;}
    create the object, then pass/call it like it's a function

Lambda
    [](double num) { return num * 3; }

Pointer to Member (Method Reference from Java)
    ???

Things You Can Pass to <algorithm> Functions
    eg. std::transform
    functions directly (implicitly as function pointers)
    function pointers
    pointers to members
    callable objects (instantiated)
    lambda

Traditional Functional Operations
    map() is implemented by std::transform
    reduce() is implemented by std::accumulate
    filter() is implemented by std::copy_if
    any(), all(), none() are implemented by std::any_of, std::all_of, std::none_of
    zip() is not implemented

Type of Function Object
    std::function (from <functional> header)
            polymorphic wrapper for function-like things
            not a base class of function objects, but rather just knows how to wrap them
            including functions, lambdas, function pointers, etc.

Built-in Function Objects
    in <functional> header

    std::less<T>(), std::greater<T>(), std::equal_to<T>()
        call these functions to get a function object you can pass to do < and > operations
        they invoke operator< and operator> on type T
        you can specialize them for your type to make them do otherwise

    std::plus<T>(), std::minus<T>(), std::multiplies<T>()
        call these functions to get a function object to operate on two objects
        binary operators to do arithmetic operations
        use the arithmetic operators unless you specialize

    std::logical_and<T>(), std::logical_or<T>()
        call these functions to get a function object to operate on two objects
        returns boolean

    std::not_fn(fn)
        negates a predicate

Partial Application
    in <functional> header

    std::bind(fn, arg1, arg2, ...)
        return type is undefined - just use 'auto' for the variable
        you can use std::cref and std::href for reference and constant reference parameters
        for args that you're not binding, you have to use members of the std::placeholders namespace
            _1, _2, etc.
            even if at the end of the list
        the placeholders can appear anywhere in the list and be in any order
            the bind call should look like the whole function call
            then the placeholders are the things passed in when calling the returned function object
                with order determined by their number
    
        int count_less_than_five = std::count_if(nums.begin(), nums.end(), 
                                                 std::bind(std::less<>(), std::placeholders::_1, 5));

    std::ref(val), std::cref(val)
        create ref or constant ref of a value for partial application
        basically wraps the value in a wrapper object that takes the appropriate reference internally
        the wrapper implements operators like assignment to forward to the internal value

Not supported: zip operation

[Classes]
Unique Aspects of C++
    classes (and enums) require ; after the closing brace
        nothing else does (not functions, not control blocks, etc.)
    :: for scope resolution instead of just .
    methods are not virtual by default
        this makes it difficult to extend things like stdlib collections like you could in others
        also causes weird name hiding behavior for non-virtuals
    true destructor called at predictable time
        which leads to RAII idiom
    operator overloading
    no common base class or common interfaces for things like iterables
        instead have behaviors have to conform to in a duck-typed way when using std:: stuff
    const overloading
        allowing you to protect objects the way you can't easily in other languages
    access modifiers are sections instead of individual item modifiers
    use class name over and over (no base, super, etc.)
    subclasses can arbitrarily change access levels of base members (not just increase)
    structs are just classes with different default access
    this-> instead of this.

Static Members
    mark a variable or method as static
    static variables have an additional requirement
        their "storage" must be specified outside the class declaration (eg. in the .cpp file)
        eg.
            int MyClass::staticVar = 10;
        interesting to note: no 'static' specifier here
            inferred by the compiler because of the class declaration
            you could also interpret this as a global variable that happens to be scoped in the class
    static members can be referred to inside the class unqualified just like instance members
    outside the class, either via MyClass::staticthing or via m.staticthing
        only 1 shared thing either way

Reference Members
    must be bound in c'tor initialization list or inline
Constant Members
    must be bound in c'tor initialization list or inline

Memory Layout
    the variables needed + padding to align for the CPU + vtable if virtual members
    automatic variables declared in the class prototype are part of the class storage
    references stored as pointers, secretly

Constructors
    named after the class
    overloadable

    default = the one with no args
        can have body and init list
    parameterized = any other ones that take parameters
    copy = taking const reference to another object of same type
    move = taking rvalue reference (&&) (not const) to object of same type
Assignment Operators
    look like constructors but named operator= intead of after the class
        also return the class type itself (usually by reference)
    
    copy = taking const reference to another object of same type
    move = taking rvalue reference (&&) (not const) to object of same type

Move/Copy Semantics
    whether constructor or assignment is called does not depend on whether () or = used
        depends on whether the variable has already been initialized or not
        sometimes = will call a constructor (if it's the first initialization)

    MyClass m;  // default constructor called
    MyClass m(10); // parameterized constructor called
    MyClass n = m; // copy constructor called
    MyClass n = std::move(m);  // move constructor called
    Myclass n(std::move(m)); // move constructor called

    n = m;  // copy assignment called
    n = std::move(m); // move assignment called

    a move assignment/constructor is expected to steal data from the source
        for instance, if source has a vector, use std::move again to invoke on the vector to steal it

'this'
    this is a pointer of type MyClass* (for instance)
    thus, you have to use -> intead of .

Hashing & toString()
    no methods for these like in Java and Python
    see "Collections" for how to do it
        "Implementing Elements for Collections" and "Custom Hasher"

Not available:
    extension methods
    partial classes

[Templates]
Unique Aspects of C++
    compile-time templating instead of runtime generics
    duck-typed like Python instead of dynamically polymorphic
        eg. by having a begin() and end() that returns something that implements -> and *
            you have an iterable container
            if you violate the contract, you'll get errors from the template calling things
    static polymorphism
        can "virtually" call a derived method via template without that method by virtual
        also, wrappers like std::function act polymorphic
            but don't do any inheritence or virtual
    metaprogramming
    arguments that aren't types
    default arguments
    template specializations
    variadic Templates
    no raw type
        even static members live on the specific type

you cannot directly cast between collections of different element types

[Imports/Modules]
???

[stdlib]
Unique Aspects of C++
    relies very heavily on templates, static polymorphism, and duck typing
        no common bases/interfaces like other languages
    things that you would normally use an interface for in other languages
        you would specialize a template for, or else just add members/operators to make it fit

stdlib headers put stuff in std namespace
headers that start with c (from the C standard library) do as well
    but some things also available in global namespace
    std:: versions are more typesafe in many cases

<optional>
    optional<T>
        can set to a T or to std::nullopt
        can coalesce with o.value_or(default)

[Annotations]
none in the traditional sense
attributes with [[]] but only certain built-in ones and only the c++ compiler uses them

[ToDo]
unique_ptr delete [] vs. delete
casting between arrays covariantly
vector of base class scenario
std::accumulate more details
even more <algorithm> functions
even more <functional> functions
even more <iterator> functions
add printing without newline to OOP template
failbit
